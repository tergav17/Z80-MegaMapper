              	; --------------------------------------
              	; zasm: assemble "KMSX.asm"
              	; date: 2024-09-08 11:15:57
              	; --------------------------------------


              	;
              	;********************************************************************
              	;*
              	;*        K R I S Y S   M S X   1   C O R E
              	;*
              	;********************************************************************
              	
              	#include "KRISYS.asm"
              	;
              	;********************************************************************
              	;*
              	;*              I D E N T I T Y   K R I S Y S
              	;*
              	;*      The [K]lunkly [R]emapper / [I]nterpreter [SYS]tem
              	;*
              	;*             Written by Gavin Tersteeg, 2024
              	;*              Copyleft, All Wrongs Reserved
              	;*
              	;*
              	;*   This piece of software allows different classic Z80 systems
              	;*   to run as "virtual machines" on top of existing hardware by
              	;*   use of a ZMM (Z80 MEGAMAPPER). It does this by remapping RAM
              	;*   and I/O address space ot match that of it's target system.
              	;*   Anything that can't be emulated by simple remapping is instead
              	;*   interpreted using I/O traps. 
              	;*
              	;*   This allows virtualized machines to run with an acceptable
              	;*   degree of speed and accuracy. While the ZMM is still quite
              	;*   limited in what sort of hardware can be efficiently virtualized,
              	;*   anything that avoids MMIO or graphics hardware that isn't a VDP
              	;*   generally can be made to work.
              	;* 
              	;********************************************************************
              		
              	; ----------------------------
              	; ******** ZASM Setup ********
              	; ----------------------------
              	
0020:         	stack_size = 0x20
              	
              	#target BIN
0100:         	#code	_TEXT,0x0100	; Setup to run as a CP/M executable
0D63:         	#code	_DATA,_TEXT_end
12B5:         	#data	_BSS,_DATA_end
              	
              	; Make sure we don't overrun available memory
              	#assert	_BSS_end < (zmm_capture-stack_size)
              	
              	.area	_TEXT
0100: C39409  		jp	kri_start
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
              	; CP/M Stuff
0005:         	bdos		equ	0x0005
0000:         	bdos_exit	equ	0x00
0001:         	bdos_con_in	equ	0x01
0002:         	bdos_con_out	equ	0x02
0009:         	bdos_print	equ	0x09
000A:         	bdos_input	equ	0x0A
000F:         	bdos_open	equ	0x0F
0014:         	bdos_read	equ	0x14
001A:         	bios_set_dma	equ	0x1A
              	
0080:         	cpm_command	equ	0x0080
              	
              	; Z80 MEGAMAPPER Stuff
0030:         	zmm_bnk0	equ	0x30	; 16K Bank 0 (0x0000 - 0x3FFF)
0031:         	zmm_bnk1	equ	0x31	; 16K Bank 1 (0x4000 - 0x7FFF)
0032:         	zmm_bnk2	equ	0x32	; 16K Bank 2 (0x8000 - 0xBFFF)
0033:         	zmm_bnk3	equ	0x33	; 16K Bank 3 (0xC000 - 0xFFFF)
0034:         	zmm_ctrl	equ	0x34	; ZMM Control Register
0030:         	zmm_isr		equ	0x30	; ZMM Trapped Instruction Register
0032:         	zmm_addr_hi	equ	0x32	; ZMM Trap Address High
0033:         	zmm_addr_lo	equ	0x33	; ZMM Trap Address Low
0037:         	zmm_trap	equ	0x37 	; ZMM Trap Vector
              	
7000:         	zmm_capture	equ	0x7000
8000:         	zmm_map		equ	0x8000
C000:         	zmm_top		equ	0xC000
              	
0070:         	zmm_capt_set	equ	0b01110000
007F:         	zmm_capt_res	equ	0b01111111
              	
              	; General Z80 Stuff
0066:         	nmi_address	equ	0x0066
0067:         	nmi_vector	equ	nmi_address+1
              	
              	; NABU Specific Stuff
0000:         	nabu_nctl	equ	0x00	; NABU Control Register
0040:         	nabu_ay_data	equ	0x40	; AY-3-8910 Data Port
0041:         	nabu_ay_latch	equ	0x41	; AY-3-8910 Latch Port
0090:         	nabu_key_data	equ	0x90	; NABU Keyboard Data
0091:         	nabu_key_stat	equ	0x91	; NABU Keyboard Status
00A0:         	nabu_vdp_data	equ	0xA0	; VDP Data Port
00A1:         	nabu_vdp_addr	equ	0xA1	; VDP Address Port
              	
              	; Stack / Trap Management
7000:         	kri_stack	equ	zmm_capture
6FFF:         	trap_a_value	equ	kri_stack-1
6FFE:         	trap_f_value	equ	kri_stack-2
              	
              	; -------------------------------------
              	; ******** Additional Includes ********
              	; -------------------------------------
              	
              	#include "MEMORY.asm"
              	;
              	;********************************************************************
              	;*
              	;*                    Z M M   M E M O R Y
              	;* 
              	;*    The ZMM can be configured to have different amounts
              	;*    of memory installed. Instead of dicking around with 
              	;*    on-board jumpers, KRISYS will simply check what banks
              	;*    are available on startup. Memory will be dynamically
              	;*    allocated as needed by the client process.
              	;*
              	;*    Memory can be assigned to specific owners in the code.
              	;*    Valid owner IDs range from 1 to 254. Owner 0 is reserved
              	;*    for unallocatable banks.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              		
              	; Initalize the memory map
              	; Each bank of the ZMM will be probed, and writable
              	; banks will be recorded on the allocated bank map
              	;
              	; Returns nothing
              	; Uses: AF, BC, DE, HL
0103:         	mem_map_init:
              		; Go to virtual mode
0103: CD9102  		call	zmm_set_virt
              		
              		; Reset free bank counter
0106: 3E00    		ld	a,0
0108: 32B612  		ld	(banks_free),a
              		
              		; Write tags to all banks
010B: 0600    		ld	b,0
010D: 78      	0$:	ld	a,b
010E: CDFB02  		call	zmm_bnk3_set
0111: 3200C0  		ld	(zmm_top),a
0114: ED44    		neg
0116: 3201C0  		ld	(zmm_top+1),a
0119: 04      		inc	b
011A: F20D01  		jp	p,0$
              		
              		; Mark any banks that record correctly
011D: 0600    		ld	b,0
011F: 21B712  		ld	hl,alloc_bank_map
0122: AF      	1$:	xor	a
0123: 77      		ld	(hl),a
0124: 78      		ld	a,b
0125: CDFB02  		call	zmm_bnk3_set
0128: 3A00C0  		ld	a,(zmm_top)
012B: B8      		cp	b
012C: C24401  		jp	nz,2$
012F: 3A01C0  		ld	a,(zmm_top+1)
0132: 4F      		ld	c,a
0133: 78      		ld	a,b
0134: ED44    		neg
0136: B9      		cp	c
0137: C24401  		jp	nz,2$
              	
              		; Mark it
013A: 3EFF    		ld	a,0xFF
013C: 77      		ld	(hl),a
013D: 3AB612  		ld	a,(banks_free)
0140: 3C      		inc	a
0141: 32B612  		ld	(banks_free),a
              		
              		; Next
0144: 23      	2$:	inc	hl
0145: 04      		inc	b
0146: F22201  		jp	p,1$
              		
              		; Disable virtual mode
0149: CD9C02  		call	zmm_set_real
              		
              		; Print out result
014C: 3AB612  		ld	a,(banks_free)
014F: CDFB09  		call	tohex
0152: ED53880D		ld	(str_mem_init_cnt),de
0156: 11630D  		ld	de,str_mem_init
0159: CDB909  		call	cpm_print
              		
              		; Do we actually have an acceptable amount of memory?
015C: 3AB612  		ld	a,(banks_free)
015F: 3D      		dec	a
0160: 3D      		dec	a
0161: FAF301  		jp	m,mem_empty
              		
              		; We do, return
0164: C9      		ret
              		
              	; Fetch byte from virtual memory
              	; HL = Address to fetch
              	;
              	; Returns A = Fetched byte
              	; Uses: AF
0165:         	mem_fvbyte:
              		; Calculate target bank
0165: CD9001  		call	mem_getbank
0168: D333    		out	(zmm_bnk3),a
              		
              		; Grab byte
016A: E5      		push	hl
016B: 7C      		ld	a,h
016C: F6C0    		or	0b11000000
016E: 67      		ld	h,a
016F: 66      		ld	h,(hl)
              		
              		; Restore original bank
0170: 3A3D13  		ld	a,(zmm_bnk3_state)
0173: D333    		out	(zmm_bnk3),a
0175: 7C      		ld	a,h
              		
              		; Return
0176: E1      		pop	hl
0177: C9      		ret
              		
              	; Set a byte in virtual memory
              	; A = Value to set
              	; HL = Address of byte
              	;
              	; Returns nothing
              	; Uses: AF
0178:         	mem_svbyte:
              		; Calculate target bank
0178: 32B512  		ld	(mem_work),a
017B: CD9001  		call	mem_getbank
017E: D333    		out	(zmm_bnk3),a
              		
              		; Set the byte
0180: E5      		push	hl
0181: 7C      		ld	a,h
0182: F6C0    		or	0b11000000
0184: 67      		ld	h,a
0185: 3AB512  		ld	a,(mem_work)
0188: 77      		ld	(hl),a
              		
              		; Restore original bank
0189: 3A3D13  		ld	a,(zmm_bnk3_state)
018C: D333    		out	(zmm_bnk3),a
              	
              		; Return
018E: E1      		pop	hl
018F: C9      		ret
              	
              	; Gets the bank that an address points to
              	; HL = Address to analyse
              	;
              	; Returns A = Value of write-enabled bank
              	; Uses: AF
0190:         	mem_getbank:
0190: 7C      		ld	a,h
0191: 07      		rlca
0192: DAA501  		jp	c,0$
              		
              		; Lower 32K
0195: 07      		rlca
0196: DA9F01  		jp	c,1$
              		
              		; 0-15K
0199: 3A3A13  		ld	a,(zmm_bnk0_state)
019C: E67F    		and	0b01111111
019E: C9      		ret
              		
              		; 16K-31K
019F: 3A3B13  	1$:	ld	a,(zmm_bnk1_state)
01A2: E67F    		and	0b01111111
01A4: C9      		ret
              	
              		; Upper 32K
01A5: 07      	0$:	rlca
01A6: DAAF01  		jp	c,2$
              		
              		; 32K-47K
01A9: 3A3C13  		ld	a,(zmm_bnk2_state)
01AC: E67F    		and	0b01111111
01AE: C9      		ret
              	
              		; 48K-63K
01AF: 3A3D13  	2$:	ld	a,(zmm_bnk3_state)
01B2: E67F    		and	0b01111111
01B4: C9      		ret
              		
              	; Allocates a bank of memory
              	; Will produce an error if no banks are available,
              	; check (banks_free) to avoid
              	; D = Owner ID (1-254)
              	;
              	; Returns A = Bank #
              	; Uses: AF, BC, HL
01B5:         	mem_alloc:
              		; Check and decrement free memory
01B5: 3AB612  		ld	a,(banks_free)
01B8: 3D      		dec	a
01B9: 32B612  		ld	(banks_free),a
01BC: FAF301  		jp	m,mem_empty
              		
              		; Look for the first free bank
01BF: 21B712  		ld	hl,alloc_bank_map
01C2: 018000  		ld	bc,0x0080
01C5: 3EFF    		ld	a,0xFF
01C7: EDB1    		cpir
              		
              		; Make sure we found something
01C9: C2F301  		jp	nz,mem_empty
              		
              		; Save and exit
01CC: 2B      		dec	hl
01CD: 72      		ld	(hl),d
01CE: 01B712  		ld	bc,alloc_bank_map
01D1: B7      		or	a
01D2: ED42    		sbc	hl,bc
01D4: 7D      		ld	a,l
01D5: C9      		ret
              		
              	; Frees a bank of memory
              	; Safe to use on banks that are not free / not owned
              	; A = Bank #
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
01D6:         	mem_free:
              		; Find location in memory
01D6: 0600    		ld	b,0
01D8: 4F      		ld	c,a
01D9: 21B712  		ld	hl,alloc_bank_map
01DC: 09      		add	hl,bc
              		
              		; Check owner
01DD: 7E      		ld	a,(hl)
01DE: BA      		cp	d
01DF: C0      		ret	nz
              		
              		; Free bank
01E0: 3EFF    		ld	a,0xFF
01E2: 77      		ld	(hl),a
              		
              		; Increment banks free
01E3: 21B612  		ld	hl,banks_free
01E6: 34      		inc	(hl)
01E7: C9      		ret
              		
              	; Free all banks by owner
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
01E8:         	mem_free_all:
              		; Free a bank
01E8: AF      		xor	a
01E9: F5      	0$:	push	af
01EA: CDD601  		call	mem_free
01ED: F1      		pop	af
              		
              		; Next bank
01EE: 3C      		inc	a
01EF: F2E901  		jp	p,0$
01F2: C9      		ret
              		
              	; Error out if empty
              	;
              	; Does not return
              	; Uses: N/A
01F3:         	mem_empty:
01F3: 118E0D  		ld	de,str_mem_empty
01F6: CDB909  		call	cpm_print
01F9: C3F309  		jp	cpm_exit
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0D63:         	str_mem_init:
0D63: 494E4954		defb	'INITIALIZED MEMORY MAP',0x0A,0x0D
0D67: 49414C49	
0D6B: 5A454420	
0D6F: 4D454D4F	
0D73: 5259204D	
0D77: 41500A0D	
0D7B: 42414E4B		defb	'BANK COUNT = '
0D7F: 20434F55	
0D83: 4E54203D	
0D87: 20      	
0D88:         	str_mem_init_cnt:
0D88: 5858480A		defb	'XXH',0x0A,0x0D,'$'
0D8C: 0D24    	
              		
0D8E:         	str_mem_empty:
0D8E: 494E5355		defb	'INSUFFICIENT MEMORY',0x0A,0x0D,'$'
0D92: 46464943	
0D96: 49454E54	
0D9A: 204D454D	
0D9E: 4F52590A	
0DA2: 0D24    	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Memory work byte
12B5:         	mem_work:
12B5: 00      		defs	1
              	
              	; Free bank count
12B6:         	banks_free:
12B6: 00      		defs	1
              	
              	; Allocated bank map
              	; This 128 byte table keeps track of every single 16K bank
              	; that exists on the ZMM. Populated on startup
12B7:         	alloc_bank_map:
12B7: 00000000		defs	128
12BB: 00...   	
              	#include "ZMM.asm"
              	;
              	;********************************************************************
              	;*
              	;*                  Z M M   M A N A G E M E N T
              	;* 
              	;*    These routines are used to manage the state of the ZMM.
              	;*    This includes the setting of the registers as well as setting
              	;*    up trap and interrupt stuff.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize ZMM and reset registers
              	;
              	; Returns nothing
              	; Uses: AF
01FC:         	zmm_init:
              		; Zero out control register
01FC: 3E00    		ld	a,0
01FE: 323913  		ld	(zmm_ctrl_state),a
0201: 323A13  		ld	(zmm_bnk0_state),a
0204: 323B13  		ld	(zmm_bnk1_state),a
0207: 323C13  		ld	(zmm_bnk2_state),a
020A: 323D13  		ld	(zmm_bnk3_state),a
              		
              		; See if we can swing in and out of virtual mode
020D: CD9102  		call	zmm_set_virt
0210: CD9C02  		call	zmm_set_real
              		
              		; Tell the user that the ZMM is ready
0213: 11A40D  		ld	de,str_zmm_init
0216: C3B909  		jp	cpm_print
              		
              	; Performs a virtual NMI
              	;
              	; Returns nothing
              	; Uses: AF
0219:         	zmm_nmi:
0219: E5      		push	hl
              		
              		; Get the value of the program counter
021A: 2AFC13  		ld	hl,(trap_sp_value)
021D: 7C      		ld	a,h
021E: E67F    		and	zmm_capt_res
0220: F670    		or	zmm_capt_set
0222: 67      		ld	h,a
0223: 7E      		ld	a,(hl)
0224: 323713  		ld	(zmm_work),a
0227: 23      		inc	hl
0228: 7C      		ld	a,h
0229: E67F    		and	zmm_capt_res
022B: F670    		or	zmm_capt_set
022D: 67      		ld	h,a
022E: 7E      		ld	a,(hl)
              		
              		; Push it onto the virtual stack
022F: 2AFC13  		ld	hl,(trap_sp_value)
0232: 2B      		dec	hl
0233: CD7801  		call	mem_svbyte
0236: 2B      		dec	hl
0237: 3A3713  		ld	a,(zmm_work)
023A: CD7801  		call	mem_svbyte
023D: 22FC13  		ld	(trap_sp_value),hl
              	
              		; Push 0x66 as a return address
0240: 7C      		ld	a,h
0241: E67F    		and	zmm_capt_res
0243: F670    		or	zmm_capt_set
0245: 67      		ld	h,a
0246: 3666    		ld	(hl),0x66
0248: 23      		inc	hl
0249: 7C      		ld	a,h
024A: E67F    		and	zmm_capt_res
024C: F670    		or	zmm_capt_set
024E: 67      		ld	h,a
024F: 3600    		ld	(hl),0
              		
              		; Disable interrupts
0251: F3      		di
              	
0252: E1      		pop	hl
0253: C9      		ret
              		
              	; Start execution of the virtual machine at a specific location
              	; HL = Address to start execution at
              	; 
              	; Does not return
              	; Uses: All registers zeroed
0254:         	zmm_vm_start:
0254: 310000  		ld	sp,0x0000
              		
              		; Completely empty out capture zone
0257: E5      		push	hl
0258: 210070  		ld	hl,zmm_capture
025B: 110170  		ld	de,zmm_capture+1
025E: 01FF0F  		ld	bc,0x1000-1
0261: AF      		xor	a
0262: 77      		ld	(hl),a
0263: EDB0    		ldir
0265: E1      		pop	hl
              		
0266: 7D      		ld	a,l
0267: 320070  		ld	(zmm_capture),a
026A: 7C      		ld	a,h
026B: 320170  		ld	(zmm_capture + 1),a
              		
              		; Reset I/O trap flag just in case
026E: D337    		out	(zmm_trap),a
              		
              		; Zero everything
0270: AF      		xor	a
0271: 47      		ld	b,a
0272: 4F      		ld	c,a
0273: 57      		ld 	d,a
0274: 5F      		ld	e,a
0275: 67      		ld	h,a
0276: 6F      		ld	l,a
0277: D9      		exx
0278: 08      		ex	af,af'
0279: AF      		xor	a
027A: 47      		ld	b,a
027B: 4F      		ld	c,a
027C: 57      		ld 	d,a
027D: 5F      		ld	e,a
027E: 67      		ld	h,a
027F: 6F      		ld	l,a
              		
0280: DD210000		ld	ix,0
0284: FD210000		ld	iy,0
              		
              		; Enter virtual machine
0288: 00      		nop
0289: ED45    		retn
              		
              	; Set the ZMM control register to the recorded state
              	; (zmm_ctrl_state) = New value of ZMM control register
              	;
              	; Returns nothing
              	; Uses: AF
028B:         	zmm_ctrl_set:
028B: 3A3913  		ld	a,(zmm_ctrl_state)
028E: D334    		out	(zmm_ctrl),a
0290: C9      		ret
              		
              	; Go to virtual mode
              	;
              	; Returns nothing
              	; Uses: AF
0291:         	zmm_set_virt:
0291: 3A3913  		ld	a,(zmm_ctrl_state)
0294: F601    		or	0b00000001
0296: 323913  		ld	(zmm_ctrl_state),a
0299: D334    		out	(zmm_ctrl),a
029B: C9      		ret
              		
              	; Go to real mode
              	;
              	; Returns nothing
              	; Uses: AF
029C:         	zmm_set_real:
029C: 3A3913  		ld	a,(zmm_ctrl_state)
029F: E6FE    		and	0b11111110
02A1: 323913  		ld	(zmm_ctrl_state),a
02A4: D334    		out	(zmm_ctrl),a
02A6: C9      		ret
              		
              	; Set program direction to "IN"
              	;
              	; Returns nothing
              	; Uses: AF
02A7:         	zmm_prgm_in:
02A7: 3A3913  		ld	a,(zmm_ctrl_state)
02AA: F602    		or	0b00000010
02AC: 323913  		ld	(zmm_ctrl_state),a
02AF: D334    		out	(zmm_ctrl),a
02B1: C9      		ret
              		
              	; Set program direction to "OUT"
              	;
              	; Returns nothing
              	; Uses: AF
02B2:         	zmm_prgm_out:
02B2: 3A3913  		ld	a,(zmm_ctrl_state)
02B5: E6FD    		and	0b11111101
02B7: 323913  		ld	(zmm_ctrl_state),a
02BA: D334    		out	(zmm_ctrl),a
02BC: C9      		ret
              		
              	; Turn on irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
02BD:         	zmm_irq_inter:
02BD: 3A3913  		ld	a,(zmm_ctrl_state)
02C0: F604    		or	0b00000100
02C2: 323913  		ld	(zmm_ctrl_state),a
02C5: D334    		out	(zmm_ctrl),a
02C7: C9      		ret
              		
              	; Turn off irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
02C8:         	zmm_irq_normal:
02C8: 3A3913  		ld	a,(zmm_ctrl_state)
02CB: E6FB    		and	0b11111011
02CD: 323913  		ld	(zmm_ctrl_state),a
02D0: D334    		out	(zmm_ctrl),a
02D2: C9      		ret
              	
              	; Turn on force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
02D3:         	zmm_irq_on:
02D3: 3A3913  		ld	a,(zmm_ctrl_state)
02D6: F608    		or	0b00001000
02D8: 323913  		ld	(zmm_ctrl_state),a
02DB: D334    		out	(zmm_ctrl),a
02DD: C9      		ret
              		
              	; Turn off force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
02DE:         	zmm_irq_off:
02DE: 3A3913  		ld	a,(zmm_ctrl_state)
02E1: E6F7    		and	0b11110111
02E3: 323913  		ld	(zmm_ctrl_state),a
02E6: D334    		out	(zmm_ctrl),a
02E8: C9      		ret
              		
              	; Set bank 0
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses: AF,
02E9:         	zmm_bnk0_set:
02E9: 323A13  		ld	(zmm_bnk0_state),a
02EC: D330    		out	(zmm_bnk0),a
02EE: C9      		ret
              		
              	; Set bank 1
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF
02EF:         	zmm_bnk1_set:
02EF: 323B13  		ld	(zmm_bnk1_state),a
02F2: D331    		out	(zmm_bnk1),a
02F4: C9      		ret
              		
              	; Set bank 2
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF
02F5:         	zmm_bnk2_set:
02F5: 323C13  		ld	(zmm_bnk2_state),a
02F8: D332    		out	(zmm_bnk2),a
02FA: C9      		ret
              		
              	; Set bank 3
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF
02FB:         	zmm_bnk3_set:
02FB: 323D13  		ld	(zmm_bnk3_state),a
02FE: D333    		out	(zmm_bnk3),a
0300: C9      		ret
              		
              		
              	; Write protect bank 0
              	;
              	; Returns nothing
              	; Uses: AF
0301:         	zmm_bnk0_wp:
0301: 3A3A13  		ld	a,(zmm_bnk0_state)
0304: F680    		or	0b10000000
0306: C3E902  		jp 	zmm_bnk0_set
              		
              	; Write enable bank 0
              	;
              	; Returns nothing
              	; Uses: AF
0309:         	zmm_bnk0_we:
0309: 3A3A13  		ld	a,(zmm_bnk0_state)
030C: E67F    		and	~0b10000000
030E: C3E902  		jp 	zmm_bnk0_set
              		
              	; Write protect bank 1
              	;
              	; Returns nothing
              	; Uses: AF
0311:         	zmm_bnk1_wp:
0311: 3A3B13  		ld	a,(zmm_bnk1_state)
0314: F680    		or	0b10000000
0316: C3EF02  		jp 	zmm_bnk1_set
              		
              	; Write enable bank 1
              	;
              	; Returns nothing
              	; Uses: AF
0319:         	zmm_bnk1_we:
0319: 3A3B13  		ld	a,(zmm_bnk1_state)
031C: E67F    		and	~0b10000000
031E: C3EF02  		jp 	zmm_bnk1_set
              		
              	; Write protect bank 2
              	;
              	; Returns nothing
              	; Uses: AF
0321:         	zmm_bnk2_wp:
0321: 3A3C13  		ld	a,(zmm_bnk2_state)
0324: F680    		or	0b10000000
0326: C3F502  		jp 	zmm_bnk2_set
              		
              	; Write enable bank 2
              	;
              	; Returns nothing
              	; Uses: AF
0329:         	zmm_bnk2_we:
0329: 3A3C13  		ld	a,(zmm_bnk2_state)
032C: E67F    		and	~0b10000000
032E: C3F502  		jp 	zmm_bnk2_set
              		
              	; Write protect bank 3
              	;
              	; Returns nothing
              	; Uses: AF
0331:         	zmm_bnk3_wp:
0331: 3A3D13  		ld	a,(zmm_bnk3_state)
0334: F680    		or	0b10000000
0336: C3FB02  		jp 	zmm_bnk3_set
              		
              	; Write enable bank 3
              	;
              	; Returns nothing
              	; Uses: AF
0339:         	zmm_bnk3_we:
0339: 3A3D13  		ld	a,(zmm_bnk3_state)
033C: E67F    		and	~0b10000000
033E: C3FB02  		jp 	zmm_bnk3_set
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0DA4:         	str_zmm_init:
0DA4: 494E4954		defb	'INITIALIZED ZMM',0x0A,0x0D,'$'
0DA8: 49414C49	
0DAC: 5A454420	
0DB0: 5A4D4D0A	
0DB4: 0D24    	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; ZMM work memory
1337:         	zmm_work:
1337: 0000    		defs	2
              	
              	; Reflected state of control register
1339:         	zmm_ctrl_state:
1339: 00      		defs	1
              		
              	; Bank 0 state
133A:         	zmm_bnk0_state:
133A: 00      		defs	1
              		
              	; Bank 1 state
133B:         	zmm_bnk1_state:
133B: 00      		defs	1
              		
              	; Bank 2 state
133C:         	zmm_bnk2_state:
133C: 00      		defs	1
              		
              	; Bank 3 state
133D:         	zmm_bnk3_state:
133D: 00      		defs	1
              		
              	#include "RESOURCE.asm"
              	;
              	;********************************************************************
              	;*
              	;*               R E S O U R C E   M A N A G E M E N T
              	;* 
              	;*    These routines handle obtaining use-supplied resources
              	;*    such as configurations, ROM images, and storage bindings.
              	;*    During startup, these resources will be loaded to build
              	;*    the virtual machine.
              	;*
              	;********************************************************************
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
0010:         	arg_size	equ 16
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize resources
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
0341:         	res_init:
              		; Start by zero-terminating string
0341: 218000  		ld	hl,cpm_command
0344: 4E      		ld	c,(hl)
0345: 0600    		ld	b,0
0347: 09      		add	hl,bc
0348: 23      		inc	hl
0349: 70      		ld	(hl),b
              		
034A: C9      		ret
              		
              	; Loads an open resource into a bankmap
              	; Bankmap will be zero-padded to fill requested number of records
              	; HL = Address of bankmap
              	; BC = Number of records (128 byte blocks) to load
              	;
              	; Returns nothing
              	; Uses: all
034B:         	res_load:
              		; Set read flag
034B: 3EFF    		ld	a,0xFF
034D: 32D313  		ld	(res_do_read),a
              	
              		; Save args
0350: 22D413  		ld	(res_bankmap),hl
0353: ED43D113		ld	(res_sectors),bc
              	
              		; Virtual mode should be off while we do this
0357: 3A3913  		ld	a,(zmm_ctrl_state)
035A: F5      		push	af
035B: CD9C02  		call	zmm_set_real
              		
              		; Do function call
035E: CD6D03  		call	0$
              		
              		; Reset bank 3
0361: 3A3D13  		ld	a,(zmm_bnk3_state)
0364: D333    		out	(zmm_bnk3),a
              		
              		; Restore register
0366: F1      		pop	af
0367: 323913  		ld	(zmm_ctrl_state),a
036A: C38B02  		jp	zmm_ctrl_set
              		
              		; Allocate a new bank
036D: 1601    	0$:	ld	d,1
036F: CDB501  		call	mem_alloc
0372: 2AD413  		ld	hl,(res_bankmap)
0375: 77      		ld	(hl),a
0376: 23      		inc	hl
0377: 22D413  		ld	(res_bankmap),hl
              		
              		; Set the bank in slot 3
037A: D333    		out	(zmm_bnk3),a
              		
              		; Set DMA address
037C: 115113  		ld	de,res_buffer
037F: 0E1A    		ld	c,bios_set_dma
0381: CD0500  		call	bdos
              		
              		; Set pointer	
0384: 2100C0  		ld	hl,zmm_top
0387: 22D613  		ld	(res_pointer),hl
              		
              		; We will be loading up to 128 records at a time here
038A: 0680    		ld	b,128
              		
              		; Do read operation
038C: C5      	1$:	push	bc
038D: 11D813  		ld	de,res_fcb
0390: 0E14    		ld	c,bdos_read
0392: 3AD313  		ld	a,(res_do_read)
0395: B7      		or	a
0396: C40500  		call	nz,bdos
              		
              		; Check file I/O result
0399: B7      		or	a
039A: C4C303  		call	nz,50$
              		
              		; Go to virtual mode
039D: CD9102  		call	zmm_set_virt
              		
              		; Copy record to bank
03A0: 215113  		ld	hl,res_buffer
03A3: ED5BD613		ld	de,(res_pointer)
03A7: 018000  		ld	bc,128
03AA: EDB0    		ldir
03AC: ED53D613		ld	(res_pointer),de
              		
              		; Back to real mode
03B0: CD9C02  		call	zmm_set_real 
              		
              		; Get BC back to restore sector counter
03B3: C1      		pop	bc
              		
              		; Decrement record count
03B4: 2AD113  		ld	hl,(res_sectors)
03B7: 2B      		dec	hl
03B8: 22D113  		ld	(res_sectors),hl
03BB: 7C      		ld	a,h
03BC: B5      		or	l
03BD: C8      		ret	z
              		
              		; Go get another sector
03BE: 10CC    		djnz	1$
03C0: C36D03  		jp	0$
              	
              		; Zero buffer and reset read flag
03C3: AF      	50$:	xor	a
03C4: 32D313  		ld	(res_do_read),a
              		
03C7: 215113  		ld	hl,res_buffer
03CA: 115213  		ld	de,res_buffer+1
03CD: 017F00  		ld	bc,128-1
03D0: 77      		ld	(hl),a
03D1: EDB0    		ldir
              	
03D3: C9      		ret
              		
              	; Throws an error a missing resource
              	; Resource name will be last attempted to locate
              	;
              	; Does not return
              	; Uses: N/A
03D4:         	res_missing:
03D4: CD9C02  		call	zmm_set_real
              		
              		; Print error message
03D7: 0E09    		ld	c,bdos_print
03D9: 11F30D  		ld	de,str_missing
03DC: CD0500  		call	bdos
              		
              		; Print resource name
03DF: ED5B4F13		ld	de,(res_current)
03E3: CDD404  		call	res_printzt
              		
              		; CRLF
03E6: 0E09    		ld	c,bdos_print
03E8: 11380F  		ld	de,str_crlf
03EB: CD0500  		call	bdos
              		
              		; Exit
03EE: C3F309  		jp	cpm_exit
              		
              	; Opens a file based on the resource argument
              	; If the file cannot be opened, an error will be thrown
              	; (res_argument) = File to open
              	;
              	; Returns nothing
              	; Uses: all
03F1:         	res_open:
              		; Virtual mode should be off while we do this
03F1: 3A3913  		ld	a,(zmm_ctrl_state)
03F4: F5      		push	af
03F5: CD9C02  		call	zmm_set_real
              		
              		; Do function call
03F8: CD0204  		call	0$
              		
              		; Restore register
03FB: F1      		pop	af
03FC: 323913  		ld	(zmm_ctrl_state),a
03FF: C38B02  		jp	zmm_ctrl_set
              		
              		; Let the user know we are loading stuff
0402: 0E09    	0$:	ld	c,bdos_print
0404: 11B60D  		ld	de,str_load_a
0407: CD0500  		call	bdos
              		
              		; Print resource name
040A: ED5B4F13		ld	de,(res_current)
040E: CDD404  		call	res_printzt
              		
              		; Next string
0411: 0E09    		ld	c,bdos_print
0413: 11BF0D  		ld	de,str_load_b
0416: CD0500  		call	bdos
              		
              		; Print file name
0419: 113E13  		ld	de,res_argument
041C: CDD404  		call	res_printzt
              		
              		; CRLF
041F: 0E09    		ld	c,bdos_print
0421: 11380F  		ld	de,str_crlf
0424: CD0500  		call	bdos
              		
              		; Detect if there is an argument
0427: 3A3E13  		ld	a,(res_argument)
042A: B7      		or	a
042B: C23904  		jp	nz,1$
              		
              		; No argument, error!
042E: 0E09    		ld	c,bdos_print
0430: 11C60D  		ld	de,str_arg_empty
0433: CD0500  		call	bdos
0436: C3F309  		jp	cpm_exit
              	
              		; Reset fields
0439: AF      	1$:	xor	a
043A: 21D813  		ld	hl,res_fcb
043D: 11D913  		ld	de,res_fcb+1
0440: 012300  		ld	bc ,36-1
0443: 77      		ld	(hl),a
0444: EDB0    		ldir
              		
0446: 3E20    		ld	a,0x20
0448: 21D913  		ld	hl,res_fcb_name
044B: 11DA13  		ld	de,res_fcb_name+1
044E: 010A00  		ld	bc ,11-1
0451: 77      		ld	(hl),a
0452: EDB0    		ldir
              	
              		; Is there a prefix?
0454: 213E13  		ld	hl,res_argument
0457: 3A3F13  		ld	a,(res_argument+1)
045A: FE3A    		cp	':'
045C: C26E04  		jp	nz,2$
              		
              		; Set prefix
045F: 3A3E13  		ld	a,(res_argument)
0462: D640    		sub	'A'-1
0464: FE11    		cp	17
0466: D2C904  		jp	nc,99$
0469: 32D813  		ld	(res_fcb_drive),a
046C: 23      		inc	hl
046D: 23      		inc	hl
              	
              		; HL = Proper filename start
046E: 0608    	2$:	ld	b,8
0470: 11D913  		ld	de,res_fcb_name
              		
              		; Copy it over
0473: 7E      	3$:	ld	a,(hl)
0474: B7      		or	a
0475: CAC904  		jp	z,99$
0478: FE2A    		cp	'*'
047A: CA8A04  		jp	z,4$
047D: FE2E    		cp	'.'
047F: CA9104  		jp	z,5$
0482: 12      		ld	(de),a
0483: 13      		inc	de
0484: 23      		inc	hl
0485: 10EC    		djnz	3$
0487: C39104  		jp	5$
              	
              		; Fill remains of FCB file name
048A: 3E3F    	4$:	ld	a,'?'
048C: 12      		ld	(de),a
048D: 13      		inc	de
048E: 10FA    		djnz	4$
0490: 23      		inc	hl
              	
              		; We should either see a '.' or a null character
0491: 7E      	5$:	ld	a,(hl)
0492: B7      		or	a
0493: CABA04  		jp	z,8$
0496: FE2E    		cp	'.'
0498: C2C904  		jp	nz,99$
049B: 23      		inc	hl
              		
              		; Fill in extension
049C: 0603    		ld	b,3
049E: 11E113  		ld	de,res_fcb_type
              		
              		; Copy it over
04A1: 7E      	6$:	ld	a,(hl)
04A2: B7      		or	a
04A3: CABA04  		jp	z,8$
04A6: FE2A    		cp	'*'
04A8: CAB304  		jp	z,7$
04AB: 12      		ld	(de),a
04AC: 13      		inc	de
04AD: 23      		inc	hl
04AE: 10F1    		djnz	6$
04B0: C3BA04  		jp	8$
              		
              		; Fill remains of FCB file extension
04B3: 3E3F    	7$:	ld	a,'?'
04B5: 12      		ld	(de),a
04B6: 13      		inc	de
04B7: 10D1    		djnz	4$
04B9: 23      		inc	hl
              	
              		; We should get a zero
04BA: 7E      	8$:	ld 	a,(hl)
04BB: B7      		or	a
04BC: C2C904  		jp	nz,99$
              		
              		; It is filled in, attempt to open
04BF: 0E0F    		ld	c,bdos_open
04C1: 11D813  		ld	de,res_fcb
04C4: CD0500  		call	bdos
              		
              		; Check error
04C7: 3C      		inc	a
04C8: C0      		ret	nz
              		
              		; Error!
04C9: 0E09    	99$:	ld	c,bdos_print
04CB: 11DD0D  		ld	de,str_arg_fail
04CE: CD0500  		call	bdos
04D1: C3F309  		jp	cpm_exit
              		
              		
              	; Print a zero terminated string
              	; We should be in real mode for this
              	; DE = String
              	;
              	; Returns nothing
              	; Uses: All
04D4:         	res_printzt:
04D4: 1A      	0$:	ld	a,(de)
04D5: B7      		or	a
04D6: C8      		ret	z
              		
              		; Print character
04D7: D5      		push	de
04D8: 5F      		ld	e,a
04D9: 0E02    		ld	c,bdos_con_out
04DB: CD0500  		call	bdos
04DE: D1      		pop	de
04DF: 13      		inc	de
04E0: C3D404  		jp	0$
              	
              	; Find a resource from the command line
              	; If the resource is found, the contents will be cached in memory
              	; DE = Name of resource (upper case only) 
              	;
              	; Returns A = 0xFF if no resource is found
              	; Uses: AF, BC, DE, HL
04E3:         	res_locate:
              		; Save resource
04E3: ED534F13		ld	(res_current),de
              	
              		; Travel to the start of arguments
04E7: 218100  		ld	hl,cpm_command+1
04EA: 7E      	0$:	ld	a,(hl)
04EB: B7      		or	a
04EC: CA4905  		jp	z,99$
04EF: FE21    		cp	0x21
04F1: D2F804  		jp	nc,1$
04F4: 23      		inc	hl
04F5: C3EA04  		jp	0$
              		
              		; Found an argument
              		; Check it against the contents of (DE)
              		; Also must start with '-'
04F8: FE2D    	1$:	cp	'-'
04FA: C20B05  		jp	nz,3$
04FD: 23      		inc	hl
04FE: D5      		push	de
04FF: 1A      	2$:	ld	a,(de)
              		
              		; Check if at end of string
0500: B7      		or	a
0501: CA1905  		jp	z,4$
              		
              		; No? Well lets see if (de) = (hl)
0504: BE      		cp	(hl)
0505: 23      		inc	hl
0506: 13      		inc	de
0507: CAFF04  		jp	z,2$
              		
              		; Strings are different!
              		; Escape from the current argument and continue
050A: D1      		pop	de
050B: 7E      	3$:	ld	a,(hl)
050C: B7      		or	a
050D: CA4905  		jp	z,99$
0510: FE21    		cp	0x21
0512: DAEA04  		jp	c,0$
0515: 23      		inc	hl
0516: C30B05  		jp	3$
              	
              		; Make sure we are at the end of the argument as well
0519: D1      	4$: 	pop	de
051A: 7E      		ld	a,(hl)
051B: FE21    		cp	0x21
051D: D20B05  		jp	nc,3$
              		
              		; Ok, lets copy the argument into memory if it exists
0520: 113E13  		ld	de,res_argument
0523: AF      		xor	a
0524: 12      		ld	(de),a
              		
              		; Travel to the start of the argument
0525: 7E      	5$:	ld	a,(hl)
0526: B7      		or	a
0527: CA4705  		jp	z,89$
052A: FE21    		cp	0x21
052C: D23305  		jp	nc,6$
052F: 23      		inc	hl
0530: C32505  		jp	5$
              	
              		; Make sure it doesn't start with '-'
0533: FE2D    	6$:	cp	'-'
0535: CA4705  		jp	z,89$
              		
              		; Ok, lets copy up 16 bytes of this
0538: 0610    		ld	b,arg_size
053A: 7E      	7$:	ld	a,(hl)
053B: FE21    		cp	0x21
053D: DA4505  		jp	c,8$
0540: 12      		ld	(de),a
0541: 23      		inc	hl
0542: 13      		inc	de
0543: 10F5    		djnz	7$
              	
              		; Zero terminate
0545: AF      	8$:	xor	a
0546: 12      		ld	(de),a
              		
              		; Good ending
0547: AF      	89$:	xor	a
0548: C9      		ret
              	
              		; Bad ending
0549: 3EFF    	99$:	ld	a,0xFF
054B: C9      		ret
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Loading string components
0DB6:         	str_load_a:
0DB6: 4C4F4144		defb	'LOADING $'
0DBA: 494E4720	
0DBE: 24      	
              		
0DBF:         	str_load_b:
0DBF: 2046524F		defb	' FROM $'
0DC3: 4D2024  	
              		
              	; Error messages
0DC6:         	str_arg_empty:
0DC6: 4E4F2041		defb	'NO ARGUMENT PROVIDED',0x0A,0x0D,'$'
0DCA: 5247554D	
0DCE: 454E5420	
0DD2: 50524F56	
0DD6: 49444544	
0DDA: 0A0D24  	
              		
0DDD:         	str_arg_fail:
0DDD: 4641494C		defb	'FAILED TO OPEN FILE',0x0A,0x0D,'$'
0DE1: 45442054	
0DE5: 4F204F50	
0DE9: 454E2046	
0DED: 494C450A	
0DF1: 0D24    	
              		
0DF3:         	str_missing:
0DF3: 4D495353		defb	'MISSING RESOURCE: $'
0DF7: 494E4720	
0DFB: 5245534F	
0DFF: 55524345	
0E03: 3A2024  	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Stores a zero-terminated string for the resource argument
133E:         	res_argument:
133E: 00000000		defs	arg_size+1
1342: 00...   	
              		
              	; Current resource being accessed
134F:         	res_current:
134F: 0000    		defs	2
              		
              	; Resource buffer
1351:         	res_buffer:
1351: 00000000		defs	128
1355: 00...   	
              		
              	; Sector counter
13D1:         	res_sectors:
13D1: 0000    		defs	2
              		
              	; Do we need to read?
13D3:         	res_do_read:
13D3: 00      		defs	1
              		
              	; Resource bankmap
13D4:         	res_bankmap:
13D4: 0000    		defs	2
              		
              	; Loading pointer
13D6:         	res_pointer:
13D6: 0000    		defs	2
              		
              	; File control block for use in loading resources
13D8:         	res_fcb:
13D8: 00000000		defs	36
13DC: 00...   	
13D8:         	res_fcb_drive	equ	res_fcb
13D9:         	res_fcb_name	equ	res_fcb+1
13E1:         	res_fcb_type	equ	res_fcb+9
13E4:         	res_fcb_ex	equ	res_fcb+12
13E5:         	res_fcb_s1	equ	res_fcb+13
13E6:         	res_fcb_s2	equ	res_fcb+14
13E7:         	res_fcb_rc	equ	res_fcb+15
13E8:         	res_fcb_data	equ	res_fcb+16
13F8:         	res_fcb_cr	equ	res_fcb+32
13F9:         	res_fcb_r0	equ	res_fcb+33
13FA:         	res_fcb_r1	equ	res_fcb+34
13FB:         	res_fcb_r2	equ	res_fcb+35
              	#include "TRAP.asm"
              	;
              	;********************************************************************
              	;*
              	;*                     T R A P   H A N D L E R
              	;* 
              	;*    Responsible for handling various traps from the ZMM. Both
              	;*    interrupt and I/O traps will be pre-processed before being
              	;*    sent to the virtualization core for device-specific handling
              	;*
              	;********************************************************************
              	
              	; -------------------------------
              	; ********  Trap Handler ********
              	; -------------------------------
              	
              	.area	_TEXT
              	
              	; Entry point for traps
054C:         	trap_entry:
              		; Save value of SP
054C: ED73FC13		ld	(trap_sp_value),sp
0550: 310070  		ld	sp,kri_stack
              		
              		; Save value of AF
0553: F5      		push	af
              		
              		; Check in on device interrupts
0554: CD250C  		call	irq_handle
              		
              		; Grab the value of the ISR register
0557: DB30    		in	a,(zmm_isr)
              		
              		; Do we actually need to handle an I/O trap?
0559: B7      		or	a
055A: F23507  		jp	p,trap_continue
              		
              		; OK, a trap did occur.
              		; Are we doing "classic" I/O or extended I/O?
055D:         	trap_io:	
055D: FEE8    		cp	0b11101000
055F: DA7905  		jp	c,trap_io_ext
              		
              		; In or out?
0562: FEEC    		cp	0b11101100
0564: DA7005  	69$:	jp	c,0$
              		
              		; In it is
0567: CD3A0C  		call	in_handle
056A: 32FF6F  		ld	(trap_a_value),a
056D: C33507  		jp	trap_continue
              		
              		; Out it is
0570: 3AFF6F  	0$:	ld	a,(trap_a_value)
0573: CD4E0C  		call	out_handle
0576: C33507  		jp	trap_continue
              	
              	
              	; It's an extended I/O instruction
0579:         	trap_io_ext:
              	
              		; Input or output?
0579: 0F      		rrca
057A: DAEF05  		jp	c,trap_io_ex_out
              		
              		; Extended input instruction
              		; INI-class?
057D: 0F      		rrca
057E: DA4906  		jp	c,trap_io_inx
              		
              		; Left or right column
0581: 0F      		rrca
0582: DAAC05  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
0585: 0F      		rrca
0586: DA9B05  		jp	c,1$
              		
              		; B or H?
0589: 0F      		rrca
058A: DA9405  		jp	c,2$
              		
              		; It's B
058D: CD3A0C  		call	in_handle
0590: 47      		ld	b,a
0591: C3D605  		jp	90$
              		
              		; It's H	
0594: CD3A0C  	2$:	call	in_handle
0597: 67      		ld	h,a
0598: C3D605  		jp	90$
              	
              		; D or 0?
059B: 0F      	1$:	rrca
059C: DAA605  		jp	c,3$
              	
              		; It's D
059F: CD3A0C  		call	in_handle
05A2: 57      		ld	d,a
05A3: C3D605  		jp	90$
              		
              		; It's 0
05A6: CD3A0C  	3$:	call	in_handle
05A9: C3D605  		jp	90$
              		
              		
              		; Right column
              		; C, E, L, or A?
05AC: 0F      	0$:	rrca
05AD: DAC205  		jp	c,4$
              		
              		; C or L?
05B0: 0F      		rrca
05B1: DABB05  		jp	c,5$
              		
              		; It's C
05B4: CD3A0C  		call	in_handle
05B7: 4F      		ld	c,a
05B8: C3D605  		jp	90$
              	
              		; It's L
05BB: CD3A0C  	5$:	call	in_handle
05BE: 6F      		ld	l,a
05BF: C3D605  		jp	90$
              		
              		; E or A?
05C2: 0F      	4$:	rrca
05C3: DACD05  		jp	c,6$
              		
              		; It's E
05C6: CD3A0C  		call	in_handle
05C9: 5F      		ld	e,a
05CA: C3D605  		jp	90$
              	
              		; It's A
05CD: CD3A0C  	6$:	call	in_handle
05D0: 32FF6F  		ld	(trap_a_value),a
05D3: C3D605  		jp	90$
              		
              		; Extended IN instructions require special flag states
              		; lets set them and return
05D6: E5      	90$:	push	hl
05D7: 21FE6F  		ld	hl,trap_f_value
05DA: CB46    		bit	0,(hl)
05DC: E1      		pop	hl
              		
              		; If it's zero, we don't need the carry flag
05DD: CAE805  		jp	z,91$ 
              		
              		; Update flags and persist carry flag
05E0: B7      		or	a
05E1: 37      		scf
05E2: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Do trap restore
05E5: C33607  		jp	trap_restore
              		
              		; Update flags and reset carry flag
05E8: B7      	91$:	or	a
05E9: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Do trap restore
05EC: C33607  		jp	trap_restore
              		
              	; Extended output instruction
05EF:         	trap_io_ex_out:
              	
              		; OUTI-class?
05EF: 0F      		rrca
05F0: DABF06  		jp	c,trap_io_outx
              		
              		; Left or right column?
05F3: 0F      		rrca
05F4: DA1F06  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
05F7: 0F      		rrca
05F8: DA0D06  		jp	c,1$
              		
              		; B or H?
05FB: 0F      		rrca
05FC: DA0606  		jp	c,2$
              		
              		; It's B
05FF: 78      		ld	a,b
0600: CD4E0C  		call	out_handle
0603: C33507  		jp	trap_continue
              		
              		; It's H	
0606: 7C      	2$:	ld	a,h
0607: CD4E0C  		call	out_handle
060A: C33507  		jp	trap_continue
              	
              		; D or 0?
060D: 0F      	1$:	rrca
060E: DA1806  		jp	c,3$
              	
              		; It's D
0611: 7A      		ld	a,d
0612: CD4E0C  		call	out_handle
0615: C33507  		jp	trap_continue
              		
              		; It's 0
0618: AF      	3$:	xor	a
0619: CD4E0C  		call	out_handle
061C: C33507  		jp	trap_continue
              		
              		
              		; Right column
              		; C, E, L, or A?
061F: 0F      	0$:	rrca
0620: DA3506  		jp	c,4$
              		
              		; C or L?
0623: 0F      		rrca
0624: DA2E06  		jp	c,5$
              		
              		; It's C
0627: 79      		ld	a,c
0628: CD4E0C  		call	out_handle
062B: C33507  		jp	trap_continue
              	
              		; It's L
062E: 7D      	5$:	ld	a,l
062F: CD4E0C  		call	out_handle
0632: C33507  		jp	trap_continue
              		
              		; E or A?
0635: 0F      	4$:	rrca
0636: DA4006  		jp	c,6$
              		
              		; It's E
0639: 7B      		ld	a,e
063A: CD4E0C  		call	out_handle
063D: C33507  		jp	trap_continue
              	
              		; It's A
0640: 3AFF6F  	6$:	ld	a,(trap_a_value)
0643: CD4E0C  		call	out_handle
0646: C33507  		jp	trap_continue
              	
              	
              		; INX class instructions
              		; The CPU should handle the differences between INX and INXR
0649:         	trap_io_inx:
              		; Left or right column?
0649: 0F      		rrca
064A: DA8606  		jp	c,trap_io_ind
              		
              		; Left column, it's 'I' class
064D: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
064E: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
064F: 7C      		ld	a,h
0650: 07      		rlca
0651: DA6406  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0654: 07      		rlca
0655: DA5E06  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0658: 3A3A13  		ld	a,(zmm_bnk0_state)
065B: C37106  		jp	3$
              		
              		; 0x4000 - 0x7FFF
065E: 3A3B13  	1$:	ld	a,(zmm_bnk1_state)
0661: C37106  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0664: 07      	0$:	rlca
0665: DA6E06  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
0668: 3A3C13  		ld	a,(zmm_bnk2_state)
066B: C37106  		jp	3$
              	
              		; 0xC000 - 0xFFFF
066E: 3A3D13  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0671: E67F    	3$:	and	0b01111111
0673: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0675: 3EC0    		ld	a,0b11000000
0677: B4      		or	h
0678: 67      		ld	h,a
              		
              		; Do the input
0679: CD3A0C  		call	in_handle
067C: 77      		ld	(hl),a
              		
              		; Fix banks
067D: 3A3D13  		ld	a,(zmm_bnk3_state)
0680: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0682: E1      		pop	hl
0683: C33507  		jp	trap_continue
              		
              		; Right column, it's 'D' class
0686:         	trap_io_ind:
0686: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0687: 23      		inc	hl	; Increment to reverse 'D' class instruction
0688: 7C      		ld	a,h
0689: 07      		rlca
068A: DA9D06  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
068D: 07      		rlca
068E: DA9706  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0691: 3A3A13  		ld	a,(zmm_bnk0_state)
0694: C3AA06  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0697: 3A3B13  	1$:	ld	a,(zmm_bnk1_state)
069A: C3AA06  		jp	3$
              			
              		; 0x8000 - 0xFFFF
069D: 07      	0$:	rlca
069E: DAA706  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
06A1: 3A3C13  		ld	a,(zmm_bnk2_state)
06A4: C3AA06  		jp	3$
              	
              		; 0xC000 - 0xFFFF
06A7: 3A3D13  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
06AA: E67F    	3$:	and	0b01111111
06AC: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
06AE: 3EC0    		ld	a,0b11000000
06B0: B4      		or	h
06B1: 67      		ld	h,a
              		
              		; Do the input
06B2: CD3A0C  		call	in_handle
06B5: 77      		ld	(hl),a
              		
              		; Fix banks
06B6: 3A3D13  		ld	a,(zmm_bnk3_state)
06B9: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
06BB: E1      		pop	hl
06BC: C33507  		jp	trap_continue
              	
              		; OUTX-class instructions
              		; The CPU should handle the differences between OUTX and OTXR
06BF:         	trap_io_outx:
              	
              		; Left or right column?
06BF: 0F      		rrca
06C0: DAFC06  		jp	c,trap_io_outd
              		
              		; Left column, it's 'I' class
06C3: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
06C4: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
06C5: 7C      		ld	a,h
06C6: 07      		rlca
06C7: DADA06  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
06CA: 07      		rlca
06CB: DAD406  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
06CE: 3A3A13  		ld	a,(zmm_bnk0_state)
06D1: C3E706  		jp	3$
              		
              		; 0x4000 - 0x7FFF
06D4: 3A3B13  	1$:	ld	a,(zmm_bnk1_state)
06D7: C3E706  		jp	3$
              			
              		; 0x8000 - 0xFFFF
06DA: 07      	0$:	rlca
06DB: DAE406  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
06DE: 3A3C13  		ld	a,(zmm_bnk2_state)
06E1: C3E706  		jp	3$
              	
              		; 0xC000 - 0xFFFF
06E4: 3A3D13  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
06E7: E67F    	3$:	and	0b01111111
06E9: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
06EB: 3EC0    		ld	a,0b11000000
06ED: B4      		or	h
06EE: 67      		ld	h,a
              		
              		; Do the output
06EF: 7E      		ld	a,(hl)
06F0: CD4E0C  		call	out_handle
              		
              		; Fix banks
06F3: 3A3D13  		ld	a,(zmm_bnk3_state)
06F6: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
06F8: E1      		pop	hl
              		
06F9: C33507  		jp	trap_continue
              		
              		; Right column, it's 'D' class
06FC:         	trap_io_outd:
06FC: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
06FD: 23      		inc	hl	; Increment to reverse 'D' class instruction
06FE: 7C      		ld	a,h
06FF: 07      		rlca
0700: DA1307  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0703: 07      		rlca
0704: DA0D07  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0707: 3A3A13  		ld	a,(zmm_bnk0_state)
070A: C32007  		jp	3$
              		
              		; 0x4000 - 0x7FFF
070D: 3A3B13  	1$:	ld	a,(zmm_bnk1_state)
0710: C32007  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0713: 07      	0$:	rlca
0714: DA1D07  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
0717: 3A3C13  		ld	a,(zmm_bnk2_state)
071A: C32007  		jp	3$
              	
              		; 0xC000 - 0xFFFF
071D: 3A3D13  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0720: E67F    	3$:	and	0b01111111
0722: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0724: 3EC0    		ld	a,0b11000000
0726: B4      		or	h
0727: 67      		ld	h,a
              		
              		; Do the output
0728: 7E      		ld	a,(hl)
0729: CD4E0C  		call	out_handle
              		
              		; Fix banks
072C: 3A3D13  		ld	a,(zmm_bnk3_state)
072F: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0731: E1      		pop	hl
0732: C33507  		jp	trap_continue
              	
              		
              	; Continue execution
0735:         	trap_continue:
              		; Restore AF
0735: F1      		pop	af
              		
              		; Restore stack and return
              		; Maybe invoke the debugger as well
0736:         	trap_restore:
              		
              		; Reset trap state
0736:         	trap_res_flag:
0736: 00      		nop
0737: 00      		nop
0738: 00      		nop
0739: D337    		out	(zmm_trap),a
              		
              		; Restore old SP
073B: ED7BFC13		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
073F: 00      		nop
0740: ED45    		retn
              		
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize trap handling stuff
              	;
              	; Returns nothing
              	; Uses: AF, HL
0742:         	trap_init:
              		; Install trap vector
0742: 3EC3    		ld	a,0xC3
0744: 326600  		ld	(nmi_address),a
0747: 214C05  		ld	hl,trap_entry
074A: 226700  		ld	(nmi_vector),hl
              		
074D: C9      		ret
              		
              		
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value of untrapped SP value
13FC:         	trap_sp_value:
13FC: 0000    		defs	2
              	#include "IRQ.asm"
              	;
              	;********************************************************************
              	;*
              	;*             I N T E R R U P T   M A N A G E M E N T
              	;* 
              	;*    Manages "real" system interrupts on the host hardware.
              	;*    Also deals with mocking interrupts to the virtual machine
              	;*    if it is needed.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize interrupt stuff
              	;
              	; Returns nothing
              	; Uses: AF
074E:         	irq_init:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
074E: 3E07    		ld	a,7		; AY register = 7
0750: D341    		out	(nabu_ay_latch),a
0752: DB40    		in	a,(nabu_ay_data)
0754: E63F    		and	0x3F
0756: F640    		or	0x40
0758: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off all interrupts
075A: 3E0E    		ld	a,14		; AY register = 14	
075C: D341    		out	(nabu_ay_latch),a
075E: AF      		xor	a
075F: D340    		out	(nabu_ay_data),a
0761: 32FE13  		ld	(irq_mask_state),a
              		
              		; Return
0764: C9      		ret
              		
              		
              	; Turns on the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
0765:         	irq_vdp_on:
0765: 3AFE13  		ld	a,(irq_mask_state)
0768: F610    		or	0b00010000
076A: 32FE13  		ld	(irq_mask_state),a
              		
076D: C3D007  		jp	irq_restore
              		
              	; Turns off the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
0770:         	irq_vdp_off:
0770: 3AFE13  		ld	a,(irq_mask_state)
0773: E6EF    		and	~0b00010000
0775: 32FE13  		ld	(irq_mask_state),a
              		
0778: C3D007  		jp	irq_restore
              		
              	; Turns on the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
077B:         	irq_keyb_on:
077B: 3AFE13  		ld	a,(irq_mask_state)
077E: F620    		or	0b00100000
0780: 32FE13  		ld	(irq_mask_state),a
              		
0783: C3D007  		jp	irq_restore
              		
              	; Turns off the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
0786:         	irq_keyb_off:
0786: 3AFE13  		ld	a,(irq_mask_state)
0789: E6DF    		and	~0b00100000
078B: 32FE13  		ld	(irq_mask_state),a
              		
078E: C3D007  		jp	irq_restore
              	
              	; Turns on the HCCA output
              	;
              	; Returns nothing
              	; Uses: AF
0791:         	irq_hcca_o_on:
0791: 3AFE13  		ld	a,(irq_mask_state)
0794: F640    		or	0b01000000
0796: 32FE13  		ld	(irq_mask_state),a
              		
0799: C3D007  		jp	irq_restore
              		
              	; Turns off the HCCA output
              	;
              	; Returns nothing
              	; Uses: AF
079C:         	irq_hcca_o_off:
079C: 3AFE13  		ld	a,(irq_mask_state)
079F: E6BF    		and	~0b01000000
07A1: 32FE13  		ld	(irq_mask_state),a
              		
07A4: C3D007  		jp	irq_restore
              		
              	; Turns on the HCCA input
              	;
              	; Returns nothing
              	; Uses: AF
07A7:         	irq_hcca_i_on:
07A7: 3AFE13  		ld	a,(irq_mask_state)
07AA: F680    		or	0b10000000
07AC: 32FE13  		ld	(irq_mask_state),a
              		
07AF: C3D007  		jp	irq_restore
              		
              	; Turns off the HCCA input
              	;
              	; Returns nothing
              	; Uses: AF
07B2:         	irq_hcca_i_off:
07B2: 3AFE13  		ld	a,(irq_mask_state)
07B5: E67F    		and	~0b10000000
07B7: 32FE13  		ld	(irq_mask_state),a
              		
07BA: C3D007  		jp	irq_restore
              		
              	; Returns the IRQ status byte
              	;
              	; Returns A = IRQ status
              	; Uses: AF
07BD:         	irq_status:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
07BD: 3E07    		ld	a,7		; AY register = 7
07BF: D341    		out	(nabu_ay_latch),a
07C1: DB40    		in	a,(nabu_ay_data)
07C3: E63F    		and	0x3F
07C5: F640    		or	0x40
07C7: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
07C9: 3E0F    		ld	a,15		; AY register = 15	
07CB: D341    		out	(nabu_ay_latch),a
07CD: DB40    		in	a,(nabu_ay_data)
07CF: C9      		ret
              		
              	; Restore the IRQ mask from 
              	;
              	; Returns nothing
              	; Uses: AF
07D0:         	irq_restore:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
07D0: 3E07    		ld	a,7		; AY register = 7
07D2: D341    		out	(nabu_ay_latch),a
07D4: DB40    		in	a,(nabu_ay_data)
07D6: E63F    		and	0x3F
07D8: F640    		or	0x40
07DA: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
07DC: 3E0E    		ld	a,14		; AY register = 14	
07DE: D341    		out	(nabu_ay_latch),a
07E0: 3AFE13  		ld	a,(irq_mask_state)
07E3: D340    		out	(nabu_ay_data),a
07E5: C9      		ret
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value interrupt mask
13FE:         	irq_mask_state:
13FE: 00      		defs	1
              	#include "DEBUG.asm"
              	;
              	;**************************************************************
              	;*
              	;*        V I R T U A L   M A C H I N E   D E B U G G E R
              	;*
              	;*    Proves a machine-language monitor for debugging the
              	;*    virtual machine. Does standard monitor stuff.
              	;* 
              	;**************************************************************
              	
              	; ---------------------------
              	; ********  Debugger ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Handle for the debugger
07E6:         	debug_handle:
              	
              		; Save machine context
07E6: ED730214		ld	(debug_temp),sp
07EA: 311D14  		ld	sp,debug_state
              		
              		; Dump registers
07ED: F5      		push	af
07EE: C5      		push	bc
07EF: D5      		push	de
07F0: E5      		push	hl
07F1: D9      		exx
07F2: 08      		ex	af,af'
07F3: F5      		push	af
07F4: C5      		push	bc
07F5: D5      		push	de
07F6: E5      		push	hl
07F7: DDE5    		push	ix
07F9: FDE5    		push	iy
              		
07FB: ED7B0214		ld	sp,(debug_temp)
              		
              		; Check to see if we are skipping over stuff
07FF: 3A0614  		ld	a,(debug_f_over)
0802: B7      		or	a
0803: CA1608  		jp	z,0$
              		
              		; Check stack pointer
0806: 2AFC13  		ld	hl,(trap_sp_value)
0809: ED5B0714		ld	de,(debug_over_sp)
080D: ED52    		sbc	hl,de
080F: C22A09  		jp	nz,debug_continue
              		
              		; Reset over flag
0812: AF      		xor	a
0813: 320614  		ld	(debug_f_over),a
              		
0816:         	0$:
              		
              		; Debugger stuff starts here
              		; Populate register dump string
0816: 011D14  		ld	bc,debug_state
0819: 21640E  		ld	hl,str_rdump_af
081C: CD4C09  		call	debug_rtohex
081F: 216D0E  		ld	hl,str_rdump_bc
0822: CD4C09  		call	debug_rtohex
0825: 21760E  		ld	hl,str_rdump_de
0828: CD4C09  		call	debug_rtohex
082B: 217F0E  		ld	hl,str_rdump_hl
082E: CD4C09  		call	debug_rtohex
0831: 218C0E  		ld	hl,str_rdump_aaf
0834: CD4C09  		call	debug_rtohex
0837: 21950E  		ld	hl,str_rdump_abc
083A: CD4C09  		call	debug_rtohex
083D: 219E0E  		ld	hl,str_rdump_ade
0840: CD4C09  		call	debug_rtohex
0843: 21A70E  		ld	hl,str_rdump_ahl
0846: CD4C09  		call	debug_rtohex
0849: 21B40E  		ld	hl,str_rdump_ix
084C: CD4C09  		call	debug_rtohex
084F: 21BD0E  		ld	hl,str_rdump_iy
0852: CD4C09  		call	debug_rtohex
              		
              		; Display stack pointer
0855: 2AFC13  		ld	hl,(trap_sp_value)
0858: 23      		inc	hl
0859: 23      		inc	hl
085A: 7C      		ld	a,h
085B: CDFB09  		call	tohex
085E: ED532A0E		ld	(str_rdump_sp),de
0862: 7D      		ld	a,l
0863: CDFB09  		call	tohex
0866: ED532C0E		ld	(str_rdump_sp+2),de
              			
              		; Extract PC from capture area
086A: 2AFC13  		ld	hl,(trap_sp_value)
086D: 7C      		ld	a,h
086E: E67F    		and	zmm_capt_res
0870: F670    		or	zmm_capt_set
0872: 67      		ld	h,a
0873: 7E      		ld	a,(hl)
0874: 320414  		ld	(debug_pc_state),a
0877: CDFB09  		call	tohex
087A: ED53230E		ld	(str_rdump_pc+2),de
087E: 23      		inc	hl
087F: 7C      		ld	a,h
0880: E67F    		and	zmm_capt_res
0882: F670    		or	zmm_capt_set
0884: 67      		ld	h,a
0885: 7E      		ld	a,(hl)
0886: 320514  		ld	(debug_pc_state+1),a
0889: CDFB09  		call	tohex
088C: ED53210E		ld	(str_rdump_pc),de
              		
              		; Display instruction
0890: 2A0414  		ld	hl,(debug_pc_state)
0893: CD6501  		call	mem_fvbyte
0896: CDFB09  		call	tohex
0899: ED53350E		ld	(str_rdump_isr),de
089D: 23      		inc	hl
089E: CD6501  		call	mem_fvbyte
08A1: CDFB09  		call	tohex
08A4: ED53370E		ld	(str_rdump_isr+2),de
08A8: 23      		inc	hl
08A9: CD6501  		call	mem_fvbyte
08AC: CDFB09  		call	tohex
08AF: ED53390E		ld	(str_rdump_isr+4),de
08B3: 23      		inc	hl
08B4: CD6501  		call	mem_fvbyte
08B7: CDFB09  		call	tohex
08BA: ED533B0E		ld	(str_rdump_isr+6),de
              		
              		; Get interrupt status
08BE: ED57    		ld	a,i
08C0: 3E2D    		ld	a,'-'
08C2: E2C708  		jp	po,1$
08C5: 3E58    		ld	a,'X'
08C7: 32530E  	1$:	ld	(str_rdump_ei),a
              	
              		; Get I/O trap status
08CA: DB30    		in	a,(zmm_isr)
08CC: B7      		or	a
08CD: 3E2D    		ld 	a,'-'
08CF: F2D408  		jp	p,2$
08D2: 3E58    		ld	a,'X'
08D4: 325A0E  	2$:	ld	(str_rdump_io),a
              	
              		; Copy flags
08D7: 11460E  		ld	de,str_rdump_flag
08DA: 21130E  		ld	hl,debug_flags
08DD: 3A1B14  		ld	a,(debug_state-2)
08E0: 0608    		ld	b,8
08E2: 4F      		ld	c,a
08E3: 7E      	3$:	ld	a,(hl)
08E4: CB21    		sla	c
08E6: DAEB08  		jp	c,4$
08E9: 3E2D    		ld	a,'-'
08EB: 12      	4$:	ld	(de),a
08EC: 23      		inc	hl
08ED: 13      		inc	de
08EE: 10F3    		djnz	3$
              		
              		
              		; Print
08F0: 111B0E  		ld	de,str_rdump
08F3: CDB909  		call	cpm_print
              		
              	; Query the user for an operation to perform
08F6:         	debug_query:
08F6: CDDF09  		call	cpm_getc
08F9: 79      		ld	a,c
              		
              		; Exit?
08FA: FE1B    		cp	0x1B
08FC: CAF309  		jp	z,cpm_exit
              		
              		; Over?
08FF: FE4F    		cp	'O'
0901: CA0C09  		jp	z,debug_over
              		
              		; Upper?
0904: FE55    		cp	'U'
0906: CA1A09  		jp	z,debug_upper
              		
              		
              		; Ok, just continue then
0909: C32A09  		jp	debug_continue
              	
              	
              	;	ld	de,str_prompt
              	;	call	cpm_print
              	;	ld	de,input_buff
              	;	call	cpm_input
              	
              		
              	; Do not enter debugger until stack is equal to the original value
090C:         	debug_over:
090C: 2AFC13  		ld	hl,(trap_sp_value)
090F: 220714  		ld	(debug_over_sp),hl
              		
0912: 3EFF    		ld	a,0xFF
0914: 320614  		ld	(debug_f_over),a
              		
0917: C32A09  		jp	debug_continue
              		
              	; Do not enter debugger until current function has been returned from
091A:         	debug_upper:
091A: 2AFC13  		ld	hl,(trap_sp_value)
091D: 23      		inc	hl
091E: 23      		inc	hl
091F: 220714  		ld	(debug_over_sp),hl
              		
0922: 3EFF    		ld	a,0xFF
0924: 320614  		ld	(debug_f_over),a
              		
0927: C32A09  		jp	debug_continue	
              		
              	; Go back to the virutal machine
092A:         	debug_continue:
              		
              		; Restore IRQ state
092A: CDD007  		call	irq_restore
              		
              		; Restore machine context
092D: ED730214		ld	(debug_temp),sp
0931: 310914  		ld	sp,debug_state-20
              		
              		; Restore registers
0934: FDE1    		pop	iy
0936: DDE1    		pop	ix
0938: E1      		pop	hl
0939: D1      		pop	de
093A: C1      		pop	bc
093B: F1      		pop	af
093C: D9      		exx
093D: 08      		ex	af,af'
093E: E1      		pop	hl
093F: D1      		pop	de
0940: C1      		pop	bc
0941: F1      		pop	af
              		
              		; Go back to trap handler
0942: ED7B0214		ld	sp,(debug_temp)
0946: C9      		ret
              	
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	
              	; Initalize the debugger
              	;
              	; Returns nothing
              	; Uses: AF
0947:         	debug_init:
              		
              		; Reset flags
0947: AF      		xor	a
0948: 320614  		ld	(debug_f_over),a
              		
094B: C9      		ret
              	
              	; Converts a register to hexadecimal
              	; BC = Address of register value
              	; HL = Address of hex string
              	;
              	; Returns BC=BC=2
              	; Uses: AF, BC, DE, HL
094C:         	debug_rtohex:
094C: 0B      		dec	bc
094D: 0A      		ld	a,(bc)
094E: C5      		push	bc
094F: CDFB09  		call	tohex
0952: C1      		pop	bc
0953: 73      		ld	(hl),e
0954: 23      		inc	hl
0955: 72      		ld	(hl),d
0956: 23      		inc	hl
0957: 0B      		dec	bc
0958: 0A      		ld	a,(bc)
0959: C5      		push	bc
095A: CDFB09  		call 	tohex
095D: C1      		pop	bc
095E: 73      		ld	(hl),e
095F: 23      		inc	hl
0960: 72      		ld	(hl),d
0961: C9      		ret
              	
              	; Bind the debugger to the trap handler
              	; Any trap can now be used to invoke the machine language monitor
              	;
              	; Returns nothing
              	; Uses: A, HL
0962:         	debug_bind:
              	
              		; Save previous binding
0962: 3A3607  		ld	a,(trap_res_flag)
0965: 2A3707  		ld	hl,(trap_res_flag+1)
0968: 32FF13  		ld	(debug_pbind),a
096B: 220014  		ld	(debug_pbind+1),hl
              		
              		; Bind debugger handle
096E: 3ECD    		ld	a,0xCD
0970: 21E607  		ld	hl,debug_handle
0973: 323607  		ld	(trap_res_flag),a
0976: 223707  		ld	(trap_res_flag+1),hl
              		
0979: C9      		ret
              		
              	; Unbind the debugger and allow traps to process normally
              	;
              	; Returns nothjing
              	; Uses: A, HL
097A:         	debug_unbind:
              		
              		; Restore previous binding
097A: 3AFF13  		ld	a,(debug_pbind)
097D: 2A0014  		ld	hl,(debug_pbind+1)
0980: 323607  		ld	(trap_res_flag),a
0983: 223707  		ld	(trap_res_flag+1),hl
              		
0986: C9      		ret
              		
              	; Print the contexts of register A onto the terminal
              	; This should really only be used in early system debugging
              	; A = Byte to print
              	;
              	; Returns nothing
              	; Uses: All
0987:         	debug_puta:
0987: CDFB09  		call	tohex
098A: ED530E0E		ld	(str_debug_val),de
098E: 11060E  		ld	de,str_debug
0991: C3B909  		jp	cpm_print
              		
              		
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Debug string
0E06:         	str_debug:
0E06: 52454720		defb 	'REG A = '
0E0A: 41203D20	
0E0E:         	str_debug_val:
0E0E: 58580A0D		defb	'XX',0x0A,0x0D,'$'
0E12: 24      	
              		
              	; Flag template
0E13:         	debug_flags:
0E13: 535A3548		defb	'SZ5H3PNC'
0E17: 33504E43	
              	
              	; Register dump string
0E1B:         	str_rdump:
0E1B: 1E17    		defb	0x1E,0x17
0E1D: 50433A20		defb	'PC: '
0E21:         	str_rdump_pc:
0E21: 58585858		defb	'XXXX SP: '
0E25: 2053503A	
0E29: 20      	
0E2A:         	str_rdump_sp:
0E2A: 58585858		defb	'XXXX NEXT: '
0E2E: 204E4558	
0E32: 543A20  	
0E35:         	str_rdump_isr:
0E35: 58585858		defb	'XXXXXXXX',0x0A,0x0D
0E39: 58585858	
0E3D: 0A0D    	
              	
0E3F: 464C4147		defb	'FLAGS: '
0E43: 533A20  	
0E46:         	str_rdump_flag:
0E46: 2D2D2D2D		defb	'-------- EI: '
0E4A: 2D2D2D2D	
0E4E: 2045493A	
0E52: 20      	
0E53:         	str_rdump_ei:
0E53: 2D20492F		defb	'- I/O: '
0E57: 4F3A20  	
0E5A:         	str_rdump_io:
0E5A: 2D0A0D  		defb	'-',0x0A,0x0D
              		
0E5D: 523D2041		defb	'R= AF: '
0E61: 463A20  	
0E64:         	str_rdump_af:
0E64: 58585858		defb	'XXXX BC: '
0E68: 2042433A	
0E6C: 20      	
0E6D:         	str_rdump_bc:
0E6D: 58585858		defb	'XXXX DE: '
0E71: 2044453A	
0E75: 20      	
0E76:         	str_rdump_de:
0E76: 58585858		defb	'XXXX HL: '
0E7A: 20484C3A	
0E7E: 20      	
0E7F:         	str_rdump_hl:
0E7F: 58585858		defb	'XXXX',0x0A,0x0D
0E83: 0A0D    	
              		
0E85: 583D2041		defb	'X= AF: '
0E89: 463A20  	
0E8C:         	str_rdump_aaf:
0E8C: 58585858		defb	'XXXX BC: '
0E90: 2042433A	
0E94: 20      	
0E95:         	str_rdump_abc:
0E95: 58585858		defb	'XXXX DE: '
0E99: 2044453A	
0E9D: 20      	
0E9E:         	str_rdump_ade:
0E9E: 58585858		defb	'XXXX HL: '
0EA2: 20484C3A	
0EA6: 20      	
0EA7:         	str_rdump_ahl:
0EA7: 58585858		defb	'XXXX',0x0A,0x0D
0EAB: 0A0D    	
              		
0EAD: 453D2049		defb	'E= IX: '
0EB1: 583A20  	
0EB4:         	str_rdump_ix:
0EB4: 58585858		defb	'XXXX IY: '
0EB8: 2049593A	
0EBC: 20      	
0EBD:         	str_rdump_iy:
0EBD: 58585858		defb	'XXXX',0x0A,0x0D,'$'
0EC1: 0A0D24  	
              		
              	; Debug prompt
0EC4:         	str_prompt
0EC4: 0A0D2A24		defb	0x0A,0x0D,'*','$'
              		
              	; Input buffer
0EC8:         	input_buff:
0EC8: 28      		defb	40
0EC9: 00000000		defs	41
0ECD: 00...   	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Previous trap bind
13FF:         	debug_pbind:
13FF: 000000  		defs	3
              		
              	; General purpose memory register
              	; Usually used in context swaps
1402:         	debug_temp:
1402: 0000    		defs	2
              		
              	; Debug program counter value
1404:         	debug_pc_state:
1404: 0000    		defs	2
              		
              	; Debug skip over flag
1406:         	debug_f_over:
1406: 00      		defs	1
              		
              	; Debug skip over stack value
1407:         	debug_over_sp:
1407: 0000    		defs	2
              		
              	; Machine state
              	; IY	-20
              	; IX	-18
              	; 'HL	-16
              	; 'DE	-14
              	; 'BC	-12
              	; 'AF 	-10
              	; HL	-8
              	; DE	-6
              	; BC	-4
              	; AF	-2
              	; --- TOP ---
1409: 00000000		defs	20
140D: 00...   	
141D:         	debug_state:
              	
              	; --------------------------------
              	; ******** KRISYS Startup ********
              	; --------------------------------
              	
              	.area	_TEXT
              		
              		; KRISYS entry point
0994:         	kri_start:	
              		; Set up stack
0994: F3      		di
0995: 310070  		ld	sp,kri_stack
0998: 21F309  		ld	hl,cpm_exit
099B: E5      		push	hl
              		
              		; Print "hello" splash
099C: 0E09    		ld	c,bdos_print
099E: 11F20E  		ld	de,str_splash
09A1: CD0500  		call	bdos
              		
              		; Initalize subcomponents
09A4: CD4E07  		call	irq_init
09A7: CDFC01  		call	zmm_init
09AA: CD4207  		call	trap_init
09AD: CD0301  		call	mem_map_init
09B0: CD4103  		call	res_init
09B3: CD4709  		call 	debug_init
              		
              		; Start the core
09B6: C3120A  		jp	core_start
              		
              	; ------------------------------
              	; ******** CP/M Service ********
              	; ------------------------------
              		
              	; Print something to the CP/M console
              	; DE = Address of string to print
              	;
              	; Returns nothing
              	; Uses: All
09B9:         	cpm_print:
              		; Save control register state
09B9: 3A3913  		ld	a,(zmm_ctrl_state)
09BC: F5      		push	af
              		
              		; Go to real mode
09BD: CD9C02  		call zmm_set_real
              		
              		; Do BDOS call
09C0: 0E09    		ld	c,bdos_print
09C2: CD0500  		call	bdos
              		
              		; Restore register
09C5: F1      		pop	af
09C6: 323913  		ld	(zmm_ctrl_state),a
09C9: C38B02  		jp	zmm_ctrl_set
              		
              	; Gets a line of input from the console
              	; DE = Address of result
              	;
              	; Returns nothing
              	; Uses: All
09CC:         	cpm_input:
              		; Save control register state
09CC: 3A3913  		ld	a,(zmm_ctrl_state)
09CF: F5      		push	af
              		
              		; Go to real mode
09D0: CD9C02  		call zmm_set_real
              		
              		; Do BDOS call
09D3: 0E0A    		ld	c,bdos_input
09D5: CD0500  		call	bdos
              		
              		; Restore register
09D8: F1      		pop	af
09D9: 323913  		ld	(zmm_ctrl_state),a
09DC: C38B02  		jp	zmm_ctrl_set
              		
              	; Gets a character from the console
              	;
              	; Returns C = character returns
              	; Uses: All
09DF:         	cpm_getc:
              		; Save control register state
09DF: 3A3913  		ld	a,(zmm_ctrl_state)
09E2: F5      		push	af
              		
              		; Go to real mode
09E3: CD9C02  		call zmm_set_real
              		
              		; Do BDOS call
09E6: 0E01    		ld	c,bdos_con_in
09E8: CD0500  		call	bdos
09EB: 4F      		ld	c,a
              		
              		; Restore register
09EC: F1      		pop	af
09ED: 323913  		ld	(zmm_ctrl_state),a
09F0: C38B02  		jp	zmm_ctrl_set
              		
              	; Go back to CP/M
              	;
              	; Does not return
              	; Uses: N/A
09F3:         	cpm_exit:
09F3: CD9C02  		call	zmm_set_real
09F6: 0E00    		ld	c,bdos_exit
09F8: CD0500  		call	bdos	
              		
              	; ----------------------
              	; ******** Misc ********
              	; ----------------------
              		
              	; Converts the value into an 8 bit hex number
              	; A = Number to convert
              	;
              	; Returns DE = result
              	; Uses: AF, DE
09FB: 57      	tohex:	ld	d,a
09FC: CD060A  		call	0$
09FF: 5F      		ld	e,a
0A00: 7A      		ld	a,d
0A01: CD0A0A  		call	1$
0A04: 57      		ld	d,a
0A05: C9      		ret
              		
0A06: 1F      	0$:	rra
0A07: 1F      		rra
0A08: 1F      		rra
0A09: 1F      		rra
0A0A: F6F0    	1$:	or	0xF0
0A0C: 27      		daa
0A0D: C6A0    		add	a,0xA0
0A0F: CE40    		adc	a,0x40
0A11: C9      		ret
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0EF2:         	str_splash:
0EF2: 4944454E		defb	'IDENTITY KRISYS HYPERVISOR, CP/M EDT.',0x0A,0x0D
0EF6: 54495459	
0EFA: 204B5249	
0EFE: 53595320	
0F02: 48595045	
0F06: 52564953	
0F0A: 4F522C20	
0F0E: 43502F4D	
0F12: 20454454	
0F16: 2E0A0D  	
0F19: 5645522E		defb	'VER. 0.0.1, GAVIN TERSTEEG 2024'
0F1D: 20302E30	
0F21: 2E312C20	
0F25: 47415649	
0F29: 4E205445	
0F2D: 52535445	
0F31: 45472032	
0F35: 303234  	
              		
              	; Carriage return, line break
0F38:         	str_crlf:
0F38: 0A0D24  		defb	0x0A,0x0D,'$' 
              		
              	
              	; ---------------------------
              	; ******** Core Init ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Start of MSX 1 core
0A12:         	core_start:
              	
              		; Try to find bios resource
0A12: 113B0F  		ld	de,str_bios
0A15: CDE304  		call	res_locate
0A18: B7      		or	a
0A19: C2D403  		jp	nz,res_missing
              		
              		; Open the resource
0A1C: CDF103  		call	res_open
              		
              		; Load resources into bankmap
0A1F: 212014  		ld	hl,bm_bios
0A22: 010001  		ld	bc,256
0A25: CD4B03  		call	res_load
              		
              		; Try to find slot 1 resource
0A28: AF      		xor	a
0A29: 321D14  		ld	(mx_has_slot_1),a
0A2C: 11400F  		ld	de,str_slot_1
0A2F: CDE304  		call	res_locate
0A32: B7      		or	a
0A33: C2470A  		jp	nz,1$
0A36: 3EFF    		ld	a,0xFF
0A38: 321D14  		ld	(mx_has_slot_1),a
              		
              		; Open the resource
0A3B: CDF103  		call	res_open
              		
              		; Load resources into bankmap
0A3E: 211E14  		ld	hl,bm_slot_1
0A41: 010001  		ld	bc,256
0A44: CD4B03  		call	res_load
              		
0A47:         	1$:
              		
              		; Program the I/O map
0A47: 11430F  		ld	de,str_prgm
0A4A: CDB909  		call	cpm_print
              		
              		; Do input map
0A4D: CD9102  		call	zmm_set_virt
0A50: CDA702  		call	zmm_prgm_in
0A53: 21950F  		ld	hl,io_map_input
0A56: 110080  		ld	de,zmm_map
0A59: 010001  		ld	bc,256
0A5C: EDB0    		ldir
              		
              		; Do output map
0A5E: CDB202  		call	zmm_prgm_out
0A61: 219510  		ld	hl,io_map_output
0A64: 110080  		ld	de,zmm_map
0A67: 010001  		ld	bc,256
0A6A: EDB0    		ldir
              		
              		; Set up slot map
0A6C: 115C0F  		ld	de,str_slots
0A6F: CDB909  		call	cpm_print
              		
              		; Allocate a bank the invalid slot ID
0A72: 1601    		ld	d,1
0A74: CDB501  		call	mem_alloc
0A77: F5      		push	af
0A78: CDFB02  		call	zmm_bnk3_set
0A7B: 2100C0  		ld	hl,zmm_top
0A7E: 1101C0  		ld	de,zmm_top+1
0A81: 01FF3F  		ld	bc,0x4000-1
0A84: 36C7    		ld	(hl),0xC7
0A86: EDB0    		ldir
0A88: F1      		pop	af
0A89: F680    		or	0b10000000
0A8B: 322214  		ld	(null_page),a
              		
              		; Fill slot map with invalid pages
0A8E: 214414  		ld	hl,mx_page_0
0A91: 114514  		ld	de,mx_page_0+1
0A94: 010F00  		ld	bc,16-1
0A97: 77      		ld	(hl),a
0A98: EDB0    		ldir
              		
              		; Allocate free ram
0A9A: 11720F  		ld	de,str_ram_alloc
0A9D: CDB909  		call	cpm_print
              		
              		; Mount Slot 1 RAM
0AA0: 1601    		ld	d,1
0AA2: CDB501  		call	mem_alloc
0AA5: 324514  		ld	(mx_page_0+1),a
0AA8: 1601    		ld	d,1
0AAA: CDB501  		call	mem_alloc
0AAD: 324914  		ld	(mx_page_1+1),a
0AB0: 1601    		ld	d,1
0AB2: CDB501  		call	mem_alloc
0AB5: 324D14  		ld	(mx_page_2+1),a
0AB8: 1601    		ld	d,1
0ABA: CDB501  		call	mem_alloc
0ABD: 325114  		ld	(mx_page_3+1),a
              		
              		; Mount BIOS in slot 0
0AC0: 3A2014  		ld	a,(bm_bios)
0AC3: F680    		or	0b10000000
0AC5: 324414  		ld	(mx_page_0),a
0AC8: 3A2114  		ld	a,(bm_bios+1)
0ACB: F680    		or	0b10000000
0ACD: 324814  		ld	(mx_page_1),a
              		
              		; Mount User Slot 1
0AD0: 3A1D14  		ld	a,(mx_has_slot_1)
0AD3: B7      		or	a
0AD4: CAE70A  		jp	z,50$
0AD7: 3A1E14  		ld	a,(bm_slot_1)
0ADA: F680    		or	0b10000000
0ADC: 324A14  		ld	(mx_page_1+2),a
0ADF: 3A1F14  		ld	a,(bm_slot_1+1)
0AE2: F680    		or	0b10000000
0AE4: 324E14  		ld	(mx_page_2+2),a
0AE7:         	50$:
              		
              		; Initalize slots
0AE7: AF      		xor	a
0AE8: 324314  		ld	(mx_slot_state),a
0AEB: CD1F0D  		call	mx_slot_sync
              		
              		; Set up interrupt modes
0AEE: CDBD02  		call	zmm_irq_inter
0AF1: CDDE02  		call	zmm_irq_off
0AF4: CD6507  		call	irq_vdp_on
0AF7: CD7B07  		call	irq_keyb_on
              	;	call	irq_hcca_o_on
              		
              		; Reset joystick state
0AFA: AF      		xor	a
0AFB: 325814  		ld	(mx_ctrl_sel),a
0AFE: 3D      		dec	a
0AFF: 325914  		ld	(mx_ctrl_1),a
0B02: 325A14  		ld	(mx_ctrl_2),a
              		
              		; Reset keyboard state
0B05: 212314  		ld	hl,mx_key_matrix
0B08: 112414  		ld	de,mx_key_matrix+1
0B0B: 010F00  		ld	bc,16-1
0B0E: 36FF    		ld	(hl),0xFF
0B10: EDB0    		ldir
0B12: 213314  		ld	hl,mx_key_ttl
0B15: 113414  		ld	de,mx_key_ttl+1
0B18: 010F00  		ld	bc,16-1
0B1B: 3600    		ld	(hl),0
0B1D: EDB0    		ldir
              		
              		; Bind debugger
              	;	call	debug_bind
              		
              		; Start up VM
0B1F: 11830F  		ld	de,str_vm_start
0B22: CDB909  		call	cpm_print
              		
0B25: CD9102  		call	zmm_set_virt
0B28: 210000  		ld	hl,0x0000
0B2B: C35402  		jp	zmm_vm_start
              	
              	
              	; Remaps address space so all reads of the VDP address register results in a trap
              	;
              	; Returns nothing
              	; Uses: AF
0B2E:         	mx_vdpr_trap:
0B2E: CDA702  		call	zmm_prgm_in
0B31: 3E37    		ld	a,zmm_trap
0B33: 329980  		ld	(zmm_map+0x99),a
0B36: 329B80  		ld	(zmm_map+0x9B),a
0B39: 329D80  		ld	(zmm_map+0x9D),a
0B3C: 329F80  		ld	(zmm_map+0x9F),a
0B3F: C9      		ret
              		
              	; Untraps all VDP register read operations
              	;
              	; Returns nothing
              	; Uses: AF
0B40:         	mx_vdpr_untrap:
0B40: CDA702  		call	zmm_prgm_in
0B43: 3EA1    		ld	a,nabu_vdp_addr
0B45: 329980  		ld	(zmm_map+0x99),a
0B48: 329B80  		ld	(zmm_map+0x9B),a
0B4B: 329D80  		ld	(zmm_map+0x9D),a
0B4E: 329F80  		ld	(zmm_map+0x9F),a
0B51: C9      		ret
              		
              		; Exit out of the emulator
0B52:         	mx_exit:
0B52: CD9C02  		call	zmm_set_real
              		
              		; Bodge over the serial # in VRAM
0B55: 21FE57  		ld	hl,0x17FE + 0x4000
0B58: 7D      		ld	a,l
0B59: D3A1    		out	(nabu_vdp_addr),a
0B5B: 7C      		ld	a,h
0B5C: D3A1    		out	(nabu_vdp_addr),a
0B5E: AF      		xor	a
0B5F: D3A0    		out	(nabu_vdp_data),a
0B61: E3      		ex	(sp),hl
0B62: E3      		ex	(sp),hl
0B63: E3      		ex	(sp),hl
0B64: E3      		ex	(sp),hl
0B65: D3A0    		out	(nabu_vdp_data),a
              		
0B67: C3F309  		jp	cpm_exit
              		
              	; -----------------------------------
              	; ******** Interrupt Handler ********
              	; -----------------------------------
              		
              	.area	_TEXT
              		
              		
              	; Handle a "keyboard" event
0B6A:         	mx_keyboard:
              		
              		; Get the latest scancode from the keyboard
0B6A: DB90    		in	a,(nabu_key_data)
0B6C: 325614  		ld	(mx_last_stroke),a
              		
              		; Is it an 'ESC'?
0B6F: FE1B    		cp	0x1B
0B71: CA520B  		jp	z,mx_exit
              		
              		; Check for joystick 1
0B74: FE80    		cp	0x80
0B76: CA880B  		jp	z,20$
              		
              		; Check for joystick 2
0B79: FE81    		cp	0x81
0B7B: CA8D0B  		jp	z,21$
              		
              		; Joystick data byte?
0B7E: E6E0    		and	0b11100000
0B80: FEA0    		cp	0b10100000
0B82: CA930B  		jp	z,40$
              		
              		; General purpose key
0B85: C3B50B  		jp	mx_strike_key
              		
              		; Joystick 1 detected
0B88: AF      	20$:	xor	a
0B89: 325814  		ld	(mx_ctrl_sel),a
0B8C: C9      		ret
              		
              		; Joystick 2 detected
0B8D: 3E01    	21$:	ld	a,1
0B8F: 325814  		ld	(mx_ctrl_sel),a
0B92: C9      		ret
              	
              		; Handle a joystick data byte
0B93: C5      	40$:	push	bc
0B94: E5      		push	hl
0B95: 3A5614  		ld	a,(mx_last_stroke)
0B98: E61F    		and	0b00011111
0B9A: 0600    		ld	b,0
0B9C: 4F      		ld	c,a
0B9D: 219511  		ld	hl,mx_ctrltab
0BA0: 09      		add	hl,bc
0BA1: 3A5814  		ld	a,(mx_ctrl_sel)
0BA4: B7      		or	a
0BA5: 7E      		ld	a,(hl)
0BA6: C2AF0B  		jp	nz,50$
              		
              		; Joystick 0
0BA9: 325914  		ld	(mx_ctrl_1),a
0BAC: E1      		pop	hl
0BAD: C1      		pop	bc
0BAE: C9      		ret
              		
              		; Joystick  1
0BAF: 325A14  	50$:	ld	(mx_ctrl_2),a
0BB2: E1      		pop	hl
0BB3: C1      		pop	bc
0BB4: C9      		ret
              		
              	; Strike a key on the keyboard
              	; Leaves an impression on the matrix
0BB5:         	mx_strike_key:
0BB5: C5      		push	bc
0BB6: E5      		push	hl
              		
0BB7: 3A5614  		ld	a,(mx_last_stroke)
0BBA: B7      		or	a
0BBB: FA220C  		jp	m,99$
              		
              		; Get matrix vector
0BBE: 0600    		ld	b,0
0BC0: 4F      		ld	c,a
0BC1: CB21    		sla	c
0BC3: 21B511  		ld	hl,mx_keytab
0BC6: 09      		add	hl,bc
              		
              		; Process keystroke
0BC7: 7E      		ld	a,(hl)
0BC8: FEFF    		cp	0xFF
0BCA: CA220C  		jp	z,99$
0BCD: E5      		push	hl
0BCE: 4F      		ld	c,a
0BCF: CB29    		sra	c
0BD1: CBB9    		res	7,c
0BD3: CB29    		sra	c
0BD5: CB29    		sra	c
0BD7: CB29    		sra	c
0BD9: 212314  		ld	hl,mx_key_matrix
0BDC: 09      		add	hl,bc
0BDD: E60F    		and	0b0001111
0BDF: 0E01    		ld	c,1
0BE1: B7      	0$:	or	a
0BE2: CAEB0B  		jp	z,1$
0BE5: CB21    		sla	c
0BE7: 3D      		dec	a
0BE8: C3E10B  		jp	0$
0BEB: 79      	1$:	ld	a,c
0BEC: EEFF    		xor	0xFF
0BEE: 77      		ld	(hl),a
0BEF: 0E10    		ld 	c,16
0BF1: 09      		add	hl,bc
0BF2: 3602    		ld	(hl),2
0BF4: E1      		pop	hl
              		
0BF5: 23      		inc	hl
0BF6: 7E      		ld	a,(hl)
0BF7: FEFF    		cp	0xFF
0BF9: CA220C  		jp	z,99$
0BFC: 4F      		ld	c,a
0BFD: CB29    		sra	c
0BFF: CBB9    		res	7,c
0C01: CB29    		sra	c
0C03: CB29    		sra	c
0C05: CB29    		sra	c
0C07: 212314  		ld	hl,mx_key_matrix
0C0A: 09      		add	hl,bc
0C0B: E60F    		and	0b0001111
0C0D: 0E01    		ld	c,1
0C0F: B7      	2$:	or	a
0C10: CA190C  		jp	z,3$
0C13: CB21    		sla	c
0C15: 3D      		dec	a
0C16: C30F0C  		jp	2$
0C19: 79      	3$:	ld	a,c
0C1A: EEFF    		xor	0xFF
0C1C: 77      		ld	(hl),a
0C1D: 0E10    		ld 	c,16
0C1F: 09      		add	hl,bc
0C20: 3602    		ld	(hl),2
              		
0C22: E1      	99$:	pop	hl
0C23: C1      		pop	bc
0C24: C9      		ret
              		
              		
              	; Handle "real" interrupts from devices (if needed)
              	; All registers except AF must remain unchanged!
0C25:         	irq_handle:
0C25: CDBD07  		call	irq_status
0C28: 0F      		rrca
0C29: D0      		ret	nc
              		
              		; Interrupt detected, VDP or keyboard?
0C2A: 0F      		rrca
0C2B: DA310C  		jp	c,0$
              	
              		; Ok, we hit a keyboard interrupt
0C2E: C36A0B  		jp	mx_keyboard
              		
              		; Ok, we hit a VDP interrupt
0C31: CD7007  	0$:	call	irq_vdp_off
0C34: CDD302  		call	zmm_irq_on
0C37: C32E0B  		jp	mx_vdpr_trap
              		
              		
              	; -----------------------------
              	; ******** I/O Handler ********
              	; -----------------------------
              		
              	.area	_TEXT
              	
              	; Handle an IN instruction
              	; Inputted value should be returned in register A
              	; All registers except AF must remain unchanged!
0C3A:         	in_handle:
0C3A: DB33    		in	a,(zmm_addr_lo)
0C3C: E6F8    		and	0b11111000
              		
              		; VDP?
0C3E: FE98    		cp	0x98
0C40: CA5F0C  		jp	z,vdp_in
              	
              		; PSG?
0C43: FEA0    		cp	0xA0
0C45: CA6B0C  		jp	z,psg_in
              		
              		; PPI?
0C48: FEA8    		cp	0xA8
0C4A: CAC70C  		jp	z,ppi_in
              	
0C4D: C9      		ret
              	
              	; Handle an OUT instruction
              	; A = Value outputted by virtual machine
              	; All registers except AF must remain unchanged!
0C4E:         	out_handle:
0C4E: F5      		push	af
0C4F: DB33    		in	a,(zmm_addr_lo)
0C51: E6F8    		and	0b11111000
              		
              		; PSG?
0C53: FEA0    		cp	0xA0
0C55: CA910C  		jp	z,psg_out
              		
              		; PPI?
0C58: FEA8    		cp	0xA8
0C5A: CAE30C  		jp	z,ppi_out
              		
0C5D: F1      		pop	af
0C5E: C9      		ret
              		
              		
              	; VDP input
0C5F:         	vdp_in:
0C5F: CD400B  		call	mx_vdpr_untrap
0C62: CDDE02  		call	zmm_irq_off
0C65: CD6507  		call	irq_vdp_on
0C68: DBA1    		in	a,(nabu_vdp_addr)
0C6A: C9      		ret
              		
              		
              	; PSG input
0C6B:         	psg_in:
              		; Read data
0C6B: 3A5514  		ld	a,(mx_ay_latch)
              		
              		; Port A?
0C6E: FE0E    		cp	14
0C70: CA7D0C  		jp	z,20$
              		
              		; Port B?
0C73: FE0F    		cp	15
0C75: CA8D0C  		jp	z,30$
              		
0C78: D341    		out	(nabu_ay_latch),a
0C7A: DB40    		in	a,(nabu_ay_data)
0C7C: C9      		ret
              		
              		; Read port A
0C7D: 3A5414  	20$:	ld	a,(mx_ay_port_b)
0C80: 07      		rlca
0C81: 07      		rlca
0C82: DA890C  		jp	c,25$
              		
              		; Read controller 1
0C85: 3A5914  		ld	a,(mx_ctrl_1)
0C88: C9      		ret
              		
              		; Read controller 2
0C89: 3A5A14  	25$:	ld	a,(mx_ctrl_2)
0C8C: C9      		ret
              		
              		; Read port B
0C8D: 3A5414  	30$:	ld	a,(mx_ay_port_b)
0C90: C9      		ret
              		
              	
              	; PSG output
0C91:         	psg_out:
0C91: DB33    		in	a,(zmm_addr_lo)
0C93: 0F      		rrca
0C94: DA9E0C  		jp	c,20$
              		
              		; Set latch
0C97: F1      		pop	af
0C98: E60F    		and	0b00001111
0C9A: 325514  		ld	(mx_ay_latch),a
0C9D: C9      		ret
              		
              		; Set data
0C9E: 3A5514  	20$:	ld	a,(mx_ay_latch)
              		
              		; Enable?
0CA1: FE07    		cp	7
0CA3: CAB60C  		jp	z,30$
              		
              		; Port A?
0CA6: FE0E    		cp	14
0CA8: CAC00C  		jp	z,40$
              		
              		; Port B?
0CAB: FE0F    		cp	15
0CAD: CAC20C  		jp	z,50$
              		
              		; Normal write
0CB0: D341    		out	(nabu_ay_latch),a
0CB2: F1      		pop	af
0CB3: D340    		out	(nabu_ay_data),a
0CB5: C9      		ret
              		
              		; Enable channels
0CB6: D341    	30$: 	out	(nabu_ay_latch),a
0CB8: F1      		pop	af
0CB9: E63F    		and	0b00111111
0CBB: F640    		or	0b01000000
0CBD: D340    		out	(nabu_ay_data),a
0CBF: C9      		ret
              		
              		; Write port A
0CC0: F1      	40$:	pop	af
0CC1: C9      		ret
              		
              		; Write port B
0CC2: F1      	50$:	pop	af
0CC3: 325414  		ld	(mx_ay_port_b),a
0CC6: C9      		ret
              		
              		
              	; PPI input
0CC7:         	ppi_in:
0CC7: DB33    		in	a,(zmm_addr_lo)
0CC9: 0F      		rrca
0CCA: DAD90C  		jp	c,20$
              		
              		; Even address
0CCD: 0F      		rrca
0CCE: DAD80C  		jp	c,10$
              		
              		; Port A
0CD1: 3A4314  		ld	a,(mx_slot_state)
0CD4: C9      		ret
              		
              		; Port C
0CD5: 3A5714  		ld	a,(mx_key_cas)
0CD8: C9      	10$:	ret
              		
              		
              		; Odd address
0CD9: 0F      	20$:	rrca
0CDA: DA3000  		jp	c,$30
              		
              		; Port B
0CDD: C3010D  		jp	mx_key_scan
              		
              		; CTRL register
0CE0: 3EFF    	30$:	ld	a,0xFF
0CE2: C9      		ret
              		
              	
              	; PPI output
0CE3:         	ppi_out:
0CE3: DB33    		in	a,(zmm_addr_lo)
0CE5: 0F      		rrca
0CE6: DAF90C  		jp	c,20$
              		
              		; Even address
0CE9: 0F      		rrca
0CEA: DAF40C  		jp	c,10$
              		
              		; Port A
0CED: F1      		pop	af
0CEE: 324314  		ld	(mx_slot_state),a
0CF1: C31F0D  		jp	mx_slot_sync
              		
              		; Port C
0CF4: F1      	10$:	pop	af
0CF5: 325714  		ld	(mx_key_cas),a
0CF8: C9      		ret
              		
              		
              		; Odd address
0CF9: 0F      	20$:	rrca
0CFA: DAFF0C  		jp	c,30$
              		
              		; Port B
0CFD: F1      		pop	af
0CFE: C9      		ret
              		
              		; CTRL register
0CFF: F1      	30$:	pop	af
0D00: C9      		ret
              		
              		
              	; Get key inputs from the matrix
              	; A = return keyboard scan code
0D01:         	mx_key_scan:
0D01: C5      		push	bc
0D02: E5      		push	hl
              		
              		; Get matrix row
0D03: 3A5714  		ld	a,(mx_key_cas)
0D06: E60F    		and	0b00001111
0D08: 4F      		ld	c,a
0D09: 0600    		ld	b,0
0D0B: 213314  		ld	hl,mx_key_ttl
0D0E: 09      		add	hl,bc
0D0F: 7E      		ld	a,(hl)
0D10: B7      		or	a
0D11: 3EFF    		ld	a,0xFF
0D13: CA1C0D  		jp	z,99$
0D16: 35      		dec	(hl)
0D17: 212314  		ld	hl,mx_key_matrix
0D1A: 09      		add	hl,bc
0D1B: 7E      		ld	a,(hl)
              		
0D1C: E1      	99$:	pop	hl
0D1D: C1      		pop	bc
0D1E: C9      		ret
              		
              	; Sync virtual memory map with expected slot state
0D1F:         	mx_slot_sync:
0D1F: C5      		push	bc
0D20: E5      		push	hl
              	
              		; Unpack pages 0-3, and set memory banks accordingly
0D21: 3A4314  		ld	a,(mx_slot_state)
0D24: 0600    		ld	b,0
              		
              		; Page 0
0D26: F5      		push	af
0D27: E603    		and	0b00000011
0D29: 4F      		ld	c,a
0D2A: 214414  		ld	hl,mx_page_0
0D2D: 09      		add	hl,bc
0D2E: 7E      		ld	a,(hl)
0D2F: CDE902  		call	zmm_bnk0_set
0D32: F1      		pop	af
0D33: 0F      		rrca
0D34: 0F      		rrca
              		
              		; Page 1
0D35: F5      		push	af
0D36: E603    		and	0b00000011
0D38: 4F      		ld	c,a
0D39: 214814  		ld	hl,mx_page_1
0D3C: 09      		add	hl,bc
0D3D: 7E      		ld	a,(hl)
0D3E: CDEF02  		call	zmm_bnk1_set
0D41: F1      		pop	af
0D42: 0F      		rrca
0D43: 0F      		rrca
              		
              		; Page 2
0D44: F5      		push	af
0D45: E603    		and	0b00000011
0D47: 4F      		ld	c,a
0D48: 214C14  		ld	hl,mx_page_2
0D4B: 09      		add	hl,bc
0D4C: 7E      		ld	a,(hl)
0D4D: CDF502  		call	zmm_bnk2_set
0D50: F1      		pop	af
0D51: 0F      		rrca
0D52: 0F      		rrca
              		
              		; Page 3
0D53: F5      		push	af
0D54: E603    		and	0b00000011
0D56: 4F      		ld	c,a
0D57: 215014  		ld	hl,mx_page_3
0D5A: 09      		add	hl,bc
0D5B: 7E      		ld	a,(hl)
0D5C: CDFB02  		call	zmm_bnk3_set
0D5F: F1      		pop	af
              		
              		
0D60: E1      		pop	hl
0D61: C1      		pop	bc
0D62: C9      		ret
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Resource strings
0F3B:         	str_bios:
0F3B: 42494F53		defb	'BIOS',0
0F3F: 00      	
              		
0F40:         	str_slot_1:
0F40: 533100  		defb	'S1',0
              		
              	; Bootup strings
0F43:         	str_prgm:
0F43: 50524F47		defb	'PROGRAMMING VM I/O MAP',0x0A,0x0D,'$'
0F47: 52414D4D	
0F4B: 494E4720	
0F4F: 564D2049	
0F53: 2F4F204D	
0F57: 41500A0D	
0F5B: 24      	
              	
              	; Bootup strings
0F5C:         	str_slots:
0F5C: 53455454		defb	'SETTING UP SLOT MAP',0x0A,0x0D,'$'
0F60: 494E4720	
0F64: 55502053	
0F68: 4C4F5420	
0F6C: 4D41500A	
0F70: 0D24    	
              		
              	; Bootup strings
0F72:         	str_ram_alloc:
0F72: 414C4C4F		defb	'ALLOCATING RAM',0x0A,0x0D,'$'
0F76: 43415449	
0F7A: 4E472052	
0F7E: 414D0A0D	
0F82: 24      	
              		
              	; Bootup strings
0F83:         	str_vm_start:
0F83: 53544152		defb	'STARTING VM NOW',0x0A,0x0D,'$'
0F87: 54494E47	
0F8B: 20564D20	
0F8F: 4E4F570A	
0F93: 0D24    	
              	
              	
              	; ----------------------
              	; ******** Data ********
              	; ----------------------
              		
              	.area	_DATA
              	
0037:         	TRAP	equ	zmm_trap	; Trap Vector
00A0:         	_VDD	equ	nabu_vdp_data	; VDP Data
00A1:         	_VDA	equ	nabu_vdp_addr	; VDP Address
              	
              	; Virtual machine I/O maps
              	; Input map
0F95:         	io_map_input:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
0F95: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
0F99: 37...   	
0FA5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
0FA9: 37...   	
0FB5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
0FB9: 37...   	
0FC5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
0FC9: 37...   	
0FD5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
0FD9: 37...   	
0FE5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
0FE9: 37...   	
0FF5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
0FF9: 37...   	
1005: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
1009: 37...   	
1015: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x8*
1019: 37...   	
1025: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x9*
1029: 37373737	
102D: A0A1A0A1	
1031: A0A1A0A1	
1035: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xA*
1039: 37...   	
1045: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xB*
1049: 37...   	
1055: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
1059: 37...   	
1065: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
1069: 37...   	
1075: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
1079: 37...   	
1085: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
1089: 37...   	
              	
              	; Output map
1095:         	io_map_output:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
1095: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
1099: 37...   	
10A5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
10A9: 37...   	
10B5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
10B9: 37...   	
10C5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
10C9: 37...   	
10D5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
10D9: 37...   	
10E5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
10E9: 37...   	
10F5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
10F9: 37...   	
1105: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
1109: 37...   	
1115: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x8*
1119: 37...   	
1125: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x9*
1129: 37373737	
112D: A0A1A0A1	
1131: A0A1A0A1	
1135: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xA*
1139: 37...   	
1145: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xB*
1149: 37...   	
1155: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
1159: 37...   	
1165: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
1169: 37...   	
1175: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
1179: 37...   	
1185: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
1189: 37...   	
              	
              	; MSX controller table
1195:         	mx_ctrltab:
1195: BF      		defb	~0b01000000	; -----
1196: BB      		defb	~0b01000100	; ----L
1197: BD      		defb	~0b01000010	; ---D-
1198: B9      		defb	~0b01000110	; ---DL
1199: B7      		defb	~0b01001000	; --R--
119A: B3      		defb	~0b01001100	; --R-L
119B: B5      		defb	~0b01001010	; --RD-
119C: B1      		defb	~0b01001110	; --RDL
119D: BE      		defb	~0b01000001	; -U---
119E: BA      		defb	~0b01000101	; -U--L
119F: BC      		defb	~0b01000011	; -U-D-
11A0: B8      		defb	~0b01000111	; -U-DL
11A1: B6      		defb	~0b01001001	; -UR--
11A2: B2      		defb	~0b01001101	; -UR-L
11A3: B4      		defb	~0b01001011	; -URD-
11A4: B0      		defb	~0b01001111	; -URDL
11A5: AF      		defb	~0b01010000	; F----
11A6: AB      		defb	~0b01010100	; F---L
11A7: AD      		defb	~0b01010010	; F--D-
11A8: A9      		defb	~0b01010110	; F--DL
11A9: A7      		defb	~0b01011000	; F-R--
11AA: A3      		defb	~0b01011100	; F-R-L
11AB: A5      		defb	~0b01011010	; F-RD-
11AC: A1      		defb	~0b01011110	; F-RDL
11AD: AE      		defb	~0b01010001	; FU---
11AE: AA      		defb	~0b01010101	; FU--L
11AF: AC      		defb	~0b01010011	; FU-D-
11B0: A8      		defb	~0b01010111	; FU-DL
11B1: A6      		defb	~0b01011001	; FUR--
11B2: A2      		defb	~0b01011101	; FUR-L
11B3: A4      		defb	~0b01011011	; FURD-
11B4: A0      		defb	~0b01011111	; FURDL
              	
              	; Keyboard lookup table
11B5:         	mx_keytab:
11B5: 2661    		defb	0x26,0x61	; 0x00 CTRL-@
11B7: 2761    		defb	0x27,0x61	; 0x01 CTRL-A
11B9: 3061    		defb	0x30,0x61	; 0x02 CTRL-B
11BB: 3161    		defb	0x31,0x61	; 0x03 CTRL-C
11BD: 3261    		defb	0x32,0x61	; 0x04 CTRL-D
11BF: 3361    		defb	0x33,0x61	; 0x05 CTRL-E
11C1: 3461    		defb	0x34,0x61	; 0x06 CTRL-F
11C3: 3561    		defb	0x35,0x61	; 0x07 CTRL-G
11C5: 75FF    		defb	0x75,0xFF	; 0x08 CTRL-H
11C7: 73FF    		defb	0x73,0xFF	; 0x09 CTRL-I
11C9: 4061    		defb	0x40,0x61	; 0x0A CTRL-J
11CB: 4161    		defb	0x41,0x61	; 0x0B CTRL-K
11CD: 4261    		defb	0x42,0x61	; 0x0C CTRL-L
11CF: 77FF    		defb	0x77,0xFF	; 0x0D CTRL-M
11D1: 4461    		defb	0x44,0x61	; 0x0E CTRL-N
11D3: 4561    		defb	0x45,0x61	; 0x0F CTRL-O
11D5: 4661    		defb	0x46,0x61	; 0x10 CTRL-P
11D7: 4761    		defb	0x47,0x61	; 0x11 CTRL-Q
11D9: 5061    		defb	0x50,0x61	; 0x12 CTRL-R
11DB: 5161    		defb	0x51,0x61	; 0x13 CTRL-S
11DD: 5261    		defb	0x52,0x61	; 0x14 CTRL-T
11DF: 5361    		defb	0x53,0x61	; 0x15 CTRL-U
11E1: 5461    		defb	0x54,0x61	; 0x16 CTRL-V
11E3: 5561    		defb	0x55,0x61	; 0x07 CTRL-W
11E5: 5661    		defb	0x56,0x61	; 0x18 CTRL-X
11E7: 5761    		defb	0x57,0x61	; 0x19 CTRL-Y
11E9: FF61    		defb	0xFF,0x61	; 0x1A CTRL-Z
11EB: 72FF    		defb	0x72,0xFF	; 0x1B CTRL-[ (ESC)
11ED: FF61    		defb	0xFF,0x61	; 0x1C CTRL-<
11EF: FF61    		defb	0xFF,0x61	; 0x1D CTRL-]
11F1: FF61    		defb	0xFF,0x61	; 0x1E CTRL-^
11F3: FF61    		defb	0xFF,0x61	; 0x1F CTRL--
11F5: 80FF    		defb	0x80,0xFF	; 0x20 Space
11F7: 0160    		defb	0x01,0x60	; 0x21 !
11F9: 2060    		defb	0x20,0x60	; 0x22 "
11FB: 0360    		defb	0x03,0x60	; 0x23 #
11FD: 0460    		defb	0x04,0x60	; 0x24 $
11FF: 0560    		defb	0x05,0x60	; 0x25 %
1201: 0760    		defb	0x07,0x60	; 0x26 &
1203: 20FF    		defb	0x20,0xFF	; 0x27 '
1205: 1160    		defb	0x11,0x60	; 0x28 (
1207: 0060    		defb	0x00,0x60	; 0x29 )
1209: 1060    		defb	0x10,0x60	; 0x2A *
120B: 1360    		defb	0x13,0x60	; 0x2B +
120D: 22FF    		defb	0x22,0xFF	; 0x2C ,
120F: 12FF    		defb	0x12,0xFF	; 0x2D -
1211: 23FF    		defb	0x23,0xFF	; 0x2E .
1213: 24FF    		defb	0x24,0xFF	; 0x2F /
1215: 00FF    		defb	0x00,0xFF	; 0x30 0
1217: 01FF    		defb	0x01,0xFF	; 0x31 1
1219: 02FF    		defb	0x02,0xFF	; 0x32 2
121B: 03FF    		defb	0x03,0xFF	; 0x33 3
121D: 04FF    		defb	0x04,0xFF	; 0x34 4
121F: 05FF    		defb	0x05,0xFF	; 0x35 5
1221: 06FF    		defb	0x06,0xFF	; 0x36 6
1223: 07FF    		defb	0x07,0xFF	; 0x37 7
1225: 10FF    		defb	0x10,0xFF	; 0x38 8
1227: 11FF    		defb	0x11,0xFF	; 0x39 9
1229: 1760    		defb	0x17,0x60	; 0x3A :
122B: 17FF    		defb	0x17,0xFF	; 0x3B ;
122D: 2260    		defb	0x22,0x60	; 0x3C <
122F: 13FF    		defb	0x13,0xFF	; 0x3D =
1231: 2360    		defb	0x23,0x60	; 0x3E >
1233: 2460    		defb	0x24,0x60	; 0x3F ?
1235: 0260    		defb	0x02,0x60	; 0x40 @
1237: 2660    		defb	0x26,0x60	; 0x41 A
1239: 2760    		defb	0x27,0x60	; 0x42 B
123B: 3060    		defb	0x30,0x60	; 0x43 C
123D: 3160    		defb	0x31,0x60	; 0x44 D
123F: 3260    		defb	0x32,0x60	; 0x45 E
1241: 3360    		defb	0x33,0x60	; 0x46 F
1243: 3460    		defb	0x34,0x60	; 0x47 G
1245: 3560    		defb	0x35,0x60	; 0x48 H
1247: 3660    		defb	0x36,0x60	; 0x49 I
1249: 3760    		defb	0x37,0x60	; 0x4A J
124B: 4060    		defb	0x40,0x60	; 0x4B K
124D: 4160    		defb	0x41,0x60	; 0x4C L
124F: 4260    		defb	0x42,0x60	; 0x4D M
1251: 4360    		defb	0x43,0x60	; 0x4E N
1253: 4460    		defb	0x44,0x60	; 0x4F O
1255: 4560    		defb	0x45,0x60	; 0x50 P
1257: 4660    		defb	0x46,0x60	; 0x51 Q
1259: 4760    		defb	0x47,0x60	; 0x52 R
125B: 5060    		defb	0x50,0x60	; 0x53 S
125D: 5160    		defb	0x51,0x60	; 0x54 T
125F: 5260    		defb	0x52,0x60	; 0x55 U
1261: 5360    		defb	0x53,0x60	; 0x56 V
1263: 5460    		defb	0x54,0x60	; 0x57 W
1265: 5560    		defb	0x55,0x60	; 0x58 X
1267: 5660    		defb	0x56,0x60	; 0x59 Y
1269: 5760    		defb	0x57,0x60	; 0x5A Z
126B: 15FF    		defb	0x15,0xFF	; 0x5B [
126D: 14FF    		defb	0x14,0xFF	; 0x5C N/A (\)
126F: 16FF    		defb	0x16,0xFF	; 0x5D ]
1271: 0660    		defb	0x06,0x60	; 0x5E ^
1273: 1260    		defb	0x12,0x60	; 0x5F _
1275: 25FF    		defb	0x25,0xFF	; 0x60 N/A (`)
1277: 26FF    		defb	0x26,0xFF	; 0x61 a
1279: 27FF    		defb	0x27,0xFF	; 0x62 b
127B: 30FF    		defb	0x30,0xFF	; 0x63 c
127D: 31FF    		defb	0x31,0xFF	; 0x64 d
127F: 32FF    		defb	0x32,0xFF	; 0x65 e
1281: 33FF    		defb	0x33,0xFF	; 0x66 f
1283: 34FF    		defb	0x34,0xFF	; 0x67 g
1285: 35FF    		defb	0x35,0xFF	; 0x68 h
1287: 36FF    		defb	0x36,0xFF	; 0x69 i
1289: 37FF    		defb	0x37,0xFF	; 0x6A j
128B: 40FF    		defb	0x40,0xFF	; 0x6B k
128D: 41FF    		defb	0x41,0xFF	; 0x6C l
128F: 42FF    		defb	0x42,0xFF	; 0x6D m
1291: 43FF    		defb	0x43,0xFF	; 0x6E n
1293: 44FF    		defb	0x44,0xFF	; 0x6F o
1295: 45FF    		defb	0x45,0xFF	; 0x70 p
1297: 46FF    		defb	0x46,0xFF	; 0x71 q
1299: 47FF    		defb	0x47,0xFF	; 0x72 r
129B: 50FF    		defb	0x50,0xFF	; 0x73 s
129D: 51FF    		defb	0x51,0xFF	; 0x74 t
129F: 52FF    		defb	0x52,0xFF	; 0x75 u
12A1: 53FF    		defb	0x53,0xFF	; 0x76 v
12A3: 54FF    		defb	0x54,0xFF	; 0x77 w
12A5: 55FF    		defb	0x55,0xFF	; 0x78 x
12A7: 56FF    		defb	0x56,0xFF	; 0x79 y
12A9: 57FF    		defb	0x57,0xFF	; 0x7A z
12AB: 1560    		defb	0x15,0x60	; 0x7B {
12AD: 1460    		defb	0x14,0x60	; 0x7C N/A (|)
12AF: 1660    		defb	0x16,0x60	; 0x7D }
12B1: FFFF    		defb	0xFF,0xFF	; 0x7E N/A (~)
12B3: 83FF    		defb	0x83,0xFF	; 0x7F Delete
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
141D:         	mx_has_slot_1:
141D: 00      		defs	1
              	
              	; Block map for slot 1 ROM
141E:         	bm_slot_1:
141E: 0000    		defs	2
              	
              	; Block map for BIOS
1420:         	bm_bios:
1420: 0000    		defs	2
              		
              	; Invalid page
1422:         	null_page:
1422: 00      		defs	1
              		
              	; Keyboard matrix state
1423:         	mx_key_matrix:
1423: 00000000		defs	16
1427: 00...   	
              		
              	; Keyboard matrix time to live
1433:         	mx_key_ttl:
1433: 00000000		defs	16
1437: 00...   	
              		
              	; Keeps track of the slot # form the PPI
1443:         	mx_slot_state:
1443: 00      		defs	1
              		
              	; MSX slot logic
1444:         	mx_page_0:
1444: 00000000		defs	4
1448:         	mx_page_1:
1448: 00000000		defs	4
144C:         	mx_page_2:
144C: 00000000		defs	4
1450:         	mx_page_3:
1450: 00000000		defs	4
              	
              	; MSX AY Port B output
1454:         	mx_ay_port_b:
1454: 00      		defs 	1
              		
1455:         	mx_ay_latch:
1455: 00      		defs	1
              		
              	; Last stroke from the keyboard
1456:         	mx_last_stroke:
1456: 00      		defs	1
              		
              	; Keeps keyboard scan signal and cas
1457:         	mx_key_cas:
1457: 00      		defs	1
              		
              	; Selected joystick for updating
              	; 0 = Joystick 1 selected
              	; 1 = Joystick 2 selected
1458:         	mx_ctrl_sel:
1458: 00      		defs	1
              		
              	; MSX joystick states
1459:         	mx_ctrl_1:
1459: 00      		defs	1
145A:         	mx_ctrl_2:
145A: 00      		defs	1


; +++ segments +++

#CODE _TEXT    = $0100 =   256,  size = $0C63 =  3171
#CODE _DATA    = $0D63 =  3427,  size = $0552 =  1362
#DATA _BSS     = $12B5 =  4789,  size = $01A6 =   422

; +++ global symbols +++

TRAP             = $0037 =    55  _DATA   KMSX.asm:720
_BSS             = $12B5 =  4789  _BSS    KRISYS.asm:28 (unused)
_BSS_end         = $145B =  5211  _BSS    KRISYS.asm:28
_BSS_size        = $01A6 =   422  _BSS    KRISYS.asm:28 (unused)
_DATA            = $0D63 =  3427  _DATA   KRISYS.asm:27 (unused)
_DATA_end        = $12B5 =  4789  _DATA   KRISYS.asm:27
_DATA_size       = $0552 =  1362  _DATA   KRISYS.asm:27 (unused)
_TEXT            = $0100 =   256  _TEXT   KRISYS.asm:26 (unused)
_TEXT_end        = $0D63 =  3427  _TEXT   KRISYS.asm:26
_TEXT_size       = $0C63 =  3171  _TEXT   KRISYS.asm:26 (unused)
_VDA             = $00A1 =   161  _DATA   KMSX.asm:722
_VDD             = $00A0 =   160  _DATA   KMSX.asm:721
alloc_bank_map   = $12B7 =  4791  _BSS    MEMORY.asm:307
arg_size         = $0010 =    16  _BSS    RESOURCE.asm:17
banks_free       = $12B6 =  4790  _BSS    MEMORY.asm:301
bdos             = $0005 =     5  _TEXT   KRISYS.asm:49
bdos_con_in      = $0001 =     1  _TEXT   KRISYS.asm:51
bdos_con_out     = $0002 =     2  _TEXT   KRISYS.asm:52
bdos_exit        = $0000 =     0  _TEXT   KRISYS.asm:50
bdos_input       = $000A =    10  _TEXT   KRISYS.asm:54
bdos_open        = $000F =    15  _TEXT   KRISYS.asm:55
bdos_print       = $0009 =     9  _TEXT   KRISYS.asm:53
bdos_read        = $0014 =    20  _TEXT   KRISYS.asm:56
bios_set_dma     = $001A =    26  _TEXT   KRISYS.asm:57
bm_bios          = $1420 =  5152  _BSS    KMSX.asm:945
bm_slot_1        = $141E =  5150  _BSS    KMSX.asm:941
core_start       = $0A12 =  2578  _TEXT   KMSX.asm:17
cpm_command      = $0080 =   128  _TEXT   KRISYS.asm:59
cpm_exit         = $09F3 =  2547  _TEXT   KRISYS.asm:212
cpm_getc         = $09DF =  2527  _TEXT   KRISYS.asm:190
cpm_input        = $09CC =  2508  _TEXT   KRISYS.asm:169 (unused)
cpm_print        = $09B9 =  2489  _TEXT   KRISYS.asm:147
debug_bind       = $0962 =  2402  _TEXT   DEBUG.asm:294 (unused)
debug_continue   = $092A =  2346  _TEXT   DEBUG.asm:216
debug_f_over     = $1406 =  5126  _BSS    DEBUG.asm:428
debug_flags      = $0E13 =  3603  _DATA   DEBUG.asm:351
debug_handle     = $07E6 =  2022  _TEXT   DEBUG.asm:18
debug_init       = $0947 =  2375  _TEXT   DEBUG.asm:255
debug_over       = $090C =  2316  _TEXT   DEBUG.asm:194
debug_over_sp    = $1407 =  5127  _BSS    DEBUG.asm:432
debug_pbind      = $13FF =  5119  _BSS    DEBUG.asm:415
debug_pc_state   = $1404 =  5124  _BSS    DEBUG.asm:424
debug_puta       = $0987 =  2439  _TEXT   DEBUG.asm:330 (unused)
debug_query      = $08F6 =  2294  _TEXT   DEBUG.asm:166 (unused)
debug_rtohex     = $094C =  2380  _TEXT   DEBUG.asm:269
debug_state      = $141D =  5149  _BSS    DEBUG.asm:448
debug_temp       = $1402 =  5122  _BSS    DEBUG.asm:420
debug_unbind     = $097A =  2426  _TEXT   DEBUG.asm:314 (unused)
debug_upper      = $091A =  2330  _TEXT   DEBUG.asm:204
in_handle        = $0C3A =  3130  _TEXT   KMSX.asm:399
input_buff       = $0EC8 =  3784  _DATA   DEBUG.asm:404 (unused)
io_map_input     = $0F95 =  3989  _DATA   KMSX.asm:726
io_map_output    = $1095 =  4245  _DATA   KMSX.asm:746
irq_handle       = $0C25 =  3109  _TEXT   KMSX.asm:372
irq_hcca_i_off   = $07B2 =  1970  _TEXT   IRQ.asm:125 (unused)
irq_hcca_i_on    = $07A7 =  1959  _TEXT   IRQ.asm:114 (unused)
irq_hcca_o_off   = $079C =  1948  _TEXT   IRQ.asm:103 (unused)
irq_hcca_o_on    = $0791 =  1937  _TEXT   IRQ.asm:92 (unused)
irq_init         = $074E =  1870  _TEXT   IRQ.asm:22
irq_keyb_off     = $0786 =  1926  _TEXT   IRQ.asm:81 (unused)
irq_keyb_on      = $077B =  1915  _TEXT   IRQ.asm:70
irq_mask_state   = $13FE =  5118  _BSS    IRQ.asm:182
irq_restore      = $07D0 =  2000  _TEXT   IRQ.asm:157
irq_status       = $07BD =  1981  _TEXT   IRQ.asm:136
irq_vdp_off      = $0770 =  1904  _TEXT   IRQ.asm:59
irq_vdp_on       = $0765 =  1893  _TEXT   IRQ.asm:48
kri_stack        = $7000 = 28672  _TEXT   KRISYS.asm:93
kri_start        = $0994 =  2452  _TEXT   KRISYS.asm:115
mem_alloc        = $01B5 =   437  _TEXT   MEMORY.asm:195
mem_empty        = $01F3 =   499  _TEXT   MEMORY.asm:269
mem_free         = $01D6 =   470  _TEXT   MEMORY.asm:227
mem_free_all     = $01E8 =   488  _TEXT   MEMORY.asm:253 (unused)
mem_fvbyte       = $0165 =   357  _TEXT   MEMORY.asm:101
mem_getbank      = $0190 =   400  _TEXT   MEMORY.asm:155
mem_map_init     = $0103 =   259  _TEXT   MEMORY.asm:30
mem_svbyte       = $0178 =   376  _TEXT   MEMORY.asm:128
mem_work         = $12B5 =  4789  _BSS    MEMORY.asm:297
mx_ay_latch      = $1455 =  5205  _BSS    KMSX.asm:978
mx_ay_port_b     = $1454 =  5204  _BSS    KMSX.asm:975
mx_ctrl_1        = $1459 =  5209  _BSS    KMSX.asm:996
mx_ctrl_2        = $145A =  5210  _BSS    KMSX.asm:998
mx_ctrl_sel      = $1458 =  5208  _BSS    KMSX.asm:992
mx_ctrltab       = $1195 =  4501  _DATA   KMSX.asm:766
mx_exit          = $0B52 =  2898  _TEXT   KMSX.asm:205
mx_has_slot_1    = $141D =  5149  _BSS    KMSX.asm:937
mx_key_cas       = $1457 =  5207  _BSS    KMSX.asm:986
mx_key_matrix    = $1423 =  5155  _BSS    KMSX.asm:953
mx_key_scan      = $0D01 =  3329  _TEXT   KMSX.asm:600
mx_key_ttl       = $1433 =  5171  _BSS    KMSX.asm:957
mx_keyboard      = $0B6A =  2922  _TEXT   KMSX.asm:232
mx_keytab        = $11B5 =  4533  _DATA   KMSX.asm:801
mx_last_stroke   = $1456 =  5206  _BSS    KMSX.asm:982
mx_page_0        = $1444 =  5188  _BSS    KMSX.asm:965
mx_page_1        = $1448 =  5192  _BSS    KMSX.asm:967
mx_page_2        = $144C =  5196  _BSS    KMSX.asm:969
mx_page_3        = $1450 =  5200  _BSS    KMSX.asm:971
mx_slot_state    = $1443 =  5187  _BSS    KMSX.asm:961
mx_slot_sync     = $0D1F =  3359  _TEXT   KMSX.asm:625
mx_strike_key    = $0BB5 =  2997  _TEXT   KMSX.asm:296
mx_vdpr_trap     = $0B2E =  2862  _TEXT   KMSX.asm:182
mx_vdpr_untrap   = $0B40 =  2880  _TEXT   KMSX.asm:195
nabu_ay_data     = $0040 =    64  _TEXT   KRISYS.asm:85
nabu_ay_latch    = $0041 =    65  _TEXT   KRISYS.asm:86
nabu_key_data    = $0090 =   144  _TEXT   KRISYS.asm:87
nabu_key_stat    = $0091 =   145  _TEXT   KRISYS.asm:88 (unused)
nabu_nctl        = $0000 =     0  _TEXT   KRISYS.asm:84 (unused)
nabu_vdp_addr    = $00A1 =   161  _TEXT   KRISYS.asm:90
nabu_vdp_data    = $00A0 =   160  _TEXT   KRISYS.asm:89
nmi_address      = $0066 =   102  _TEXT   KRISYS.asm:80
nmi_vector       = $0067 =   103  _TEXT   KRISYS.asm:81
null_page        = $1422 =  5154  _BSS    KMSX.asm:949
out_handle       = $0C4E =  3150  _TEXT   KMSX.asm:420
ppi_in           = $0CC7 =  3271  _TEXT   KMSX.asm:534
ppi_out          = $0CE3 =  3299  _TEXT   KMSX.asm:565
psg_in           = $0C6B =  3179  _TEXT   KMSX.asm:447
psg_out          = $0C91 =  3217  _TEXT   KMSX.asm:483
res_argument     = $133E =  4926  _BSS    RESOURCE.asm:480
res_bankmap      = $13D4 =  5076  _BSS    RESOURCE.asm:500
res_buffer       = $1351 =  4945  _BSS    RESOURCE.asm:488
res_current      = $134F =  4943  _BSS    RESOURCE.asm:484
res_do_read      = $13D3 =  5075  _BSS    RESOURCE.asm:496
res_fcb          = $13D8 =  5080  _BSS    RESOURCE.asm:508
res_fcb_cr       = $13F8 =  5112  _BSS    RESOURCE.asm:518 (unused)
res_fcb_data     = $13E8 =  5096  _BSS    RESOURCE.asm:517 (unused)
res_fcb_drive    = $13D8 =  5080  _BSS    RESOURCE.asm:510
res_fcb_ex       = $13E4 =  5092  _BSS    RESOURCE.asm:513 (unused)
res_fcb_name     = $13D9 =  5081  _BSS    RESOURCE.asm:511
res_fcb_r0       = $13F9 =  5113  _BSS    RESOURCE.asm:519 (unused)
res_fcb_r1       = $13FA =  5114  _BSS    RESOURCE.asm:520 (unused)
res_fcb_r2       = $13FB =  5115  _BSS    RESOURCE.asm:521 (unused)
res_fcb_rc       = $13E7 =  5095  _BSS    RESOURCE.asm:516 (unused)
res_fcb_s1       = $13E5 =  5093  _BSS    RESOURCE.asm:514 (unused)
res_fcb_s2       = $13E6 =  5094  _BSS    RESOURCE.asm:515 (unused)
res_fcb_type     = $13E1 =  5089  _BSS    RESOURCE.asm:512
res_init         = $0341 =   833  _TEXT   RESOURCE.asm:29
res_load         = $034B =   843  _TEXT   RESOURCE.asm:47
res_locate       = $04E3 =  1251  _TEXT   RESOURCE.asm:360
res_missing      = $03D4 =   980  _TEXT   RESOURCE.asm:153
res_open         = $03F1 =  1009  _TEXT   RESOURCE.asm:179
res_pointer      = $13D6 =  5078  _BSS    RESOURCE.asm:504
res_printzt      = $04D4 =  1236  _TEXT   RESOURCE.asm:340
res_sectors      = $13D1 =  5073  _BSS    RESOURCE.asm:492
stack_size       = $0020 =    32          KRISYS.asm:31
str_arg_empty    = $0DC6 =  3526  _DATA   RESOURCE.asm:464
str_arg_fail     = $0DDD =  3549  _DATA   RESOURCE.asm:467
str_bios         = $0F3B =  3899  _DATA   KMSX.asm:691
str_crlf         = $0F38 =  3896  _DATA   KRISYS.asm:256
str_debug        = $0E06 =  3590  _DATA   DEBUG.asm:345
str_debug_val    = $0E0E =  3598  _DATA   DEBUG.asm:347
str_load_a       = $0DB6 =  3510  _DATA   RESOURCE.asm:457
str_load_b       = $0DBF =  3519  _DATA   RESOURCE.asm:460
str_mem_empty    = $0D8E =  3470  _DATA   MEMORY.asm:287
str_mem_init     = $0D63 =  3427  _DATA   MEMORY.asm:281
str_mem_init_cnt = $0D88 =  3464  _DATA   MEMORY.asm:284
str_missing      = $0DF3 =  3571  _DATA   RESOURCE.asm:470
str_prgm         = $0F43 =  3907  _DATA   KMSX.asm:698
str_prompt       = $0EC4 =  3780  _DATA   DEBUG.asm:400 (unused)
str_ram_alloc    = $0F72 =  3954  _DATA   KMSX.asm:706
str_rdump        = $0E1B =  3611  _DATA   DEBUG.asm:355
str_rdump_aaf    = $0E8C =  3724  _DATA   DEBUG.asm:384
str_rdump_abc    = $0E95 =  3733  _DATA   DEBUG.asm:386
str_rdump_ade    = $0E9E =  3742  _DATA   DEBUG.asm:388
str_rdump_af     = $0E64 =  3684  _DATA   DEBUG.asm:374
str_rdump_ahl    = $0EA7 =  3751  _DATA   DEBUG.asm:390
str_rdump_bc     = $0E6D =  3693  _DATA   DEBUG.asm:376
str_rdump_de     = $0E76 =  3702  _DATA   DEBUG.asm:378
str_rdump_ei     = $0E53 =  3667  _DATA   DEBUG.asm:368
str_rdump_flag   = $0E46 =  3654  _DATA   DEBUG.asm:366
str_rdump_hl     = $0E7F =  3711  _DATA   DEBUG.asm:380
str_rdump_io     = $0E5A =  3674  _DATA   DEBUG.asm:370
str_rdump_isr    = $0E35 =  3637  _DATA   DEBUG.asm:362
str_rdump_ix     = $0EB4 =  3764  _DATA   DEBUG.asm:394
str_rdump_iy     = $0EBD =  3773  _DATA   DEBUG.asm:396
str_rdump_pc     = $0E21 =  3617  _DATA   DEBUG.asm:358
str_rdump_sp     = $0E2A =  3626  _DATA   DEBUG.asm:360
str_slot_1       = $0F40 =  3904  _DATA   KMSX.asm:694
str_slots        = $0F5C =  3932  _DATA   KMSX.asm:702
str_splash       = $0EF2 =  3826  _DATA   KRISYS.asm:251
str_vm_start     = $0F83 =  3971  _DATA   KMSX.asm:710
str_zmm_init     = $0DA4 =  3492  _DATA   ZMM.asm:358
tohex            = $09FB =  2555  _TEXT   KRISYS.asm:226
trap_a_value     = $6FFF = 28671  _TEXT   KRISYS.asm:94
trap_continue    = $0735 =  1845  _TEXT   TRAP.asm:476
trap_entry       = $054C =  1356  _TEXT   TRAP.asm:19
trap_f_value     = $6FFE = 28670  _TEXT   KRISYS.asm:95
trap_init        = $0742 =  1858  _TEXT   TRAP.asm:508
trap_io          = $055D =  1373  _TEXT   TRAP.asm:39 (unused)
trap_io_ex_out   = $05EF =  1519  _TEXT   TRAP.asm:166
trap_io_ext      = $0579 =  1401  _TEXT   TRAP.asm:59
trap_io_ind      = $0686 =  1670  _TEXT   TRAP.asm:305
trap_io_inx      = $0649 =  1609  _TEXT   TRAP.asm:246
trap_io_outd     = $06FC =  1788  _TEXT   TRAP.asm:421
trap_io_outx     = $06BF =  1727  _TEXT   TRAP.asm:360
trap_res_flag    = $0736 =  1846  _TEXT   TRAP.asm:485
trap_restore     = $0736 =  1846  _TEXT   TRAP.asm:482
trap_sp_value    = $13FC =  5116  _BSS    TRAP.asm:526
vdp_in           = $0C5F =  3167  _TEXT   KMSX.asm:438
zmm_addr_hi      = $0032 =    50  _TEXT   KRISYS.asm:68 (unused)
zmm_addr_lo      = $0033 =    51  _TEXT   KRISYS.asm:69
zmm_bnk0         = $0030 =    48  _TEXT   KRISYS.asm:62
zmm_bnk0_set     = $02E9 =   745  _TEXT   ZMM.asm:243
zmm_bnk0_state   = $133A =  4922  _BSS    ZMM.asm:376
zmm_bnk0_we      = $0309 =   777  _TEXT   ZMM.asm:292 (unused)
zmm_bnk0_wp      = $0301 =   769  _TEXT   ZMM.asm:283 (unused)
zmm_bnk1         = $0031 =    49  _TEXT   KRISYS.asm:63
zmm_bnk1_set     = $02EF =   751  _TEXT   ZMM.asm:253
zmm_bnk1_state   = $133B =  4923  _BSS    ZMM.asm:380
zmm_bnk1_we      = $0319 =   793  _TEXT   ZMM.asm:310 (unused)
zmm_bnk1_wp      = $0311 =   785  _TEXT   ZMM.asm:301 (unused)
zmm_bnk2         = $0032 =    50  _TEXT   KRISYS.asm:64
zmm_bnk2_set     = $02F5 =   757  _TEXT   ZMM.asm:263
zmm_bnk2_state   = $133C =  4924  _BSS    ZMM.asm:384
zmm_bnk2_we      = $0329 =   809  _TEXT   ZMM.asm:328 (unused)
zmm_bnk2_wp      = $0321 =   801  _TEXT   ZMM.asm:319 (unused)
zmm_bnk3         = $0033 =    51  _TEXT   KRISYS.asm:65
zmm_bnk3_set     = $02FB =   763  _TEXT   ZMM.asm:273
zmm_bnk3_state   = $133D =  4925  _BSS    ZMM.asm:388
zmm_bnk3_we      = $0339 =   825  _TEXT   ZMM.asm:346 (unused)
zmm_bnk3_wp      = $0331 =   817  _TEXT   ZMM.asm:337 (unused)
zmm_capt_res     = $007F =   127  _TEXT   KRISYS.asm:77
zmm_capt_set     = $0070 =   112  _TEXT   KRISYS.asm:76
zmm_capture      = $7000 = 28672  _TEXT   KRISYS.asm:72
zmm_ctrl         = $0034 =    52  _TEXT   KRISYS.asm:66
zmm_ctrl_set     = $028B =   651  _TEXT   ZMM.asm:145
zmm_ctrl_state   = $1339 =  4921  _BSS    ZMM.asm:372
zmm_init         = $01FC =   508  _TEXT   ZMM.asm:22
zmm_irq_inter    = $02BD =   701  _TEXT   ZMM.asm:198
zmm_irq_normal   = $02C8 =   712  _TEXT   ZMM.asm:209 (unused)
zmm_irq_off      = $02DE =   734  _TEXT   ZMM.asm:231
zmm_irq_on       = $02D3 =   723  _TEXT   ZMM.asm:220
zmm_isr          = $0030 =    48  _TEXT   KRISYS.asm:67
zmm_map          = $8000 = 32768  _TEXT   KRISYS.asm:73
zmm_nmi          = $0219 =   537  _TEXT   ZMM.asm:43 (unused)
zmm_prgm_in      = $02A7 =   679  _TEXT   ZMM.asm:176
zmm_prgm_out     = $02B2 =   690  _TEXT   ZMM.asm:187
zmm_set_real     = $029C =   668  _TEXT   ZMM.asm:165
zmm_set_virt     = $0291 =   657  _TEXT   ZMM.asm:154
zmm_top          = $C000 = 49152  _TEXT   KRISYS.asm:74
zmm_trap         = $0037 =    55  _TEXT   KRISYS.asm:70
zmm_vm_start     = $0254 =   596  _TEXT   ZMM.asm:94
zmm_work         = $1337 =  4919  _BSS    ZMM.asm:368


total time: 0.0263 sec.
no errors
