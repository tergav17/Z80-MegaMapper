              	; --------------------------------------
              	; zasm: assemble "KCOLECO.asm"
              	; date: 2024-08-18 22:44:12
              	; --------------------------------------


              	;
              	;********************************************************************
              	;*
              	;*        K R I S Y S   C O L E C O V I S I O N   C O R E
              	;*
              	;********************************************************************
              	
              	#include "KRISYS.asm"
              	;
              	;********************************************************************
              	;*
              	;*              I D E N T I T Y   K R I S Y S
              	;*
              	;*      The [K]lunkly [R]emapper / [I]nterpreter [SYS]tem
              	;*
              	;*             Written by Gavin Tersteeg, 2024
              	;*              Copyleft, All Wrongs Reserved
              	;*
              	;*
              	;*   This piece of software allows different classic Z80 systems
              	;*   to run as "virtual machines" on top of existing hardware by
              	;*   use of a ZMM (Z80 MEGAMAPPER). It does this by remapping RAM
              	;*   and I/O address space ot match that of it's target system.
              	;*   Anything that can't be emulated by simple remapping is instead
              	;*   interpreted using I/O traps. 
              	;*
              	;*   This allows virtualized machines to run with an acceptable
              	;*   degree of speed and accuracy. While the ZMM is still quite
              	;*   limited in what sort of hardware can be efficiently virtualized,
              	;*   anything that avoids MMIO or graphics hardware that isn't a VDP
              	;*   generally can be made to work.
              	;* 
              	;********************************************************************
              		
              	; ----------------------------
              	; ******** ZASM Setup ********
              	; ----------------------------
              	
0020:         	stack_size = 0x20
              	
              	#target BIN
0100:         	#code	_TEXT,0x0100	; Setup to run as a CP/M executable
0790:         	#code	_DATA,_TEXT_end
0A7C:         	#data	_BSS,_DATA_end
              	
              	; Make sure w don't overrun available memory
              	#assert	_BSS_end < (zmm_capture-stack_size)
              	
              	.area	_TEXT
0100: C33407  		jp	kri_start
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
              	; CP/M Stuff
0005:         	bdos		equ	0x0005
0000:         	bdos_exit	equ	0x00
0001:         	bdos_con_in	equ	0x01
0002:         	bdos_con_out	equ	0x02
0009:         	bdos_print	equ	0x09
000F:         	bdos_open	equ	0x0F
0014:         	bdos_read	equ	0x14
001A:         	bios_set_dma	equ	0x1A
              	
0080:         	cpm_command	equ	0x0080
              	
              	; Z80 MEGAMAPPER Stuff
0030:         	zmm_bnk0	equ	0x30	; 16K Bank 0 (0x0000 - 0x3FFF)
0031:         	zmm_bnk1	equ	0x31	; 16K Bank 1 (0x4000 - 0x7FFF)
0032:         	zmm_bnk2	equ	0x32	; 16K Bank 2 (0x8000 - 0xBFFF)
0033:         	zmm_bnk3	equ	0x33	; 16K Bank 3 (0xC000 - 0xFFFF)
0034:         	zmm_ctrl	equ	0x34	; ZMM Control Register
0030:         	zmm_isr		equ	0x30	; ZMM Trapped Instruction Register
0032:         	zmm_addr_hi	equ	0x32	; ZMM Trap Address High
0033:         	zmm_addr_lo	equ	0x33	; ZMM Trap Address Low
0037:         	zmm_trap	equ	0x37 	; ZMM Trap Vector
              	
7000:         	zmm_capture	equ	0x7000
8000:         	zmm_map		equ	0x8000
C000:         	zmm_top		equ	0xC000
              	
0070:         	zmm_capt_set	equ	0b01110000
007F:         	zmm_capt_res	equ	0b01111111
              	
              	; General Z80 Stuff
0066:         	nmi_address	equ	0x0066
0067:         	nmi_vector	equ	nmi_address+1
              	
              	; NABU Specific Stuff
0000:         	nabu_nctl	equ	0x00	; NABU Control Register
0040:         	nabu_ay_data	equ	0x40	; AY-3-8910 Data Port
0041:         	nabu_ay_latch	equ	0x41	; AY-3-8910 Latch Port
00A0:         	nabu_vdp_data	equ	0xA0	; VDP Data Port
00A1:         	nabu_vdp_addr	equ	0xA1	; VDP Address Port
              	
              	; Stack / Trap Management
7000:         	kri_stack	equ	zmm_capture
6FFF:         	trap_a_value	equ	kri_stack-1
6FFE:         	trap_f_value	equ	kri_stack-2
              	
              	; -------------------------------------
              	; ******** Additional Includes ********
              	; -------------------------------------
              	
              	#include "MEMORY.asm"
              	;
              	;********************************************************************
              	;*
              	;*                    Z M M   M E M O R Y
              	;* 
              	;*    The ZMM can be configured to have different amounts
              	;*    of memory installed. Instead of dicking around with 
              	;*    on-board jumpers, KRISYS will simply check what banks
              	;*    are available on startup. Memory will be dynamically
              	;*    allocated as needed by the client process.
              	;*
              	;*    Memory can be assigned to specific owners in the code.
              	;*    Valid owner IDs range from 1 to 254. Owner 0 is reserved
              	;*    for unallocatable banks.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              		
              	; Initalize the memory map
              	; Each bank of the ZMM will be probed, and writable
              	; banks will be recorded on the allocated bank map
              	;
              	; Returns nothing
              	; Uses: AF, BC, DE, HL
0103:         	mem_map_init:
              		; Go to virtual mode
0103: CD0502  		call	zmm_set_virt
              		
              		; Reset free bank counter
0106: 3E00    		ld	a,0
0108: 327C0A  		ld	(banks_free),a
              		
              		; Write tags to all banks
010B: 0600    		ld	b,0
010D: 78      	0$:	ld	a,b
010E: CD6F02  		call	zmm_bnk3_set
0111: 3200C0  		ld	(zmm_top),a
0114: ED44    		neg
0116: 3201C0  		ld	(zmm_top+1),a
0119: 04      		inc	b
011A: F20D01  		jp	p,0$
              		
              		; Mark any banks that record correctly
011D: 0600    		ld	b,0
011F: 217D0A  		ld	hl,alloc_bank_map
0122: AF      	1$:	xor	a
0123: 77      		ld	(hl),a
0124: 78      		ld	a,b
0125: CD6F02  		call	zmm_bnk3_set
0128: 3A00C0  		ld	a,(zmm_top)
012B: B8      		cp	b
012C: C24401  		jp	nz,2$
012F: 3A01C0  		ld	a,(zmm_top+1)
0132: 4F      		ld	c,a
0133: 78      		ld	a,b
0134: ED44    		neg
0136: B9      		cp	c
0137: C24401  		jp	nz,2$
              	
              		; Mark it
013A: 3EFF    		ld	a,0xFF
013C: 77      		ld	(hl),a
013D: 3A7C0A  		ld	a,(banks_free)
0140: 3C      		inc	a
0141: 327C0A  		ld	(banks_free),a
              		
              		; Next
0144: 23      	2$:	inc	hl
0145: 04      		inc	b
0146: F22201  		jp	p,1$
              		
              		; Disable virtual mode
0149: CD1002  		call	zmm_set_real
              		
              		; Print out result
014C: 3A7C0A  		ld	a,(banks_free)
014F: CD7107  		call	tohex
0152: ED53B507		ld	(str_mem_init_cnt),de
0156: 119007  		ld	de,str_mem_init
0159: CD5607  		call	cpm_print
              		
              		; Do we actually have an acceptable amount of memory?
015C: 3A7C0A  		ld	a,(banks_free)
015F: 3D      		dec	a
0160: 3D      		dec	a
0161: FAA301  		jp	m,mem_empty
              		
              		; We do, return
0164: C9      		ret
              		
              	; Allocates a bank of memory
              	; Will produce an error if no banks are available,
              	; check (banks_free) to avoid
              	; D = Owner ID (1-254)
              	;
              	; Returns A = Bank #
              	; Uses: AF, BC, HL
0165:         	mem_alloc:
              		; Check and decrement free memory
0165: 3A7C0A  		ld	a,(banks_free)
0168: 3D      		dec	a
0169: 327C0A  		ld	(banks_free),a
016C: FAA301  		jp	m,mem_empty
              		
              		; Look for the first free bank
016F: 217D0A  		ld	hl,alloc_bank_map
0172: 018000  		ld	bc,0x0080
0175: 3EFF    		ld	a,0xFF
0177: EDB1    		cpir
              		
              		; Make sure we found something
0179: C2A301  		jp	nz,mem_empty
              		
              		; Save and exit
017C: 2B      		dec	hl
017D: 72      		ld	(hl),d
017E: 017D0A  		ld	bc,alloc_bank_map
0181: B7      		or	a
0182: ED42    		sbc	hl,bc
0184: 7D      		ld	a,l
0185: C9      		ret
              		
              	; Frees a bank of memory
              	; Safe to use on banks that are not free / not owned
              	; A = Bank #
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
0186:         	mem_free:
              		; Find location in memory
0186: 0600    		ld	b,0
0188: 4F      		ld	c,a
0189: 217D0A  		ld	hl,alloc_bank_map
018C: 09      		add	hl,bc
              		
              		; Check owner
018D: 7E      		ld	a,(hl)
018E: BA      		cp	d
018F: C0      		ret	nz
              		
              		; Free bank
0190: 3EFF    		ld	a,0xFF
0192: 77      		ld	(hl),a
              		
              		; Increment banks free
0193: 217C0A  		ld	hl,banks_free
0196: 34      		inc	(hl)
0197: C9      		ret
              		
              	; Free all banks by owner
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
0198:         	mem_free_all:
              		; Free a bank
0198: AF      		xor	a
0199: F5      	0$:	push	af
019A: CD8601  		call	mem_free
019D: F1      		pop	af
              		
              		; Next bank
019E: 3C      		inc	a
019F: F29901  		jp	p,0$
01A2: C9      		ret
              		
              	; Error out if empty
              	;
              	; Does not return
              	; Uses: N/A
01A3:         	mem_empty:
01A3: 11BB07  		ld	de,str_mem_empty
01A6: CD5607  		call	cpm_print
01A9: C36907  		jp	cpm_exit
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0790:         	str_mem_init:
0790: 494E4954		defb	'INITIALIZED MEMORY MAP',0x0A,0x0D
0794: 49414C49	
0798: 5A454420	
079C: 4D454D4F	
07A0: 5259204D	
07A4: 41500A0D	
07A8: 42414E4B		defb	'BANK COUNT = '
07AC: 20434F55	
07B0: 4E54203D	
07B4: 20      	
07B5:         	str_mem_init_cnt:
07B5: 5858480A		defb	'XXH',0x0A,0x0D,'$'
07B9: 0D24    	
              		
07BB:         	str_mem_empty:
07BB: 494E5355		defb	'INSUFFICIENT MEMORY',0x0A,0x0D,'$'
07BF: 46464943	
07C3: 49454E54	
07C7: 204D454D	
07CB: 4F52590A	
07CF: 0D24    	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Free bank count
0A7C:         	banks_free:
0A7C: 00      		defs	1
              	
              	; Allocated bank map
              	; This 128 byte table keeps track of every single 16K bank
              	; that exists on the ZMM. Populated on startup
0A7D:         	alloc_bank_map:
0A7D: 00000000		defs	128
0A81: 00...   	
              	#include "ZMM.asm"
              	;
              	;********************************************************************
              	;*
              	;*                  Z M M   M A N A G E M E N T
              	;* 
              	;*    These routines are used to manage the state of the ZMM.
              	;*    This includes the setting of the registers as well as setting
              	;*    up trap and interrupt stuff.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize ZMM and reset registers
              	;
              	; Returns nothing
              	; Uses: AF
01AC:         	zmm_init:
              		; Zero out control register
01AC: 3E00    		ld	a,0
01AE: 32FD0A  		ld	(zmm_ctrl_state),a
01B1: 32FE0A  		ld	(zmm_bnk0_state),a
01B4: 32FF0A  		ld	(zmm_bnk1_state),a
01B7: 32000B  		ld	(zmm_bnk2_state),a
01BA: 32010B  		ld	(zmm_bnk3_state),a
              		
              		; See if we can swing in and out of virtual mode
01BD: CD0502  		call	zmm_set_virt
01C0: CD1002  		call	zmm_set_real
              		
              		; Tell the user that the ZMM is read
01C3: 11D107  		ld	de,str_zmm_init
01C6: C35607  		jp	cpm_print
              		
              	; Start execution of the virtual machine at a specific location
              	; HL = Address to start execution at
              	; 
              	; Does not return
              	; Uses: All registers zeroed
01C9:         	zmm_vm_start:
01C9: 31FEFF  		ld	sp,0xFFFF-1
              		
              		; Completely empty out capture zone
01CC: E5      		push	hl
01CD: 210070  		ld	hl,zmm_capture
01D0: 110170  		ld	de,zmm_capture+1
01D3: 01FF0F  		ld	bc,0x1000-1
01D6: AF      		xor	a
01D7: 77      		ld	(hl),a
01D8: EDB0    		ldir
01DA: E1      		pop	hl
              		
01DB: 7C      		ld	a,h
01DC: 32FE7F  		ld	((zmm_capture + 0x1000) - 2),a
01DF: 7D      		ld	a,l
01E0: 32FF7F  		ld	((zmm_capture + 0x1000) - 1),a
              		
              		; Reset I/O trap flag just in case
01E3: D337    		out	(zmm_trap),a
              		
              		; Zero everything
01E5: AF      		xor	a
01E6: 47      		ld	b,a
01E7: 4F      		ld	c,a
01E8: 57      		ld 	d,a
01E9: 5F      		ld	e,a
01EA: 67      		ld	h,a
01EB: 6F      		ld	l,a
01EC: D9      		exx
01ED: 08      		ex	af,af'
01EE: AF      		xor	a
01EF: 47      		ld	b,a
01F0: 4F      		ld	c,a
01F1: 57      		ld 	d,a
01F2: 5F      		ld	e,a
01F3: 67      		ld	h,a
01F4: 6F      		ld	l,a
              		
01F5: DD210000		ld	ix,0
01F9: FD210000		ld	iy,0
              		
              		; Enter virtual machine
01FD: ED45    		retn
              		
              	; Set the ZMM control register to the recorded state
              	; (zmm_ctrl_state) = New value of ZMM control register
              	;
              	; Returns nothing
              	; Uses: AF
01FF:         	zmm_ctrl_set:
01FF: 3AFD0A  		ld	a,(zmm_ctrl_state)
0202: D334    		out	(zmm_ctrl),a
0204: C9      		ret
              		
              	; Go to virtual mode
              	;
              	; Returns nothing
              	; Uses: AF
0205:         	zmm_set_virt:
0205: 3AFD0A  		ld	a,(zmm_ctrl_state)
0208: F601    		or	0b00000001
020A: 32FD0A  		ld	(zmm_ctrl_state),a
020D: D334    		out	(zmm_ctrl),a
020F: C9      		ret
              		
              	; Go to real mode
              	;
              	; Returns nothing
              	; Uses: AF
0210:         	zmm_set_real:
0210: 3AFD0A  		ld	a,(zmm_ctrl_state)
0213: E6FE    		and	0b11111110
0215: 32FD0A  		ld	(zmm_ctrl_state),a
0218: D334    		out	(zmm_ctrl),a
021A: C9      		ret
              		
              	; Set program direction to "IN"
              	;
              	; Returns nothing
              	; Uses: AF
021B:         	zmm_prgm_in:
021B: 3AFD0A  		ld	a,(zmm_ctrl_state)
021E: F602    		or	0b00000010
0220: 32FD0A  		ld	(zmm_ctrl_state),a
0223: D334    		out	(zmm_ctrl),a
0225: C9      		ret
              		
              	; Set program direction to "OUT"
              	;
              	; Returns nothing
              	; Uses: AF
0226:         	zmm_prgm_out:
0226: 3AFD0A  		ld	a,(zmm_ctrl_state)
0229: E6FD    		and	0b11111101
022B: 32FD0A  		ld	(zmm_ctrl_state),a
022E: D334    		out	(zmm_ctrl),a
0230: C9      		ret
              		
              	; Turn on irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
0231:         	zmm_irq_inter:
0231: 3AFD0A  		ld	a,(zmm_ctrl_state)
0234: F604    		or	0b00000100
0236: 32FD0A  		ld	(zmm_ctrl_state),a
0239: D334    		out	(zmm_ctrl),a
023B: C9      		ret
              		
              	; Turn off irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
023C:         	zmm_irq_normal:
023C: 3AFD0A  		ld	a,(zmm_ctrl_state)
023F: E6FB    		and	0b11111011
0241: 32FD0A  		ld	(zmm_ctrl_state),a
0244: D334    		out	(zmm_ctrl),a
0246: C9      		ret
              	
              	; Turn on force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
0247:         	zmm_irq_on:
0247: 3AFD0A  		ld	a,(zmm_ctrl_state)
024A: F608    		or	0b00001000
024C: 32FD0A  		ld	(zmm_ctrl_state),a
024F: D334    		out	(zmm_ctrl),a
0251: C9      		ret
              		
              	; Turn off force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
0252:         	zmm_irq_off:
0252: 3AFD0A  		ld	a,(zmm_ctrl_state)
0255: E6F7    		and	0b11110111
0257: 32FD0A  		ld	(zmm_ctrl_state),a
025A: D334    		out	(zmm_ctrl),a
025C: C9      		ret
              		
              	; Set bank 0
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses: AF, B
025D:         	zmm_bnk0_set:
025D: 32FE0A  		ld	(zmm_bnk0_state),a
0260: D330    		out	(zmm_bnk0),a
0262: C9      		ret
              		
              	; Set bank 1
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
0263:         	zmm_bnk1_set:
0263: 32FF0A  		ld	(zmm_bnk1_state),a
0266: D331    		out	(zmm_bnk1),a
0268: C9      		ret
              		
              	; Set bank 2
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
0269:         	zmm_bnk2_set:
0269: 32000B  		ld	(zmm_bnk2_state),a
026C: D332    		out	(zmm_bnk2),a
026E: C9      		ret
              		
              	; Set bank 3
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
026F:         	zmm_bnk3_set:
026F: 32010B  		ld	(zmm_bnk3_state),a
0272: D333    		out	(zmm_bnk3),a
0274: C9      		ret
              		
              		
              	; Write protect bank 0
              	;
              	; Returns nothing
              	; Uses: AF
0275:         	zmm_bnk0_wp:
0275: 3AFE0A  		ld	a,(zmm_bnk0_state)
0278: F680    		or	0b10000000
027A: C35D02  		jp 	zmm_bnk0_set
              		
              	; Write enable bank 0
              	;
              	; Returns nothing
              	; Uses: AF
027D:         	zmm_bnk0_we:
027D: 3AFE0A  		ld	a,(zmm_bnk0_state)
0280: E67F    		and	~0b10000000
0282: C35D02  		jp 	zmm_bnk0_set
              		
              	; Write protect bank 1
              	;
              	; Returns nothing
              	; Uses: AF
0285:         	zmm_bnk1_wp:
0285: 3AFF0A  		ld	a,(zmm_bnk1_state)
0288: F680    		or	0b10000000
028A: C36302  		jp 	zmm_bnk1_set
              		
              	; Write enable bank 1
              	;
              	; Returns nothing
              	; Uses: AF
028D:         	zmm_bnk1_we:
028D: 3AFF0A  		ld	a,(zmm_bnk1_state)
0290: E67F    		and	~0b10000000
0292: C36302  		jp 	zmm_bnk1_set
              		
              	; Write protect bank 2
              	;
              	; Returns nothing
              	; Uses: AF
0295:         	zmm_bnk2_wp:
0295: 3A000B  		ld	a,(zmm_bnk2_state)
0298: F680    		or	0b10000000
029A: C36902  		jp 	zmm_bnk2_set
              		
              	; Write enable bank 2
              	;
              	; Returns nothing
              	; Uses: AF
029D:         	zmm_bnk2_we:
029D: 3A000B  		ld	a,(zmm_bnk2_state)
02A0: E67F    		and	~0b10000000
02A2: C36902  		jp 	zmm_bnk2_set
              		
              	; Write protect bank 3
              	;
              	; Returns nothing
              	; Uses: AF
02A5:         	zmm_bnk3_wp:
02A5: 3A010B  		ld	a,(zmm_bnk3_state)
02A8: F680    		or	0b10000000
02AA: C36F02  		jp 	zmm_bnk3_set
              		
              	; Write enable bank 3
              	;
              	; Returns nothing
              	; Uses: AF
02AD:         	zmm_bnk3_we:
02AD: 3A010B  		ld	a,(zmm_bnk3_state)
02B0: E67F    		and	~0b10000000
02B2: C36F02  		jp 	zmm_bnk3_set
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
07D1:         	str_zmm_init:
07D1: 494E4954		defb	'INITIALIZED ZMM',0x0A,0x0D,'$'
07D5: 49414C49	
07D9: 5A454420	
07DD: 5A4D4D0A	
07E1: 0D24    	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
0AFD:         	zmm_ctrl_state:
0AFD: 00      		defs	1
              		
              	; Bank 0 state
0AFE:         	zmm_bnk0_state:
0AFE: 00      		defs	1
              		
              	; Bank 1 state
0AFF:         	zmm_bnk1_state:
0AFF: 00      		defs	1
              		
              	; Bank 2 state
0B00:         	zmm_bnk2_state:
0B00: 00      		defs	1
              		
              	; Bank 3 state
0B01:         	zmm_bnk3_state:
0B01: 00      		defs	1
              		
              	#include "RESOURCE.asm"
              	;
              	;********************************************************************
              	;*
              	;*               R E S O U R C E   M A N A G E M E N T
              	;* 
              	;*    These routines handle obtaining use-supplied resources
              	;*    such as configurations, ROM images, and storage bindings.
              	;*    During startup, these resources will be loaded to build
              	;*    the virtual machine.
              	;*
              	;********************************************************************
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
0010:         	arg_size	equ 16
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize resources
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
02B5:         	res_init:
              		; Start by zero-terminating string
02B5: 218000  		ld	hl,cpm_command
02B8: 4E      		ld	c,(hl)
02B9: 0600    		ld	b,0
02BB: 09      		add	hl,bc
02BC: 23      		inc	hl
02BD: 70      		ld	(hl),b
              		
02BE: C9      		ret
              		
              	; Loads an open resource into a bankmap
              	; Bankmap will be zero-padded to fill requested number of records
              	; HL = Address of bankmap
              	; BC = Number of records (128 byte blocks) to load
              	;
              	; Returns nothing
              	; Uses: all
02BF:         	res_load:
              		; Set read flag
02BF: 3EFF    		ld	a,0xFF
02C1: 32970B  		ld	(res_do_read),a
              	
              		; Save args
02C4: 22980B  		ld	(res_bankmap),hl
02C7: ED43950B		ld	(res_sectors),bc
              	
              		; Virtual mode should be off while we do this
02CB: 3AFD0A  		ld	a,(zmm_ctrl_state)
02CE: F5      		push	af
02CF: CD1002  		call	zmm_set_real
              		
              		; Do function call
02D2: CDE102  		call	0$
              		
              		; Reset bank 3
02D5: 3A010B  		ld	a,(zmm_bnk3_state)
02D8: D333    		out	(zmm_bnk3),a
              		
              		; Restore register
02DA: F1      		pop	af
02DB: 32FD0A  		ld	(zmm_ctrl_state),a
02DE: C3FF01  		jp	zmm_ctrl_set
              		
              		; Allocate a new bank
02E1: 1601    	0$:	ld	d,1
02E3: CD6501  		call	mem_alloc
02E6: 2A980B  		ld	hl,(res_bankmap)
02E9: 77      		ld	(hl),a
02EA: 23      		inc	hl
02EB: 22980B  		ld	(res_bankmap),hl
              		
              		; Set the bank in slot 3
02EE: D333    		out	(zmm_bnk3),a
              		
              		; Set DMA address
02F0: 11150B  		ld	de,res_buffer
02F3: 0E1A    		ld	c,bios_set_dma
02F5: CD0500  		call	bdos
              		
              		; Set pointer	
02F8: 2100C0  		ld	hl,zmm_top
02FB: 229A0B  		ld	(res_pointer),hl
              		
              		; We will be loading up to 128 records at a time here
02FE: 0680    		ld	b,128
              		
              		; Do read operation
0300: C5      	1$:	push	bc
0301: 119C0B  		ld	de,res_fcb
0304: 0E14    		ld	c,bdos_read
0306: 3A970B  		ld	a,(res_do_read)
0309: B7      		or	a
030A: C40500  		call	nz,bdos
              		
              		; Check file I/O result
030D: B7      		or	a
030E: C43703  		call	nz,50$
              		
              		; Go to virtual mode
0311: CD0502  		call	zmm_set_virt
              		
              		; Copy record to bank
0314: 21150B  		ld	hl,res_buffer
0317: ED5B9A0B		ld	de,(res_pointer)
031B: 018000  		ld	bc,128
031E: EDB0    		ldir
0320: ED539A0B		ld	(res_pointer),de
              		
              		; Back to real mode
0324: CD1002  		call	zmm_set_real 
              		
              		; Get BC back to restore sector counter
0327: C1      		pop	bc
              		
              		; Decrement record count
0328: 2A950B  		ld	hl,(res_sectors)
032B: 2B      		dec	hl
032C: 22950B  		ld	(res_sectors),hl
032F: 7C      		ld	a,h
0330: B5      		or	l
0331: C8      		ret	z
              		
              		; Go get another sector
0332: 10CC    		djnz	1$
0334: C3E102  		jp	0$
              	
              		; Zero buffer and reset read flag
0337: AF      	50$:	xor	a
0338: 32970B  		ld	(res_do_read),a
              		
033B: 21150B  		ld	hl,res_buffer
033E: 11160B  		ld	de,res_buffer+1
0341: 017F00  		ld	bc,128-1
0344: 77      		ld	(hl),a
0345: EDB0    		ldir
              	
0347: C9      		ret
              		
              	; Throws an error a missing resource
              	; Resource name will be last attempted to locate
              	;
              	; Does not return
              	; Uses: N/A
0348:         	res_missing:
0348: CD1002  		call	zmm_set_real
              		
              		; Print error message
034B: 0E09    		ld	c,bdos_print
034D: 112008  		ld	de,str_missing
0350: CD0500  		call	bdos
              		
              		; Print resource name
0353: ED5B130B		ld	de,(res_current)
0357: CD4804  		call	res_printzt
              		
              		; CRLF
035A: 0E09    		ld	c,bdos_print
035C: 117908  		ld	de,str_crlf
035F: CD0500  		call	bdos
              		
              		; Exit
0362: C36907  		jp	cpm_exit
              		
              	; Opens a file based on the resource argument
              	; If the file cannot be opened, an error will be thrown
              	; (res_argument) = File to open
              	;
              	; Returns nothing
              	; Uses: all
0365:         	res_open:
              		; Virtual mode should be off while we do this
0365: 3AFD0A  		ld	a,(zmm_ctrl_state)
0368: F5      		push	af
0369: CD1002  		call	zmm_set_real
              		
              		; Do function call
036C: CD7603  		call	0$
              		
              		; Restore register
036F: F1      		pop	af
0370: 32FD0A  		ld	(zmm_ctrl_state),a
0373: C3FF01  		jp	zmm_ctrl_set
              		
              		; Let the user know we are loading stuff
0376: 0E09    	0$:	ld	c,bdos_print
0378: 11E307  		ld	de,str_load_a
037B: CD0500  		call	bdos
              		
              		; Print resource name
037E: ED5B130B		ld	de,(res_current)
0382: CD4804  		call	res_printzt
              		
              		; Next string
0385: 0E09    		ld	c,bdos_print
0387: 11EC07  		ld	de,str_load_b
038A: CD0500  		call	bdos
              		
              		; Print file name
038D: 11020B  		ld	de,res_argument
0390: CD4804  		call	res_printzt
              		
              		; CRLF
0393: 0E09    		ld	c,bdos_print
0395: 117908  		ld	de,str_crlf
0398: CD0500  		call	bdos
              		
              		; Detect if there is an argument
039B: 3A020B  		ld	a,(res_argument)
039E: B7      		or	a
039F: C2AD03  		jp	nz,1$
              		
              		; No argument, error!
03A2: 0E09    		ld	c,bdos_print
03A4: 11F307  		ld	de,str_arg_empty
03A7: CD0500  		call	bdos
03AA: C36907  		jp	cpm_exit
              	
              		; Reset fields
03AD: AF      	1$:	xor	a
03AE: 219C0B  		ld	hl,res_fcb
03B1: 119D0B  		ld	de,res_fcb+1
03B4: 012300  		ld	bc ,36-1
03B7: 77      		ld	(hl),a
03B8: EDB0    		ldir
              		
03BA: 3E20    		ld	a,0x20
03BC: 219D0B  		ld	hl,res_fcb_name
03BF: 119E0B  		ld	de,res_fcb_name+1
03C2: 010A00  		ld	bc ,11-1
03C5: 77      		ld	(hl),a
03C6: EDB0    		ldir
              	
              		; Is there a prefix?
03C8: 21020B  		ld	hl,res_argument
03CB: 3A030B  		ld	a,(res_argument+1)
03CE: FE3A    		cp	':'
03D0: C2E203  		jp	nz,2$
              		
              		; Set prefix
03D3: 3A020B  		ld	a,(res_argument)
03D6: D640    		sub	'A'-1
03D8: FE11    		cp	17
03DA: D23D04  		jp	nc,99$
03DD: 329C0B  		ld	(res_fcb_drive),a
03E0: 23      		inc	hl
03E1: 23      		inc	hl
              	
              		; HL = Proper filename start
03E2: 0608    	2$:	ld	b,8
03E4: 119D0B  		ld	de,res_fcb_name
              		
              		; Copy it over
03E7: 7E      	3$:	ld	a,(hl)
03E8: B7      		or	a
03E9: CA3D04  		jp	z,99$
03EC: FE2A    		cp	'*'
03EE: CAFE03  		jp	z,4$
03F1: FE2E    		cp	'.'
03F3: CA0504  		jp	z,5$
03F6: 12      		ld	(de),a
03F7: 13      		inc	de
03F8: 23      		inc	hl
03F9: 10EC    		djnz	3$
03FB: C30504  		jp	5$
              	
              		; Fill remains of FCB file name
03FE: 3E3F    	4$:	ld	a,'?'
0400: 12      		ld	(de),a
0401: 13      		inc	de
0402: 10FA    		djnz	4$
0404: 23      		inc	hl
              	
              		; We should either see a '.' or a null character
0405: 7E      	5$:	ld	a,(hl)
0406: B7      		or	a
0407: CA2E04  		jp	z,8$
040A: FE2E    		cp	'.'
040C: C23D04  		jp	nz,99$
040F: 23      		inc	hl
              		
              		; Fill in extension
0410: 0603    		ld	b,3
0412: 11A50B  		ld	de,res_fcb_type
              		
              		; Copy it over
0415: 7E      	6$:	ld	a,(hl)
0416: B7      		or	a
0417: CA2E04  		jp	z,8$
041A: FE2A    		cp	'*'
041C: CA2704  		jp	z,7$
041F: 12      		ld	(de),a
0420: 13      		inc	de
0421: 23      		inc	hl
0422: 10F1    		djnz	6$
0424: C32E04  		jp	8$
              		
              		; Fill remains of FCB file extension
0427: 3E3F    	7$:	ld	a,'?'
0429: 12      		ld	(de),a
042A: 13      		inc	de
042B: 10D1    		djnz	4$
042D: 23      		inc	hl
              	
              		; We should get a zero
042E: 7E      	8$:	ld 	a,(hl)
042F: B7      		or	a
0430: C23D04  		jp	nz,99$
              		
              		; It is filled in, attempt to open
0433: 0E0F    		ld	c,bdos_open
0435: 119C0B  		ld	de,res_fcb
0438: CD0500  		call	bdos
              		
              		; Check error
043B: 3C      		inc	a
043C: C0      		ret	nz
              		
              		; Error!
043D: 0E09    	99$:	ld	c,bdos_print
043F: 110A08  		ld	de,str_arg_fail
0442: CD0500  		call	bdos
0445: C36907  		jp	cpm_exit
              		
              		
              	; Print a zero terminated string
              	; We should be in real mode for this
              	; DE = String
              	;
              	; Returns nothing
              	; Uses: All
0448:         	res_printzt:
0448: 1A      	0$:	ld	a,(de)
0449: B7      		or	a
044A: C8      		ret	z
              		
              		; Print character
044B: D5      		push	de
044C: 5F      		ld	e,a
044D: 0E02    		ld	c,bdos_con_out
044F: CD0500  		call	bdos
0452: D1      		pop	de
0453: 13      		inc	de
0454: C34804  		jp	0$
              	
              	; Find a resource from the command line
              	; If the resource is found, the contents will be cached in memory
              	; DE = Name of resource (upper case only) 
              	;
              	; Returns A = 0xFF if no resource is found
              	; Uses: AF, BC, DE, HL
0457:         	res_locate:
              		; Save resource
0457: ED53130B		ld	(res_current),de
              	
              		; Travel to the start of arguments
045B: 218100  		ld	hl,cpm_command+1
045E: 7E      	0$:	ld	a,(hl)
045F: B7      		or	a
0460: CABD04  		jp	z,99$
0463: FE21    		cp	0x21
0465: D26C04  		jp	nc,1$
0468: 23      		inc	hl
0469: C35E04  		jp	0$
              		
              		; Found an argument
              		; Check it against the contents of (DE)
              		; Also must start with '-'
046C: FE2D    	1$:	cp	'-'
046E: C27F04  		jp	nz,3$
0471: 23      		inc	hl
0472: D5      		push	de
0473: 1A      	2$:	ld	a,(de)
              		
              		; Check if at end of string
0474: B7      		or	a
0475: CA8D04  		jp	z,4$
              		
              		; No? Well lets see if (de) = (hl)
0478: BE      		cp	(hl)
0479: 23      		inc	hl
047A: 13      		inc	de
047B: CA7304  		jp	z,2$
              		
              		; Strings are different!
              		; Escape from the current argument and continue
047E: D1      		pop	de
047F: 7E      	3$:	ld	a,(hl)
0480: B7      		or	a
0481: CABD04  		jp	z,99$
0484: FE21    		cp	0x21
0486: DA5E04  		jp	c,0$
0489: 23      		inc	hl
048A: C37F04  		jp	3$
              	
              		; Make sure we are at the end of the argument as well
048D: D1      	4$: 	pop	de
048E: 7E      		ld	a,(hl)
048F: FE21    		cp	0x21
0491: D27F04  		jp	nc,3$
              		
              		; Ok, lets copy the argument into memory if it exists
0494: 11020B  		ld	de,res_argument
0497: AF      		xor	a
0498: 12      		ld	(de),a
              		
              		; Travel to the start of the argument
0499: 7E      	5$:	ld	a,(hl)
049A: B7      		or	a
049B: CABB04  		jp	z,89$
049E: FE21    		cp	0x21
04A0: D2A704  		jp	nc,6$
04A3: 23      		inc	hl
04A4: C39904  		jp	5$
              	
              		; Make sure it doesn't start with '-'
04A7: FE2D    	6$:	cp	'-'
04A9: CABB04  		jp	z,89$
              		
              		; Ok, lets copy up 16 bytes of this
04AC: 0610    		ld	b,arg_size
04AE: 7E      	7$:	ld	a,(hl)
04AF: FE21    		cp	0x21
04B1: DAB904  		jp	c,8$
04B4: 12      		ld	(de),a
04B5: 23      		inc	hl
04B6: 13      		inc	de
04B7: 10F5    		djnz	7$
              	
              		; Zero terminate
04B9: AF      	8$:	xor	a
04BA: 12      		ld	(de),a
              		
              		; Good ending
04BB: AF      	89$:	xor	a
04BC: C9      		ret
              	
              		; Bad ending
04BD: 3EFF    	99$:	ld	a,0xFF
04BF: C9      		ret
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Loading string components
07E3:         	str_load_a:
07E3: 4C4F4144		defb	'LOADING $'
07E7: 494E4720	
07EB: 24      	
              		
07EC:         	str_load_b:
07EC: 2046524F		defb	' FROM $'
07F0: 4D2024  	
              		
              	; Error messages
07F3:         	str_arg_empty:
07F3: 4E4F2041		defb	'NO ARGUMENT PROVIDED',0x0A,0x0D,'$'
07F7: 5247554D	
07FB: 454E5420	
07FF: 50524F56	
0803: 49444544	
0807: 0A0D24  	
              		
080A:         	str_arg_fail:
080A: 4641494C		defb	'FAILED TO OPEN FILE',0x0A,0x0D,'$'
080E: 45442054	
0812: 4F204F50	
0816: 454E2046	
081A: 494C450A	
081E: 0D24    	
              		
0820:         	str_missing:
0820: 4D495353		defb	'MISSING RESOURCE: $'
0824: 494E4720	
0828: 5245534F	
082C: 55524345	
0830: 3A2024  	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Stores a zero-terminated string for the resource argument
0B02:         	res_argument:
0B02: 00000000		defs	arg_size+1
0B06: 00...   	
              		
              	; Current resource being accessed
0B13:         	res_current:
0B13: 0000    		defs	2
              		
              	; Resource buffer
0B15:         	res_buffer:
0B15: 00000000		defs	128
0B19: 00...   	
              		
              	; Sector counter
0B95:         	res_sectors:
0B95: 0000    		defs	2
              		
              	; Do we need to read?
0B97:         	res_do_read:
0B97: 00      		defs	1
              		
              	; Resource bankmap
0B98:         	res_bankmap:
0B98: 0000    		defs	2
              		
              	; Loading pointer
0B9A:         	res_pointer:
0B9A: 0000    		defs	2
              		
              	; File control block for use in loading resources
0B9C:         	res_fcb:
0B9C: 00000000		defs	36
0BA0: 00...   	
0B9C:         	res_fcb_drive	equ	res_fcb
0B9D:         	res_fcb_name	equ	res_fcb+1
0BA5:         	res_fcb_type	equ	res_fcb+9
0BA8:         	res_fcb_ex	equ	res_fcb+12
0BA9:         	res_fcb_s1	equ	res_fcb+13
0BAA:         	res_fcb_s2	equ	res_fcb+14
0BAB:         	res_fcb_rc	equ	res_fcb+15
0BAC:         	res_fcb_data	equ	res_fcb+16
0BBC:         	res_fcb_cr	equ	res_fcb+32
0BBD:         	res_fcb_r0	equ	res_fcb+33
0BBE:         	res_fcb_r1	equ	res_fcb+34
0BBF:         	res_fcb_r2	equ	res_fcb+35
              	#include "TRAP.asm"
              	;
              	;********************************************************************
              	;*
              	;*                     T R A P   H A N D L E R
              	;* 
              	;*    Responsible for handling various traps from the ZMM. Both
              	;*    interrupt and I/O traps will be pre-processed before being
              	;*    sent to the virtualization core for device-specific handling
              	;*
              	;********************************************************************
              	
              	; -------------------------------
              	; ********  Trap Handler ********
              	; -------------------------------
              	
              	.area	_TEXT
              	
              	; Entry point for traps
04C0:         	trap_entry:
              		; Save value of SP
04C0: ED73C00B		ld	(trap_sp_value),sp
04C4: 310070  		ld	sp,kri_stack
              		
              		; Save value of AF
04C7: F5      		push	af
              		
              		; Check in on device interrupts
04C8: CD8B07  		call	irq_handle
              		
              		; Grab the value of the ISR register
04CB: DB30    		in	a,(zmm_isr)
              		
              		; Do we actually need to handle an I/O trap?
04CD: B7      		or	a
04CE: F2B106  		jp	p,trap_continue
              		
              		; Yep, reset trap flag
04D1: D337    		out	(zmm_trap),a
              		
              		; OK, a trap did occur.
              		; Are we doing "classic" I/O or extended I/O?
04D3:         	trap_io:	
04D3: FEE8    		cp	0b11101000
04D5: DAEF04  		jp	c,trap_io_ext
              		
              		; In or out?
04D8: FEEC    		cp	0b11101100
04DA: DAE604  		jp	c,0$
              		
              		; In it is
04DD: CD8C07  		call	in_handle
04E0: 32FF6F  		ld	(trap_a_value),a
04E3: C3B106  		jp	trap_continue
              		
              		; Out it is
04E6: 3AFF6F  	0$:	ld	a,(trap_a_value)
04E9: CD8F07  		call	out_handle
04EC: C3B106  		jp	trap_continue
              	
              	
              	; It's an extended I/O instruction
04EF:         	trap_io_ext:
              	
              		; Input or output?
04EF: 0F      		rrca
04F0: DA6B05  		jp	c,trap_io_ex_out
              		
              		; Extended input instruction
              		; INI-class?
04F3: 0F      		rrca
04F4: DAC505  		jp	c,trap_io_inx
              		
              		; Left or right column
04F7: 0F      		rrca
04F8: DA2205  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
04FB: 0F      		rrca
04FC: DA1105  		jp	c,1$
              		
              		; B or H?
04FF: 0F      		rrca
0500: DA0A05  		jp	c,2$
              		
              		; It's B
0503: CD8C07  		call	in_handle
0506: 47      		ld	b,a
0507: C34C05  		jp	90$
              		
              		; It's H	
050A: CD8C07  	2$:	call	in_handle
050D: 67      		ld	h,a
050E: C34C05  		jp	90$
              	
              		; D or 0?
0511: 0F      	1$:	rrca
0512: DA1C05  		jp	c,3$
              	
              		; It's D
0515: CD8C07  		call	in_handle
0518: 57      		ld	d,a
0519: C34C05  		jp	90$
              		
              		; It's 0
051C: CD8C07  	3$:	call	in_handle
051F: C34C05  		jp	90$
              		
              		
              		; Right column
              		; C, E, L, or A?
0522: 0F      	0$:	rrca
0523: DA3805  		jp	c,4$
              		
              		; C or L?
0526: 0F      		rrca
0527: DA3105  		jp	c,5$
              		
              		; It's C
052A: CD8C07  		call	in_handle
052D: 4F      		ld	c,a
052E: C34C05  		jp	90$
              	
              		; It's L
0531: CD8C07  	5$:	call	in_handle
0534: 6F      		ld	l,a
0535: C34C05  		jp	90$
              		
              		; E or A?
0538: 0F      	4$:	rrca
0539: DA4305  		jp	c,6$
              		
              		; It's E
053C: CD8C07  		call	in_handle
053F: 5F      		ld	e,a
0540: C34C05  		jp	90$
              	
              		; It's A
0543: CD8C07  	6$:	call	in_handle
0546: 32FF6F  		ld	(trap_a_value),a
0549: C34C05  		jp	90$
              		
              		; Extended IN instructions require special flag states
              		; lets set them and return
054C: E5      	90$:	push	hl
054D: 21FE6F  		ld	hl,trap_f_value
0550: CB46    		bit	0,(hl)
0552: E1      		pop	hl
              		
              		; If it's zero, we don't need the carry flag
0553: CA6105  		jp	z,91$ 
              		
              		; Update flags and persist carry flag
0556: B7      		or	a
0557: 37      		scf
0558: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Restore old SP
055B: ED7BC00B		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
055F: ED45    		retn
              		
              		; Update flags and reset carry flag
0561: B7      	91$:	or	a
0562: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Restore old SP
0565: ED7BC00B		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
0569: ED45    		retn
              		
              	; Extended output instruction
056B:         	trap_io_ex_out:
              	
              		; OUTI-class?
056B: 0F      		rrca
056C: DA3B06  		jp	c,trap_io_outx
              		
              		; Left or right column?
056F: 0F      		rrca
0570: DA9B05  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
0573: 0F      		rrca
0574: DA8905  		jp	c,1$
              		
              		; B or H?
0577: 0F      		rrca
0578: DA8205  		jp	c,2$
              		
              		; It's B
057B: 78      		ld	a,b
057C: CD8F07  		call	out_handle
057F: C3B106  		jp	trap_continue
              		
              		; It's H	
0582: 7C      	2$:	ld	a,h
0583: CD8F07  		call	out_handle
0586: C3B106  		jp	trap_continue
              	
              		; D or 0?
0589: 0F      	1$:	rrca
058A: DA9405  		jp	c,3$
              	
              		; It's D
058D: 7A      		ld	a,d
058E: CD8F07  		call	out_handle
0591: C3B106  		jp	trap_continue
              		
              		; It's 0
0594: AF      	3$:	xor	a
0595: CD8F07  		call	out_handle
0598: C3B106  		jp	trap_continue
              		
              		
              		; Right column
              		; C, E, L, or A?
059B: 0F      	0$:	rrca
059C: DAB105  		jp	c,4$
              		
              		; C or L?
059F: 0F      		rrca
05A0: DAAA05  		jp	c,5$
              		
              		; It's C
05A3: 79      		ld	a,c
05A4: CD8F07  		call	out_handle
05A7: C3B106  		jp	trap_continue
              	
              		; It's L
05AA: 7D      	5$:	ld	a,l
05AB: CD8F07  		call	out_handle
05AE: C3B106  		jp	trap_continue
              		
              		; E or A?
05B1: 0F      	4$:	rrca
05B2: DABC05  		jp	c,6$
              		
              		; It's E
05B5: 7B      		ld	a,e
05B6: CD8F07  		call	out_handle
05B9: C3B106  		jp	trap_continue
              	
              		; It's A
05BC: 3AFF6F  	6$:	ld	a,(trap_a_value)
05BF: CD8F07  		call	out_handle
05C2: C3B106  		jp	trap_continue
              	
              	
              		; INX class instructions
              		; The CPU should handle the differences between INX and INXR
05C5:         	trap_io_inx:
              		; Left or right column?
05C5: 0F      		rrca
05C6: DA0206  		jp	c,trap_io_ind
              		
              		; Left column, it's 'I' class
05C9: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
05CA: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
05CB: 7C      		ld	a,h
05CC: 07      		rlca
05CD: DAE005  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
05D0: 07      		rlca
05D1: DADA05  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
05D4: 3AFE0A  		ld	a,(zmm_bnk0_state)
05D7: C3ED05  		jp	3$
              		
              		; 0x4000 - 0x7FFF
05DA: 3AFF0A  	1$:	ld	a,(zmm_bnk1_state)
05DD: C3ED05  		jp	3$
              			
              		; 0x8000 - 0xFFFF
05E0: 07      	0$:	rlca
05E1: DAEA05  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
05E4: 3A000B  		ld	a,(zmm_bnk2_state)
05E7: C3ED05  		jp	3$
              	
              		; 0xC000 - 0xFFFF
05EA: 3A010B  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
05ED: E67F    	3$:	and	0b01111111
05EF: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
05F1: 3EC0    		ld	a,0b11000000
05F3: B4      		or	h
05F4: 67      		ld	h,a
              		
              		; Do the input
05F5: CD8C07  		call	in_handle
05F8: 77      		ld	(hl),a
              		
              		; Fix banks
05F9: 3A010B  		ld	a,(zmm_bnk3_state)
05FC: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
05FE: E1      		pop	hl
05FF: C3B106  		jp	trap_continue
              		
              		; Right column, it's 'D' class
0602:         	trap_io_ind:
0602: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0603: 23      		inc	hl	; Increment to reverse 'D' class instruction
0604: 7C      		ld	a,h
0605: 07      		rlca
0606: DA1906  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0609: 07      		rlca
060A: DA1306  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
060D: 3AFE0A  		ld	a,(zmm_bnk0_state)
0610: C32606  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0613: 3AFF0A  	1$:	ld	a,(zmm_bnk1_state)
0616: C32606  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0619: 07      	0$:	rlca
061A: DA2306  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
061D: 3A000B  		ld	a,(zmm_bnk2_state)
0620: C32606  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0623: 3A010B  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0626: E67F    	3$:	and	0b01111111
0628: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
062A: 3EC0    		ld	a,0b11000000
062C: B4      		or	h
062D: 67      		ld	h,a
              		
              		; Do the input
062E: CD8C07  		call	in_handle
0631: 77      		ld	(hl),a
              		
              		; Fix banks
0632: 3A010B  		ld	a,(zmm_bnk3_state)
0635: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0637: E1      		pop	hl
0638: C3B106  		jp	trap_continue
              	
              		; OUTX-class instructions
              		; The CPU should handle the differences between OUTX and OTXR
063B:         	trap_io_outx:
              	
              		; Left or right column?
063B: 0F      		rrca
063C: DA7806  		jp	c,trap_io_outd
              		
              		; Left column, it's 'I' class
063F: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0640: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
0641: 7C      		ld	a,h
0642: 07      		rlca
0643: DA5606  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0646: 07      		rlca
0647: DA5006  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
064A: 3AFE0A  		ld	a,(zmm_bnk0_state)
064D: C36306  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0650: 3AFF0A  	1$:	ld	a,(zmm_bnk1_state)
0653: C36306  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0656: 07      	0$:	rlca
0657: DA6006  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
065A: 3A000B  		ld	a,(zmm_bnk2_state)
065D: C36306  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0660: 3A010B  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0663: E67F    	3$:	and	0b01111111
0665: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0667: 3EC0    		ld	a,0b11000000
0669: B4      		or	h
066A: 67      		ld	h,a
              		
              		; Do the output
066B: 7E      		ld	a,(hl)
066C: CD8F07  		call	out_handle
              		
              		; Fix banks
066F: 3A010B  		ld	a,(zmm_bnk3_state)
0672: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0674: E1      		pop	hl
              		
0675: C3B106  		jp	trap_continue
              		
              		; Right column, it's 'D' class
0678:         	trap_io_outd:
0678: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0679: 23      		inc	hl	; Increment to reverse 'D' class instruction
067A: 7C      		ld	a,h
067B: 07      		rlca
067C: DA8F06  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
067F: 07      		rlca
0680: DA8906  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0683: 3AFE0A  		ld	a,(zmm_bnk0_state)
0686: C39C06  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0689: 3AFF0A  	1$:	ld	a,(zmm_bnk1_state)
068C: C39C06  		jp	3$
              			
              		; 0x8000 - 0xFFFF
068F: 07      	0$:	rlca
0690: DA9906  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
0693: 3A000B  		ld	a,(zmm_bnk2_state)
0696: C39C06  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0699: 3A010B  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
069C: E67F    	3$:	and	0b01111111
069E: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
06A0: 3EC0    		ld	a,0b11000000
06A2: B4      		or	h
06A3: 67      		ld	h,a
              		
              		; Do the output
06A4: 7E      		ld	a,(hl)
06A5: CD8F07  		call	out_handle
              		
              		; Fix banks
06A8: 3A010B  		ld	a,(zmm_bnk3_state)
06AB: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
06AD: E1      		pop	hl
06AE: C3B106  		jp	trap_continue
              	
              		
              	; Continue execution
06B1:         	trap_continue:
              		; Restore AF
06B1: F1      		pop	af
              		
              		; Restore old SP
06B2: ED7BC00B		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
06B6: ED45    		retn
              		
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize trap handling stuff
              	;
              	; Returns nothing
              	; Uses: AF, HL
06B8:         	trap_init:
              		; Install trap vector
06B8: 3EC3    		ld	a,0xC3
06BA: 326600  		ld	(nmi_address),a
06BD: 21C004  		ld	hl,trap_entry
06C0: 226700  		ld	(nmi_vector),hl
              		
06C3: C9      		ret
              		
              		
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value of untrapped SP value
0BC0:         	trap_sp_value:
0BC0: 0000    		defs	2
              	#include "IRQ.asm"
              	;
              	;********************************************************************
              	;*
              	;*             I N T E R R U P T   M A N A G E M E N T
              	;* 
              	;*    Manages "real" system interrupts on the host hardware.
              	;*    Also deals with mocking interrupts to the virtual machine
              	;*    if it is needed.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize interrupt stuff
              	;
              	; Returns nothing
              	; Uses: AF
06C4:         	irq_init:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06C4: 3E07    		ld	a,7		; AY register = 7
06C6: D341    		out	(nabu_ay_latch),a
06C8: DB40    		in	a,(nabu_ay_data)
06CA: E63F    		and	0x3F
06CC: F640    		or	0x40
06CE: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off all interrupts
06D0: 3E0E    		ld	a,14		; AY register = 14	
06D2: D341    		out	(nabu_ay_latch),a
06D4: AF      		xor	a
06D5: D340    		out	(nabu_ay_data),a
              		
              		; Return
06D7: C9      		ret
              		
              		
              	; Turns on the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
06D8:         	irq_vdp_on:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06D8: 3E07    		ld	a,7		; AY register = 7
06DA: D341    		out	(nabu_ay_latch),a
06DC: DB40    		in	a,(nabu_ay_data)
06DE: E63F    		and	0x3F
06E0: F640    		or	0x40
06E2: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask on interrupt
06E4: 3E0E    		ld	a,14		; AY register = 14	
06E6: D341    		out	(nabu_ay_latch),a
06E8: DB40    		in	a,(nabu_ay_data)
06EA: F610    		or	0b00010000
06EC: D340    		out	(nabu_ay_data),a
              		
06EE: C9      		ret
              		
              	; Turns off the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
06EF:         	irq_vdp_off:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06EF: 3E07    		ld	a,7		; AY register = 7
06F1: D341    		out	(nabu_ay_latch),a
06F3: DB40    		in	a,(nabu_ay_data)
06F5: E63F    		and	0x3F
06F7: F640    		or	0x40
06F9: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
06FB: 3E0E    		ld	a,14		; AY register = 14	
06FD: D341    		out	(nabu_ay_latch),a
06FF: DB40    		in	a,(nabu_ay_data)
0701: E6EF    		and	~0b00010000
0703: D340    		out	(nabu_ay_data),a
              		
0705: C9      		ret
              		
              	; Turns on the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
0706:         	irq_keyb_on:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
0706: 3E07    		ld	a,7		; AY register = 7
0708: D341    		out	(nabu_ay_latch),a
070A: DB40    		in	a,(nabu_ay_data)
070C: E63F    		and	0x3F
070E: F640    		or	0x40
0710: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask on interrupt
0712: 3E0E    		ld	a,14		; AY register = 14	
0714: D341    		out	(nabu_ay_latch),a
0716: DB40    		in	a,(nabu_ay_data)
0718: F620    		or	0b00100000
071A: D340    		out	(nabu_ay_data),a
              		
071C: C9      		ret
              		
              	; Turns off the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
071D:         	irq_keyb_off:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
071D: 3E07    		ld	a,7		; AY register = 7
071F: D341    		out	(nabu_ay_latch),a
0721: DB40    		in	a,(nabu_ay_data)
0723: E63F    		and	0x3F
0725: F640    		or	0x40
0727: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
0729: 3E0E    		ld	a,14		; AY register = 14	
072B: D341    		out	(nabu_ay_latch),a
072D: DB40    		in	a,(nabu_ay_data)
072F: E6DF    		and	~0b00100000
0731: D340    		out	(nabu_ay_data),a
              		
0733: C9      		ret
              	
              	; --------------------------------
              	; ******** KRISYS Startup ********
              	; --------------------------------
              	
              	.area	_TEXT
              		
              		; KRISYS entry point
0734:         	kri_start:	
              		; Set up stack
0734: F3      		di
0735: 310070  		ld	sp,kri_stack
0738: 216907  		ld	hl,cpm_exit
073B: E5      		push	hl
              		
              		; Print "hello" splash
073C: 0E09    		ld	c,bdos_print
073E: 113308  		ld	de,str_splash
0741: CD0500  		call	bdos
              		
              		; Initalize subcomponents
0744: CDC406  		call	irq_init
0747: CDAC01  		call	zmm_init
074A: CDB806  		call	trap_init
074D: CD0301  		call	mem_map_init
0750: CDB502  		call	res_init
              		
              		
              		; Start the core
0753: C38807  		jp	core_start
              		
              	; ------------------------------
              	; ******** CP/M Service ********
              	; ------------------------------
              		
              	; Print something to the CP/M console
              	; DE = Address of string to print
              	;
              	; Returns nothing
              	; Uses: All
0756:         	cpm_print:
              		; Save control register state
0756: 3AFD0A  		ld	a,(zmm_ctrl_state)
0759: F5      		push	af
              		
              		; Go to real mode
075A: CD1002  		call zmm_set_real
              		
              		; Do BDOS call
075D: 0E09    		ld	c,bdos_print
075F: CD0500  		call	bdos
              		
              		; Restore register
0762: F1      		pop	af
0763: 32FD0A  		ld	(zmm_ctrl_state),a
0766: C3FF01  		jp	zmm_ctrl_set
              		
              	; Go back to CP/M
              	;
              	; Does not return
              	; Uses: N/A
0769:         	cpm_exit:
0769: CD1002  		call	zmm_set_real
076C: 0E00    		ld	c,bdos_exit
076E: CD0500  		call	bdos	
              		
              	; ----------------------
              	; ******** Misc ********
              	; ----------------------
              		
              	; Converts the value into an 8 bit hex number
              	; A = Number to convert
              	;
              	; Returns DE = result
              	; Uses: AF, DE
0771: 57      	tohex:	ld	d,a
0772: CD7C07  		call	0$
0775: 5F      		ld	e,a
0776: 7A      		ld	a,d
0777: CD8007  		call	1$
077A: 57      		ld	d,a
077B: C9      		ret
              		
077C: 1F      	0$:	rra
077D: 1F      		rra
077E: 1F      		rra
077F: 1F      		rra
0780: F6F0    	1$:	or	0xF0
0782: 27      		daa
0783: C6A0    		add	a,0xA0
0785: CE40    		adc	a,0x40
0787: C9      		ret
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0833:         	str_splash:
0833: 4944454E		defb	'IDENTITY KRISYS HYPERVISOR, CP/M EDT.',0x0A,0x0D
0837: 54495459	
083B: 204B5249	
083F: 53595320	
0843: 48595045	
0847: 52564953	
084B: 4F522C20	
084F: 43502F4D	
0853: 20454454	
0857: 2E0A0D  	
085A: 5645522E		defb	'VER. 0.0.1, GAVIN TERSTEEG 2024'
085E: 20302E30	
0862: 2E312C20	
0866: 47415649	
086A: 4E205445	
086E: 52535445	
0872: 45472032	
0876: 303234  	
              		
              	; Carriage return, line break
0879:         	str_crlf:
0879: 0A0D24  		defb	0x0A,0x0D,'$' 
              		
              	
              	; ---------------------------
              	; ******** Core Init ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Start of ColecoVision core
0788:         	core_start:
0788: C36907  		jp	cpm_exit
              		
078B:         	debug_point:
              	
              	
              	; -----------------------------------
              	; ******** Interrupt Handler ********
              	; -----------------------------------
              	
              	.area	_TEXT
              		
              	; Handle "real" interrupts from devices (if needed)
              	; All registers except AF must remain unchanged!
078B:         	irq_handle:
078B: C9      		ret
              		
              	
              	; -----------------------------
              	; ******** I/O Handler ********
              	; -----------------------------
              		
              	.area	_TEXT
              	
              	; Handle an IN instruction
              	; Inputted value should be returned in register A
              	; All registers except AF must remain unchanged!
078C:         	in_handle:
078C: 3EFF    		ld	a,0xFF
078E: C9      		ret
              	
              	; Handle an OUT instruction
              	; A = Value outputted by virtual machine
              	; All registers except AF must remain unchanged!
078F:         	out_handle:
078F: C9      		ret
              		
              	; ----------------------
              	; ******** Data ********
              	; ----------------------
              		
              	.area	_DATA
              	
0037:         	TRAP	equ	zmm_trap
              	
              	; Virtual machine I/O maps
              	; Input map
087C:         	io_map_input:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
087C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
0880: 37...   	
088C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
0890: 37...   	
089C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
08A0: 37...   	
08AC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
08B0: 37...   	
08BC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
08C0: 37...   	
08CC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
08D0: 37...   	
08DC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
08E0: 37...   	
08EC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
08F0: 37...   	
08FC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x8*
0900: 37...   	
090C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x9*
0910: 37...   	
091C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xA*
0920: 37...   	
092C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xB*
0930: 37...   	
093C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
0940: 37...   	
094C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
0950: 37...   	
095C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
0960: 37...   	
096C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
0970: 37...   	
              	
              	; Output map
097C:         	io_map_output:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
097C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
0980: 37...   	
098C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
0990: 37...   	
099C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
09A0: 37...   	
09AC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
09B0: 37...   	
09BC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
09C0: 37...   	
09CC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
09D0: 37...   	
09DC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
09E0: 37...   	
09EC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
09F0: 37...   	
09FC: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x8*
0A00: 37...   	
0A0C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x9*
0A10: 37...   	
0A1C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xA*
0A20: 37...   	
0A2C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xB*
0A30: 37...   	
0A3C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
0A40: 37...   	
0A4C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
0A50: 37...   	
0A5C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
0A60: 37...   	
0A6C: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
0A70: 37...   	


; +++ segments +++

#CODE _TEXT    = $0100 =   256,  size = $0690 =  1680
#CODE _DATA    = $0790 =  1936,  size = $02EC =   748
#DATA _BSS     = $0A7C =  2684,  size = $0146 =   326

; +++ global symbols +++

TRAP             = $0037 =    55  _DATA   KCOLECO.asm:60
_BSS             = $0A7C =  2684  _BSS    KRISYS.asm:28 (unused)
_BSS_end         = $0BC2 =  3010  _BSS    KRISYS.asm:28
_BSS_size        = $0146 =   326  _BSS    KRISYS.asm:28 (unused)
_DATA            = $0790 =  1936  _DATA   KRISYS.asm:27 (unused)
_DATA_end        = $0A7C =  2684  _DATA   KRISYS.asm:27
_DATA_size       = $02EC =   748  _DATA   KRISYS.asm:27 (unused)
_TEXT            = $0100 =   256  _TEXT   KRISYS.asm:26 (unused)
_TEXT_end        = $0790 =  1936  _TEXT   KRISYS.asm:26
_TEXT_size       = $0690 =  1680  _TEXT   KRISYS.asm:26 (unused)
alloc_bank_map   = $0A7D =  2685  _BSS    MEMORY.asm:211
arg_size         = $0010 =    16  _BSS    RESOURCE.asm:17
banks_free       = $0A7C =  2684  _BSS    MEMORY.asm:205
bdos             = $0005 =     5  _TEXT   KRISYS.asm:49
bdos_con_in      = $0001 =     1  _TEXT   KRISYS.asm:51 (unused)
bdos_con_out     = $0002 =     2  _TEXT   KRISYS.asm:52
bdos_exit        = $0000 =     0  _TEXT   KRISYS.asm:50
bdos_open        = $000F =    15  _TEXT   KRISYS.asm:54
bdos_print       = $0009 =     9  _TEXT   KRISYS.asm:53
bdos_read        = $0014 =    20  _TEXT   KRISYS.asm:55
bios_set_dma     = $001A =    26  _TEXT   KRISYS.asm:56
core_start       = $0788 =  1928  _TEXT   KCOLECO.asm:17
cpm_command      = $0080 =   128  _TEXT   KRISYS.asm:58
cpm_exit         = $0769 =  1897  _TEXT   KRISYS.asm:164
cpm_print        = $0756 =  1878  _TEXT   KRISYS.asm:143
debug_point      = $078B =  1931  _TEXT   KCOLECO.asm:20 (unused)
in_handle        = $078C =  1932  _TEXT   KCOLECO.asm:44
io_map_input     = $087C =  2172  _DATA   KCOLECO.asm:64 (unused)
io_map_output    = $097C =  2428  _DATA   KCOLECO.asm:84 (unused)
irq_handle       = $078B =  1931  _TEXT   KCOLECO.asm:31
irq_init         = $06C4 =  1732  _TEXT   IRQ.asm:22
irq_keyb_off     = $071D =  1821  _TEXT   IRQ.asm:119 (unused)
irq_keyb_on      = $0706 =  1798  _TEXT   IRQ.asm:95 (unused)
irq_vdp_off      = $06EF =  1775  _TEXT   IRQ.asm:71 (unused)
irq_vdp_on       = $06D8 =  1752  _TEXT   IRQ.asm:47 (unused)
kri_stack        = $7000 = 28672  _TEXT   KRISYS.asm:90
kri_start        = $0734 =  1844  _TEXT   KRISYS.asm:111
mem_alloc        = $0165 =   357  _TEXT   MEMORY.asm:103
mem_empty        = $01A3 =   419  _TEXT   MEMORY.asm:177
mem_free         = $0186 =   390  _TEXT   MEMORY.asm:135
mem_free_all     = $0198 =   408  _TEXT   MEMORY.asm:161 (unused)
mem_map_init     = $0103 =   259  _TEXT   MEMORY.asm:30
nabu_ay_data     = $0040 =    64  _TEXT   KRISYS.asm:84
nabu_ay_latch    = $0041 =    65  _TEXT   KRISYS.asm:85
nabu_nctl        = $0000 =     0  _TEXT   KRISYS.asm:83 (unused)
nabu_vdp_addr    = $00A1 =   161  _TEXT   KRISYS.asm:87 (unused)
nabu_vdp_data    = $00A0 =   160  _TEXT   KRISYS.asm:86 (unused)
nmi_address      = $0066 =   102  _TEXT   KRISYS.asm:79
nmi_vector       = $0067 =   103  _TEXT   KRISYS.asm:80
out_handle       = $078F =  1935  _TEXT   KCOLECO.asm:51
res_argument     = $0B02 =  2818  _BSS    RESOURCE.asm:480
res_bankmap      = $0B98 =  2968  _BSS    RESOURCE.asm:500
res_buffer       = $0B15 =  2837  _BSS    RESOURCE.asm:488
res_current      = $0B13 =  2835  _BSS    RESOURCE.asm:484
res_do_read      = $0B97 =  2967  _BSS    RESOURCE.asm:496
res_fcb          = $0B9C =  2972  _BSS    RESOURCE.asm:508
res_fcb_cr       = $0BBC =  3004  _BSS    RESOURCE.asm:518 (unused)
res_fcb_data     = $0BAC =  2988  _BSS    RESOURCE.asm:517 (unused)
res_fcb_drive    = $0B9C =  2972  _BSS    RESOURCE.asm:510
res_fcb_ex       = $0BA8 =  2984  _BSS    RESOURCE.asm:513 (unused)
res_fcb_name     = $0B9D =  2973  _BSS    RESOURCE.asm:511
res_fcb_r0       = $0BBD =  3005  _BSS    RESOURCE.asm:519 (unused)
res_fcb_r1       = $0BBE =  3006  _BSS    RESOURCE.asm:520 (unused)
res_fcb_r2       = $0BBF =  3007  _BSS    RESOURCE.asm:521 (unused)
res_fcb_rc       = $0BAB =  2987  _BSS    RESOURCE.asm:516 (unused)
res_fcb_s1       = $0BA9 =  2985  _BSS    RESOURCE.asm:514 (unused)
res_fcb_s2       = $0BAA =  2986  _BSS    RESOURCE.asm:515 (unused)
res_fcb_type     = $0BA5 =  2981  _BSS    RESOURCE.asm:512
res_init         = $02B5 =   693  _TEXT   RESOURCE.asm:29
res_load         = $02BF =   703  _TEXT   RESOURCE.asm:47 (unused)
res_locate       = $0457 =  1111  _TEXT   RESOURCE.asm:360 (unused)
res_missing      = $0348 =   840  _TEXT   RESOURCE.asm:153 (unused)
res_open         = $0365 =   869  _TEXT   RESOURCE.asm:179 (unused)
res_pointer      = $0B9A =  2970  _BSS    RESOURCE.asm:504
res_printzt      = $0448 =  1096  _TEXT   RESOURCE.asm:340
res_sectors      = $0B95 =  2965  _BSS    RESOURCE.asm:492
stack_size       = $0020 =    32          KRISYS.asm:31
str_arg_empty    = $07F3 =  2035  _DATA   RESOURCE.asm:464
str_arg_fail     = $080A =  2058  _DATA   RESOURCE.asm:467
str_crlf         = $0879 =  2169  _DATA   KRISYS.asm:208
str_load_a       = $07E3 =  2019  _DATA   RESOURCE.asm:457
str_load_b       = $07EC =  2028  _DATA   RESOURCE.asm:460
str_mem_empty    = $07BB =  1979  _DATA   MEMORY.asm:195
str_mem_init     = $0790 =  1936  _DATA   MEMORY.asm:189
str_mem_init_cnt = $07B5 =  1973  _DATA   MEMORY.asm:192
str_missing      = $0820 =  2080  _DATA   RESOURCE.asm:470
str_splash       = $0833 =  2099  _DATA   KRISYS.asm:203
str_zmm_init     = $07D1 =  2001  _DATA   ZMM.asm:307
tohex            = $0771 =  1905  _TEXT   KRISYS.asm:178
trap_a_value     = $6FFF = 28671  _TEXT   KRISYS.asm:91
trap_continue    = $06B1 =  1713  _TEXT   TRAP.asm:485
trap_entry       = $04C0 =  1216  _TEXT   TRAP.asm:19
trap_f_value     = $6FFE = 28670  _TEXT   KRISYS.asm:92
trap_init        = $06B8 =  1720  _TEXT   TRAP.asm:505
trap_io          = $04D3 =  1235  _TEXT   TRAP.asm:42 (unused)
trap_io_ex_out   = $056B =  1387  _TEXT   TRAP.asm:175
trap_io_ext      = $04EF =  1263  _TEXT   TRAP.asm:62
trap_io_ind      = $0602 =  1538  _TEXT   TRAP.asm:314
trap_io_inx      = $05C5 =  1477  _TEXT   TRAP.asm:255
trap_io_outd     = $0678 =  1656  _TEXT   TRAP.asm:430
trap_io_outx     = $063B =  1595  _TEXT   TRAP.asm:369
trap_sp_value    = $0BC0 =  3008  _BSS    TRAP.asm:523
zmm_addr_hi      = $0032 =    50  _TEXT   KRISYS.asm:67 (unused)
zmm_addr_lo      = $0033 =    51  _TEXT   KRISYS.asm:68 (unused)
zmm_bnk0         = $0030 =    48  _TEXT   KRISYS.asm:61
zmm_bnk0_set     = $025D =   605  _TEXT   ZMM.asm:192
zmm_bnk0_state   = $0AFE =  2814  _BSS    ZMM.asm:321
zmm_bnk0_we      = $027D =   637  _TEXT   ZMM.asm:241 (unused)
zmm_bnk0_wp      = $0275 =   629  _TEXT   ZMM.asm:232 (unused)
zmm_bnk1         = $0031 =    49  _TEXT   KRISYS.asm:62
zmm_bnk1_set     = $0263 =   611  _TEXT   ZMM.asm:202
zmm_bnk1_state   = $0AFF =  2815  _BSS    ZMM.asm:325
zmm_bnk1_we      = $028D =   653  _TEXT   ZMM.asm:259 (unused)
zmm_bnk1_wp      = $0285 =   645  _TEXT   ZMM.asm:250 (unused)
zmm_bnk2         = $0032 =    50  _TEXT   KRISYS.asm:63
zmm_bnk2_set     = $0269 =   617  _TEXT   ZMM.asm:212
zmm_bnk2_state   = $0B00 =  2816  _BSS    ZMM.asm:329
zmm_bnk2_we      = $029D =   669  _TEXT   ZMM.asm:277 (unused)
zmm_bnk2_wp      = $0295 =   661  _TEXT   ZMM.asm:268 (unused)
zmm_bnk3         = $0033 =    51  _TEXT   KRISYS.asm:64
zmm_bnk3_set     = $026F =   623  _TEXT   ZMM.asm:222
zmm_bnk3_state   = $0B01 =  2817  _BSS    ZMM.asm:333
zmm_bnk3_we      = $02AD =   685  _TEXT   ZMM.asm:295 (unused)
zmm_bnk3_wp      = $02A5 =   677  _TEXT   ZMM.asm:286 (unused)
zmm_capt_res     = $007F =   127  _TEXT   KRISYS.asm:76 (unused)
zmm_capt_set     = $0070 =   112  _TEXT   KRISYS.asm:75 (unused)
zmm_capture      = $7000 = 28672  _TEXT   KRISYS.asm:71
zmm_ctrl         = $0034 =    52  _TEXT   KRISYS.asm:65
zmm_ctrl_set     = $01FF =   511  _TEXT   ZMM.asm:94
zmm_ctrl_state   = $0AFD =  2813  _BSS    ZMM.asm:317
zmm_init         = $01AC =   428  _TEXT   ZMM.asm:22
zmm_irq_inter    = $0231 =   561  _TEXT   ZMM.asm:147 (unused)
zmm_irq_normal   = $023C =   572  _TEXT   ZMM.asm:158 (unused)
zmm_irq_off      = $0252 =   594  _TEXT   ZMM.asm:180 (unused)
zmm_irq_on       = $0247 =   583  _TEXT   ZMM.asm:169 (unused)
zmm_isr          = $0030 =    48  _TEXT   KRISYS.asm:66
zmm_map          = $8000 = 32768  _TEXT   KRISYS.asm:72 (unused)
zmm_prgm_in      = $021B =   539  _TEXT   ZMM.asm:125 (unused)
zmm_prgm_out     = $0226 =   550  _TEXT   ZMM.asm:136 (unused)
zmm_set_real     = $0210 =   528  _TEXT   ZMM.asm:114
zmm_set_virt     = $0205 =   517  _TEXT   ZMM.asm:103
zmm_top          = $C000 = 49152  _TEXT   KRISYS.asm:73
zmm_trap         = $0037 =    55  _TEXT   KRISYS.asm:69
zmm_vm_start     = $01C9 =   457  _TEXT   ZMM.asm:44 (unused)


total time: 0.7030 sec.
no errors
