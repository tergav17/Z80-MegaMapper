              	; --------------------------------------
              	; zasm: assemble "KSG1000.asm"
              	; date: 2024-09-01 01:55:26
              	; --------------------------------------


              	;
              	;********************************************************************
              	;*
              	;*        K R I S Y S   S G 1 0 0 0   C O R E
              	;*
              	;********************************************************************
              	
              	#include "KRISYS.asm"
              	;
              	;********************************************************************
              	;*
              	;*              I D E N T I T Y   K R I S Y S
              	;*
              	;*      The [K]lunkly [R]emapper / [I]nterpreter [SYS]tem
              	;*
              	;*             Written by Gavin Tersteeg, 2024
              	;*              Copyleft, All Wrongs Reserved
              	;*
              	;*
              	;*   This piece of software allows different classic Z80 systems
              	;*   to run as "virtual machines" on top of existing hardware by
              	;*   use of a ZMM (Z80 MEGAMAPPER). It does this by remapping RAM
              	;*   and I/O address space ot match that of it's target system.
              	;*   Anything that can't be emulated by simple remapping is instead
              	;*   interpreted using I/O traps. 
              	;*
              	;*   This allows virtualized machines to run with an acceptable
              	;*   degree of speed and accuracy. While the ZMM is still quite
              	;*   limited in what sort of hardware can be efficiently virtualized,
              	;*   anything that avoids MMIO or graphics hardware that isn't a VDP
              	;*   generally can be made to work.
              	;* 
              	;********************************************************************
              		
              	; ----------------------------
              	; ******** ZASM Setup ********
              	; ----------------------------
              	
0020:         	stack_size = 0x20
              	
              	#target BIN
0100:         	#code	_TEXT,0x0100	; Setup to run as a CP/M executable
0A44:         	#code	_DATA,_TEXT_end
0E50:         	#data	_BSS,_DATA_end
              	
              	; Make sure w don't overrun available memory
              	#assert	_BSS_end < (zmm_capture-stack_size)
              	
              	.area	_TEXT
0100: C30409  		jp	kri_start
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
              	; CP/M Stuff
0005:         	bdos		equ	0x0005
0000:         	bdos_exit	equ	0x00
0001:         	bdos_con_in	equ	0x01
0002:         	bdos_con_out	equ	0x02
0009:         	bdos_print	equ	0x09
000A:         	bdos_input	equ	0x0A
000F:         	bdos_open	equ	0x0F
0014:         	bdos_read	equ	0x14
001A:         	bios_set_dma	equ	0x1A
              	
0080:         	cpm_command	equ	0x0080
              	
              	; Z80 MEGAMAPPER Stuff
0030:         	zmm_bnk0	equ	0x30	; 16K Bank 0 (0x0000 - 0x3FFF)
0031:         	zmm_bnk1	equ	0x31	; 16K Bank 1 (0x4000 - 0x7FFF)
0032:         	zmm_bnk2	equ	0x32	; 16K Bank 2 (0x8000 - 0xBFFF)
0033:         	zmm_bnk3	equ	0x33	; 16K Bank 3 (0xC000 - 0xFFFF)
0034:         	zmm_ctrl	equ	0x34	; ZMM Control Register
0030:         	zmm_isr		equ	0x30	; ZMM Trapped Instruction Register
0032:         	zmm_addr_hi	equ	0x32	; ZMM Trap Address High
0033:         	zmm_addr_lo	equ	0x33	; ZMM Trap Address Low
0037:         	zmm_trap	equ	0x37 	; ZMM Trap Vector
              	
7000:         	zmm_capture	equ	0x7000
8000:         	zmm_map		equ	0x8000
C000:         	zmm_top		equ	0xC000
              	
0070:         	zmm_capt_set	equ	0b01110000
007F:         	zmm_capt_res	equ	0b01111111
              	
              	; General Z80 Stuff
0066:         	nmi_address	equ	0x0066
0067:         	nmi_vector	equ	nmi_address+1
              	
              	; NABU Specific Stuff
0000:         	nabu_nctl	equ	0x00	; NABU Control Register
0040:         	nabu_ay_data	equ	0x40	; AY-3-8910 Data Port
0041:         	nabu_ay_latch	equ	0x41	; AY-3-8910 Latch Port
00A0:         	nabu_vdp_data	equ	0xA0	; VDP Data Port
00A1:         	nabu_vdp_addr	equ	0xA1	; VDP Address Port
              	
              	; Stack / Trap Management
7000:         	kri_stack	equ	zmm_capture
6FFF:         	trap_a_value	equ	kri_stack-1
6FFE:         	trap_f_value	equ	kri_stack-2
              	
              	; -------------------------------------
              	; ******** Additional Includes ********
              	; -------------------------------------
              	
              	#include "MEMORY.asm"
              	;
              	;********************************************************************
              	;*
              	;*                    Z M M   M E M O R Y
              	;* 
              	;*    The ZMM can be configured to have different amounts
              	;*    of memory installed. Instead of dicking around with 
              	;*    on-board jumpers, KRISYS will simply check what banks
              	;*    are available on startup. Memory will be dynamically
              	;*    allocated as needed by the client process.
              	;*
              	;*    Memory can be assigned to specific owners in the code.
              	;*    Valid owner IDs range from 1 to 254. Owner 0 is reserved
              	;*    for unallocatable banks.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              		
              	; Initalize the memory map
              	; Each bank of the ZMM will be probed, and writable
              	; banks will be recorded on the allocated bank map
              	;
              	; Returns nothing
              	; Uses: AF, BC, DE, HL
0103:         	mem_map_init:
              		; Go to virtual mode
0103: CD4002  		call	zmm_set_virt
              		
              		; Reset free bank counter
0106: 3E00    		ld	a,0
0108: 32500E  		ld	(banks_free),a
              		
              		; Write tags to all banks
010B: 0600    		ld	b,0
010D: 78      	0$:	ld	a,b
010E: CDAA02  		call	zmm_bnk3_set
0111: 3200C0  		ld	(zmm_top),a
0114: ED44    		neg
0116: 3201C0  		ld	(zmm_top+1),a
0119: 04      		inc	b
011A: F20D01  		jp	p,0$
              		
              		; Mark any banks that record correctly
011D: 0600    		ld	b,0
011F: 21510E  		ld	hl,alloc_bank_map
0122: AF      	1$:	xor	a
0123: 77      		ld	(hl),a
0124: 78      		ld	a,b
0125: CDAA02  		call	zmm_bnk3_set
0128: 3A00C0  		ld	a,(zmm_top)
012B: B8      		cp	b
012C: C24401  		jp	nz,2$
012F: 3A01C0  		ld	a,(zmm_top+1)
0132: 4F      		ld	c,a
0133: 78      		ld	a,b
0134: ED44    		neg
0136: B9      		cp	c
0137: C24401  		jp	nz,2$
              	
              		; Mark it
013A: 3EFF    		ld	a,0xFF
013C: 77      		ld	(hl),a
013D: 3A500E  		ld	a,(banks_free)
0140: 3C      		inc	a
0141: 32500E  		ld	(banks_free),a
              		
              		; Next
0144: 23      	2$:	inc	hl
0145: 04      		inc	b
0146: F22201  		jp	p,1$
              		
              		; Disable virtual mode
0149: CD4B02  		call	zmm_set_real
              		
              		; Print out result
014C: 3A500E  		ld	a,(banks_free)
014F: CD6B09  		call	tohex
0152: ED53690A		ld	(str_mem_init_cnt),de
0156: 11440A  		ld	de,str_mem_init
0159: CD2909  		call	cpm_print
              		
              		; Do we actually have an acceptable amount of memory?
015C: 3A500E  		ld	a,(banks_free)
015F: 3D      		dec	a
0160: 3D      		dec	a
0161: FADB01  		jp	m,mem_empty
              		
              		; We do, return
0164: C9      		ret
              		
              	; Fetch byte from virtual memory
              	; HL = Address to fetch
              	;
              	; Returns A = Fetched byte
              	; Uses: AF
0165:         	mem_fvbyte:
              		; Calculate target bank
0165: CD7801  		call	mem_getbank
0168: D333    		out	(zmm_bnk3),a
              		
              		; Grab byte
016A: E5      		push	hl
016B: 7C      		ld	a,h
016C: F6C0    		or	0b11000000
016E: 67      		ld	h,a
016F: 66      		ld	h,(hl)
              		
              		; Restore original bank
0170: 3AD50E  		ld	a,(zmm_bnk3_state)
0173: D333    		out	(zmm_bnk3),a
0175: 7C      		ld	a,h
              		
              		; Return
0176: E1      		pop	hl
0177: C9      		ret
              	
              	
              	; Gets the bank that an address points to
              	; HL = Address to analyse
              	;
              	; Returns A = Value of write-enabled bank
              	; Uses: AF
0178:         	mem_getbank:
0178: 7C      		ld	a,h
0179: 07      		rlca
017A: DA8D01  		jp	c,0$
              		
              		; Lower 32K
017D: 07      		rlca
017E: DA8701  		jp	c,1$
              		
              		; 0-15K
0181: 3AD20E  		ld	a,(zmm_bnk0_state)
0184: E67F    		and	0b01111111
0186: C9      		ret
              		
              		; 16K-31K
0187: 3AD30E  	1$:	ld	a,(zmm_bnk1_state)
018A: E67F    		and	0b01111111
018C: C9      		ret
              	
              		; Upper 32K
018D: 07      	0$:	rlca
018E: DA9701  		jp	c,2$
              		
              		; 32K-47K
0191: 3AD40E  		ld	a,(zmm_bnk2_state)
0194: E67F    		and	0b01111111
0196: C9      		ret
              	
              		; 48K-63K
0197: 3AD50E  	2$:	ld	a,(zmm_bnk3_state)
019A: E67F    		and	0b01111111
019C: C9      		ret
              		
              	; Allocates a bank of memory
              	; Will produce an error if no banks are available,
              	; check (banks_free) to avoid
              	; D = Owner ID (1-254)
              	;
              	; Returns A = Bank #
              	; Uses: AF, BC, HL
019D:         	mem_alloc:
              		; Check and decrement free memory
019D: 3A500E  		ld	a,(banks_free)
01A0: 3D      		dec	a
01A1: 32500E  		ld	(banks_free),a
01A4: FADB01  		jp	m,mem_empty
              		
              		; Look for the first free bank
01A7: 21510E  		ld	hl,alloc_bank_map
01AA: 018000  		ld	bc,0x0080
01AD: 3EFF    		ld	a,0xFF
01AF: EDB1    		cpir
              		
              		; Make sure we found something
01B1: C2DB01  		jp	nz,mem_empty
              		
              		; Save and exit
01B4: 2B      		dec	hl
01B5: 72      		ld	(hl),d
01B6: 01510E  		ld	bc,alloc_bank_map
01B9: B7      		or	a
01BA: ED42    		sbc	hl,bc
01BC: 7D      		ld	a,l
01BD: C9      		ret
              		
              	; Frees a bank of memory
              	; Safe to use on banks that are not free / not owned
              	; A = Bank #
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
01BE:         	mem_free:
              		; Find location in memory
01BE: 0600    		ld	b,0
01C0: 4F      		ld	c,a
01C1: 21510E  		ld	hl,alloc_bank_map
01C4: 09      		add	hl,bc
              		
              		; Check owner
01C5: 7E      		ld	a,(hl)
01C6: BA      		cp	d
01C7: C0      		ret	nz
              		
              		; Free bank
01C8: 3EFF    		ld	a,0xFF
01CA: 77      		ld	(hl),a
              		
              		; Increment banks free
01CB: 21500E  		ld	hl,banks_free
01CE: 34      		inc	(hl)
01CF: C9      		ret
              		
              	; Free all banks by owner
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
01D0:         	mem_free_all:
              		; Free a bank
01D0: AF      		xor	a
01D1: F5      	0$:	push	af
01D2: CDBE01  		call	mem_free
01D5: F1      		pop	af
              		
              		; Next bank
01D6: 3C      		inc	a
01D7: F2D101  		jp	p,0$
01DA: C9      		ret
              		
              	; Error out if empty
              	;
              	; Does not return
              	; Uses: N/A
01DB:         	mem_empty:
01DB: 116F0A  		ld	de,str_mem_empty
01DE: CD2909  		call	cpm_print
01E1: C36309  		jp	cpm_exit
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0A44:         	str_mem_init:
0A44: 494E4954		defb	'INITIALIZED MEMORY MAP',0x0A,0x0D
0A48: 49414C49	
0A4C: 5A454420	
0A50: 4D454D4F	
0A54: 5259204D	
0A58: 41500A0D	
0A5C: 42414E4B		defb	'BANK COUNT = '
0A60: 20434F55	
0A64: 4E54203D	
0A68: 20      	
0A69:         	str_mem_init_cnt:
0A69: 5858480A		defb	'XXH',0x0A,0x0D,'$'
0A6D: 0D24    	
              		
0A6F:         	str_mem_empty:
0A6F: 494E5355		defb	'INSUFFICIENT MEMORY',0x0A,0x0D,'$'
0A73: 46464943	
0A77: 49454E54	
0A7B: 204D454D	
0A7F: 4F52590A	
0A83: 0D24    	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Free bank count
0E50:         	banks_free:
0E50: 00      		defs	1
              	
              	; Allocated bank map
              	; This 128 byte table keeps track of every single 16K bank
              	; that exists on the ZMM. Populated on startup
0E51:         	alloc_bank_map:
0E51: 00000000		defs	128
0E55: 00...   	
              	#include "ZMM.asm"
              	;
              	;********************************************************************
              	;*
              	;*                  Z M M   M A N A G E M E N T
              	;* 
              	;*    These routines are used to manage the state of the ZMM.
              	;*    This includes the setting of the registers as well as setting
              	;*    up trap and interrupt stuff.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize ZMM and reset registers
              	;
              	; Returns nothing
              	; Uses: AF
01E4:         	zmm_init:
              		; Zero out control register
01E4: 3E00    		ld	a,0
01E6: 32D10E  		ld	(zmm_ctrl_state),a
01E9: 32D20E  		ld	(zmm_bnk0_state),a
01EC: 32D30E  		ld	(zmm_bnk1_state),a
01EF: 32D40E  		ld	(zmm_bnk2_state),a
01F2: 32D50E  		ld	(zmm_bnk3_state),a
              		
              		; See if we can swing in and out of virtual mode
01F5: CD4002  		call	zmm_set_virt
01F8: CD4B02  		call	zmm_set_real
              		
              		; Tell the user that the ZMM is ready
01FB: 11850A  		ld	de,str_zmm_init
01FE: C32909  		jp	cpm_print
              		
              	; Start execution of the virtual machine at a specific location
              	; HL = Address to start execution at
              	; 
              	; Does not return
              	; Uses: All registers zeroed
0201:         	zmm_vm_start:
0201: 310000  		ld	sp,0x0000
              		
              		; Completely empty out capture zone
0204: E5      		push	hl
0205: 210070  		ld	hl,zmm_capture
0208: 110170  		ld	de,zmm_capture+1
020B: 01FF0F  		ld	bc,0x1000-1
020E: AF      		xor	a
020F: 77      		ld	(hl),a
0210: EDB0    		ldir
0212: E1      		pop	hl
              		
0213: 7D      		ld	a,l
0214: 320070  		ld	(zmm_capture),a
0217: 7C      		ld	a,h
0218: 320170  		ld	(zmm_capture + 1),a
              		
              		; Reset I/O trap flag just in case
021B: D337    		out	(zmm_trap),a
              		
              		; Zero everything
021D: 3E01    		ld	a,1
021F: 47      		ld	b,a
0220: 4F      		ld	c,a
0221: 57      		ld 	d,a
0222: 5F      		ld	e,a
0223: 67      		ld	h,a
0224: 6F      		ld	l,a
0225: D9      		exx
0226: 08      		ex	af,af'
0227: 3E01    		ld	a,1
0229: 47      		ld	b,a
022A: 4F      		ld	c,a
022B: 57      		ld 	d,a
022C: 5F      		ld	e,a
022D: 67      		ld	h,a
022E: 6F      		ld	l,a
              		
022F: DD210000		ld	ix,0
0233: FD210000		ld	iy,0
              		
              		; Enter virtual machine
0237: 00      		nop
0238: ED45    		retn
              		
              	; Set the ZMM control register to the recorded state
              	; (zmm_ctrl_state) = New value of ZMM control register
              	;
              	; Returns nothing
              	; Uses: AF
023A:         	zmm_ctrl_set:
023A: 3AD10E  		ld	a,(zmm_ctrl_state)
023D: D334    		out	(zmm_ctrl),a
023F: C9      		ret
              		
              	; Go to virtual mode
              	;
              	; Returns nothing
              	; Uses: AF
0240:         	zmm_set_virt:
0240: 3AD10E  		ld	a,(zmm_ctrl_state)
0243: F601    		or	0b00000001
0245: 32D10E  		ld	(zmm_ctrl_state),a
0248: D334    		out	(zmm_ctrl),a
024A: C9      		ret
              		
              	; Go to real mode
              	;
              	; Returns nothing
              	; Uses: AF
024B:         	zmm_set_real:
024B: 3AD10E  		ld	a,(zmm_ctrl_state)
024E: E6FE    		and	0b11111110
0250: 32D10E  		ld	(zmm_ctrl_state),a
0253: D334    		out	(zmm_ctrl),a
0255: C9      		ret
              		
              	; Set program direction to "IN"
              	;
              	; Returns nothing
              	; Uses: AF
0256:         	zmm_prgm_in:
0256: 3AD10E  		ld	a,(zmm_ctrl_state)
0259: F602    		or	0b00000010
025B: 32D10E  		ld	(zmm_ctrl_state),a
025E: D334    		out	(zmm_ctrl),a
0260: C9      		ret
              		
              	; Set program direction to "OUT"
              	;
              	; Returns nothing
              	; Uses: AF
0261:         	zmm_prgm_out:
0261: 3AD10E  		ld	a,(zmm_ctrl_state)
0264: E6FD    		and	0b11111101
0266: 32D10E  		ld	(zmm_ctrl_state),a
0269: D334    		out	(zmm_ctrl),a
026B: C9      		ret
              		
              	; Turn on irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
026C:         	zmm_irq_inter:
026C: 3AD10E  		ld	a,(zmm_ctrl_state)
026F: F604    		or	0b00000100
0271: 32D10E  		ld	(zmm_ctrl_state),a
0274: D334    		out	(zmm_ctrl),a
0276: C9      		ret
              		
              	; Turn off irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
0277:         	zmm_irq_normal:
0277: 3AD10E  		ld	a,(zmm_ctrl_state)
027A: E6FB    		and	0b11111011
027C: 32D10E  		ld	(zmm_ctrl_state),a
027F: D334    		out	(zmm_ctrl),a
0281: C9      		ret
              	
              	; Turn on force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
0282:         	zmm_irq_on:
0282: 3AD10E  		ld	a,(zmm_ctrl_state)
0285: F608    		or	0b00001000
0287: 32D10E  		ld	(zmm_ctrl_state),a
028A: D334    		out	(zmm_ctrl),a
028C: C9      		ret
              		
              	; Turn off force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
028D:         	zmm_irq_off:
028D: 3AD10E  		ld	a,(zmm_ctrl_state)
0290: E6F7    		and	0b11110111
0292: 32D10E  		ld	(zmm_ctrl_state),a
0295: D334    		out	(zmm_ctrl),a
0297: C9      		ret
              		
              	; Set bank 0
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses: AF, B
0298:         	zmm_bnk0_set:
0298: 32D20E  		ld	(zmm_bnk0_state),a
029B: D330    		out	(zmm_bnk0),a
029D: C9      		ret
              		
              	; Set bank 1
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
029E:         	zmm_bnk1_set:
029E: 32D30E  		ld	(zmm_bnk1_state),a
02A1: D331    		out	(zmm_bnk1),a
02A3: C9      		ret
              		
              	; Set bank 2
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
02A4:         	zmm_bnk2_set:
02A4: 32D40E  		ld	(zmm_bnk2_state),a
02A7: D332    		out	(zmm_bnk2),a
02A9: C9      		ret
              		
              	; Set bank 3
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
02AA:         	zmm_bnk3_set:
02AA: 32D50E  		ld	(zmm_bnk3_state),a
02AD: D333    		out	(zmm_bnk3),a
02AF: C9      		ret
              		
              		
              	; Write protect bank 0
              	;
              	; Returns nothing
              	; Uses: AF
02B0:         	zmm_bnk0_wp:
02B0: 3AD20E  		ld	a,(zmm_bnk0_state)
02B3: F680    		or	0b10000000
02B5: C39802  		jp 	zmm_bnk0_set
              		
              	; Write enable bank 0
              	;
              	; Returns nothing
              	; Uses: AF
02B8:         	zmm_bnk0_we:
02B8: 3AD20E  		ld	a,(zmm_bnk0_state)
02BB: E67F    		and	~0b10000000
02BD: C39802  		jp 	zmm_bnk0_set
              		
              	; Write protect bank 1
              	;
              	; Returns nothing
              	; Uses: AF
02C0:         	zmm_bnk1_wp:
02C0: 3AD30E  		ld	a,(zmm_bnk1_state)
02C3: F680    		or	0b10000000
02C5: C39E02  		jp 	zmm_bnk1_set
              		
              	; Write enable bank 1
              	;
              	; Returns nothing
              	; Uses: AF
02C8:         	zmm_bnk1_we:
02C8: 3AD30E  		ld	a,(zmm_bnk1_state)
02CB: E67F    		and	~0b10000000
02CD: C39E02  		jp 	zmm_bnk1_set
              		
              	; Write protect bank 2
              	;
              	; Returns nothing
              	; Uses: AF
02D0:         	zmm_bnk2_wp:
02D0: 3AD40E  		ld	a,(zmm_bnk2_state)
02D3: F680    		or	0b10000000
02D5: C3A402  		jp 	zmm_bnk2_set
              		
              	; Write enable bank 2
              	;
              	; Returns nothing
              	; Uses: AF
02D8:         	zmm_bnk2_we:
02D8: 3AD40E  		ld	a,(zmm_bnk2_state)
02DB: E67F    		and	~0b10000000
02DD: C3A402  		jp 	zmm_bnk2_set
              		
              	; Write protect bank 3
              	;
              	; Returns nothing
              	; Uses: AF
02E0:         	zmm_bnk3_wp:
02E0: 3AD50E  		ld	a,(zmm_bnk3_state)
02E3: F680    		or	0b10000000
02E5: C3AA02  		jp 	zmm_bnk3_set
              		
              	; Write enable bank 3
              	;
              	; Returns nothing
              	; Uses: AF
02E8:         	zmm_bnk3_we:
02E8: 3AD50E  		ld	a,(zmm_bnk3_state)
02EB: E67F    		and	~0b10000000
02ED: C3AA02  		jp 	zmm_bnk3_set
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0A85:         	str_zmm_init:
0A85: 494E4954		defb	'INITIALIZED ZMM',0x0A,0x0D,'$'
0A89: 49414C49	
0A8D: 5A454420	
0A91: 5A4D4D0A	
0A95: 0D24    	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
0ED1:         	zmm_ctrl_state:
0ED1: 00      		defs	1
              		
              	; Bank 0 state
0ED2:         	zmm_bnk0_state:
0ED2: 00      		defs	1
              		
              	; Bank 1 state
0ED3:         	zmm_bnk1_state:
0ED3: 00      		defs	1
              		
              	; Bank 2 state
0ED4:         	zmm_bnk2_state:
0ED4: 00      		defs	1
              		
              	; Bank 3 state
0ED5:         	zmm_bnk3_state:
0ED5: 00      		defs	1
              		
              	#include "RESOURCE.asm"
              	;
              	;********************************************************************
              	;*
              	;*               R E S O U R C E   M A N A G E M E N T
              	;* 
              	;*    These routines handle obtaining use-supplied resources
              	;*    such as configurations, ROM images, and storage bindings.
              	;*    During startup, these resources will be loaded to build
              	;*    the virtual machine.
              	;*
              	;********************************************************************
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
0010:         	arg_size	equ 16
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize resources
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
02F0:         	res_init:
              		; Start by zero-terminating string
02F0: 218000  		ld	hl,cpm_command
02F3: 4E      		ld	c,(hl)
02F4: 0600    		ld	b,0
02F6: 09      		add	hl,bc
02F7: 23      		inc	hl
02F8: 70      		ld	(hl),b
              		
02F9: C9      		ret
              		
              	; Loads an open resource into a bankmap
              	; Bankmap will be zero-padded to fill requested number of records
              	; HL = Address of bankmap
              	; BC = Number of records (128 byte blocks) to load
              	;
              	; Returns nothing
              	; Uses: all
02FA:         	res_load:
              		; Set read flag
02FA: 3EFF    		ld	a,0xFF
02FC: 326B0F  		ld	(res_do_read),a
              	
              		; Save args
02FF: 226C0F  		ld	(res_bankmap),hl
0302: ED43690F		ld	(res_sectors),bc
              	
              		; Virtual mode should be off while we do this
0306: 3AD10E  		ld	a,(zmm_ctrl_state)
0309: F5      		push	af
030A: CD4B02  		call	zmm_set_real
              		
              		; Do function call
030D: CD1C03  		call	0$
              		
              		; Reset bank 3
0310: 3AD50E  		ld	a,(zmm_bnk3_state)
0313: D333    		out	(zmm_bnk3),a
              		
              		; Restore register
0315: F1      		pop	af
0316: 32D10E  		ld	(zmm_ctrl_state),a
0319: C33A02  		jp	zmm_ctrl_set
              		
              		; Allocate a new bank
031C: 1601    	0$:	ld	d,1
031E: CD9D01  		call	mem_alloc
0321: 2A6C0F  		ld	hl,(res_bankmap)
0324: 77      		ld	(hl),a
0325: 23      		inc	hl
0326: 226C0F  		ld	(res_bankmap),hl
              		
              		; Set the bank in slot 3
0329: D333    		out	(zmm_bnk3),a
              		
              		; Set DMA address
032B: 11E90E  		ld	de,res_buffer
032E: 0E1A    		ld	c,bios_set_dma
0330: CD0500  		call	bdos
              		
              		; Set pointer	
0333: 2100C0  		ld	hl,zmm_top
0336: 226E0F  		ld	(res_pointer),hl
              		
              		; We will be loading up to 128 records at a time here
0339: 0680    		ld	b,128
              		
              		; Do read operation
033B: C5      	1$:	push	bc
033C: 11700F  		ld	de,res_fcb
033F: 0E14    		ld	c,bdos_read
0341: 3A6B0F  		ld	a,(res_do_read)
0344: B7      		or	a
0345: C40500  		call	nz,bdos
              		
              		; Check file I/O result
0348: B7      		or	a
0349: C47203  		call	nz,50$
              		
              		; Go to virtual mode
034C: CD4002  		call	zmm_set_virt
              		
              		; Copy record to bank
034F: 21E90E  		ld	hl,res_buffer
0352: ED5B6E0F		ld	de,(res_pointer)
0356: 018000  		ld	bc,128
0359: EDB0    		ldir
035B: ED536E0F		ld	(res_pointer),de
              		
              		; Back to real mode
035F: CD4B02  		call	zmm_set_real 
              		
              		; Get BC back to restore sector counter
0362: C1      		pop	bc
              		
              		; Decrement record count
0363: 2A690F  		ld	hl,(res_sectors)
0366: 2B      		dec	hl
0367: 22690F  		ld	(res_sectors),hl
036A: 7C      		ld	a,h
036B: B5      		or	l
036C: C8      		ret	z
              		
              		; Go get another sector
036D: 10CC    		djnz	1$
036F: C31C03  		jp	0$
              	
              		; Zero buffer and reset read flag
0372: AF      	50$:	xor	a
0373: 326B0F  		ld	(res_do_read),a
              		
0376: 21E90E  		ld	hl,res_buffer
0379: 11EA0E  		ld	de,res_buffer+1
037C: 017F00  		ld	bc,128-1
037F: 77      		ld	(hl),a
0380: EDB0    		ldir
              	
0382: C9      		ret
              		
              	; Throws an error a missing resource
              	; Resource name will be last attempted to locate
              	;
              	; Does not return
              	; Uses: N/A
0383:         	res_missing:
0383: CD4B02  		call	zmm_set_real
              		
              		; Print error message
0386: 0E09    		ld	c,bdos_print
0388: 11D40A  		ld	de,str_missing
038B: CD0500  		call	bdos
              		
              		; Print resource name
038E: ED5BE70E		ld	de,(res_current)
0392: CD8304  		call	res_printzt
              		
              		; CRLF
0395: 0E09    		ld	c,bdos_print
0397: 11040C  		ld	de,str_crlf
039A: CD0500  		call	bdos
              		
              		; Exit
039D: C36309  		jp	cpm_exit
              		
              	; Opens a file based on the resource argument
              	; If the file cannot be opened, an error will be thrown
              	; (res_argument) = File to open
              	;
              	; Returns nothing
              	; Uses: all
03A0:         	res_open:
              		; Virtual mode should be off while we do this
03A0: 3AD10E  		ld	a,(zmm_ctrl_state)
03A3: F5      		push	af
03A4: CD4B02  		call	zmm_set_real
              		
              		; Do function call
03A7: CDB103  		call	0$
              		
              		; Restore register
03AA: F1      		pop	af
03AB: 32D10E  		ld	(zmm_ctrl_state),a
03AE: C33A02  		jp	zmm_ctrl_set
              		
              		; Let the user know we are loading stuff
03B1: 0E09    	0$:	ld	c,bdos_print
03B3: 11970A  		ld	de,str_load_a
03B6: CD0500  		call	bdos
              		
              		; Print resource name
03B9: ED5BE70E		ld	de,(res_current)
03BD: CD8304  		call	res_printzt
              		
              		; Next string
03C0: 0E09    		ld	c,bdos_print
03C2: 11A00A  		ld	de,str_load_b
03C5: CD0500  		call	bdos
              		
              		; Print file name
03C8: 11D60E  		ld	de,res_argument
03CB: CD8304  		call	res_printzt
              		
              		; CRLF
03CE: 0E09    		ld	c,bdos_print
03D0: 11040C  		ld	de,str_crlf
03D3: CD0500  		call	bdos
              		
              		; Detect if there is an argument
03D6: 3AD60E  		ld	a,(res_argument)
03D9: B7      		or	a
03DA: C2E803  		jp	nz,1$
              		
              		; No argument, error!
03DD: 0E09    		ld	c,bdos_print
03DF: 11A70A  		ld	de,str_arg_empty
03E2: CD0500  		call	bdos
03E5: C36309  		jp	cpm_exit
              	
              		; Reset fields
03E8: AF      	1$:	xor	a
03E9: 21700F  		ld	hl,res_fcb
03EC: 11710F  		ld	de,res_fcb+1
03EF: 012300  		ld	bc ,36-1
03F2: 77      		ld	(hl),a
03F3: EDB0    		ldir
              		
03F5: 3E20    		ld	a,0x20
03F7: 21710F  		ld	hl,res_fcb_name
03FA: 11720F  		ld	de,res_fcb_name+1
03FD: 010A00  		ld	bc ,11-1
0400: 77      		ld	(hl),a
0401: EDB0    		ldir
              	
              		; Is there a prefix?
0403: 21D60E  		ld	hl,res_argument
0406: 3AD70E  		ld	a,(res_argument+1)
0409: FE3A    		cp	':'
040B: C21D04  		jp	nz,2$
              		
              		; Set prefix
040E: 3AD60E  		ld	a,(res_argument)
0411: D640    		sub	'A'-1
0413: FE11    		cp	17
0415: D27804  		jp	nc,99$
0418: 32700F  		ld	(res_fcb_drive),a
041B: 23      		inc	hl
041C: 23      		inc	hl
              	
              		; HL = Proper filename start
041D: 0608    	2$:	ld	b,8
041F: 11710F  		ld	de,res_fcb_name
              		
              		; Copy it over
0422: 7E      	3$:	ld	a,(hl)
0423: B7      		or	a
0424: CA7804  		jp	z,99$
0427: FE2A    		cp	'*'
0429: CA3904  		jp	z,4$
042C: FE2E    		cp	'.'
042E: CA4004  		jp	z,5$
0431: 12      		ld	(de),a
0432: 13      		inc	de
0433: 23      		inc	hl
0434: 10EC    		djnz	3$
0436: C34004  		jp	5$
              	
              		; Fill remains of FCB file name
0439: 3E3F    	4$:	ld	a,'?'
043B: 12      		ld	(de),a
043C: 13      		inc	de
043D: 10FA    		djnz	4$
043F: 23      		inc	hl
              	
              		; We should either see a '.' or a null character
0440: 7E      	5$:	ld	a,(hl)
0441: B7      		or	a
0442: CA6904  		jp	z,8$
0445: FE2E    		cp	'.'
0447: C27804  		jp	nz,99$
044A: 23      		inc	hl
              		
              		; Fill in extension
044B: 0603    		ld	b,3
044D: 11790F  		ld	de,res_fcb_type
              		
              		; Copy it over
0450: 7E      	6$:	ld	a,(hl)
0451: B7      		or	a
0452: CA6904  		jp	z,8$
0455: FE2A    		cp	'*'
0457: CA6204  		jp	z,7$
045A: 12      		ld	(de),a
045B: 13      		inc	de
045C: 23      		inc	hl
045D: 10F1    		djnz	6$
045F: C36904  		jp	8$
              		
              		; Fill remains of FCB file extension
0462: 3E3F    	7$:	ld	a,'?'
0464: 12      		ld	(de),a
0465: 13      		inc	de
0466: 10D1    		djnz	4$
0468: 23      		inc	hl
              	
              		; We should get a zero
0469: 7E      	8$:	ld 	a,(hl)
046A: B7      		or	a
046B: C27804  		jp	nz,99$
              		
              		; It is filled in, attempt to open
046E: 0E0F    		ld	c,bdos_open
0470: 11700F  		ld	de,res_fcb
0473: CD0500  		call	bdos
              		
              		; Check error
0476: 3C      		inc	a
0477: C0      		ret	nz
              		
              		; Error!
0478: 0E09    	99$:	ld	c,bdos_print
047A: 11BE0A  		ld	de,str_arg_fail
047D: CD0500  		call	bdos
0480: C36309  		jp	cpm_exit
              		
              		
              	; Print a zero terminated string
              	; We should be in real mode for this
              	; DE = String
              	;
              	; Returns nothing
              	; Uses: All
0483:         	res_printzt:
0483: 1A      	0$:	ld	a,(de)
0484: B7      		or	a
0485: C8      		ret	z
              		
              		; Print character
0486: D5      		push	de
0487: 5F      		ld	e,a
0488: 0E02    		ld	c,bdos_con_out
048A: CD0500  		call	bdos
048D: D1      		pop	de
048E: 13      		inc	de
048F: C38304  		jp	0$
              	
              	; Find a resource from the command line
              	; If the resource is found, the contents will be cached in memory
              	; DE = Name of resource (upper case only) 
              	;
              	; Returns A = 0xFF if no resource is found
              	; Uses: AF, BC, DE, HL
0492:         	res_locate:
              		; Save resource
0492: ED53E70E		ld	(res_current),de
              	
              		; Travel to the start of arguments
0496: 218100  		ld	hl,cpm_command+1
0499: 7E      	0$:	ld	a,(hl)
049A: B7      		or	a
049B: CAF804  		jp	z,99$
049E: FE21    		cp	0x21
04A0: D2A704  		jp	nc,1$
04A3: 23      		inc	hl
04A4: C39904  		jp	0$
              		
              		; Found an argument
              		; Check it against the contents of (DE)
              		; Also must start with '-'
04A7: FE2D    	1$:	cp	'-'
04A9: C2BA04  		jp	nz,3$
04AC: 23      		inc	hl
04AD: D5      		push	de
04AE: 1A      	2$:	ld	a,(de)
              		
              		; Check if at end of string
04AF: B7      		or	a
04B0: CAC804  		jp	z,4$
              		
              		; No? Well lets see if (de) = (hl)
04B3: BE      		cp	(hl)
04B4: 23      		inc	hl
04B5: 13      		inc	de
04B6: CAAE04  		jp	z,2$
              		
              		; Strings are different!
              		; Escape from the current argument and continue
04B9: D1      		pop	de
04BA: 7E      	3$:	ld	a,(hl)
04BB: B7      		or	a
04BC: CAF804  		jp	z,99$
04BF: FE21    		cp	0x21
04C1: DA9904  		jp	c,0$
04C4: 23      		inc	hl
04C5: C3BA04  		jp	3$
              	
              		; Make sure we are at the end of the argument as well
04C8: D1      	4$: 	pop	de
04C9: 7E      		ld	a,(hl)
04CA: FE21    		cp	0x21
04CC: D2BA04  		jp	nc,3$
              		
              		; Ok, lets copy the argument into memory if it exists
04CF: 11D60E  		ld	de,res_argument
04D2: AF      		xor	a
04D3: 12      		ld	(de),a
              		
              		; Travel to the start of the argument
04D4: 7E      	5$:	ld	a,(hl)
04D5: B7      		or	a
04D6: CAF604  		jp	z,89$
04D9: FE21    		cp	0x21
04DB: D2E204  		jp	nc,6$
04DE: 23      		inc	hl
04DF: C3D404  		jp	5$
              	
              		; Make sure it doesn't start with '-'
04E2: FE2D    	6$:	cp	'-'
04E4: CAF604  		jp	z,89$
              		
              		; Ok, lets copy up 16 bytes of this
04E7: 0610    		ld	b,arg_size
04E9: 7E      	7$:	ld	a,(hl)
04EA: FE21    		cp	0x21
04EC: DAF404  		jp	c,8$
04EF: 12      		ld	(de),a
04F0: 23      		inc	hl
04F1: 13      		inc	de
04F2: 10F5    		djnz	7$
              	
              		; Zero terminate
04F4: AF      	8$:	xor	a
04F5: 12      		ld	(de),a
              		
              		; Good ending
04F6: AF      	89$:	xor	a
04F7: C9      		ret
              	
              		; Bad ending
04F8: 3EFF    	99$:	ld	a,0xFF
04FA: C9      		ret
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Loading string components
0A97:         	str_load_a:
0A97: 4C4F4144		defb	'LOADING $'
0A9B: 494E4720	
0A9F: 24      	
              		
0AA0:         	str_load_b:
0AA0: 2046524F		defb	' FROM $'
0AA4: 4D2024  	
              		
              	; Error messages
0AA7:         	str_arg_empty:
0AA7: 4E4F2041		defb	'NO ARGUMENT PROVIDED',0x0A,0x0D,'$'
0AAB: 5247554D	
0AAF: 454E5420	
0AB3: 50524F56	
0AB7: 49444544	
0ABB: 0A0D24  	
              		
0ABE:         	str_arg_fail:
0ABE: 4641494C		defb	'FAILED TO OPEN FILE',0x0A,0x0D,'$'
0AC2: 45442054	
0AC6: 4F204F50	
0ACA: 454E2046	
0ACE: 494C450A	
0AD2: 0D24    	
              		
0AD4:         	str_missing:
0AD4: 4D495353		defb	'MISSING RESOURCE: $'
0AD8: 494E4720	
0ADC: 5245534F	
0AE0: 55524345	
0AE4: 3A2024  	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Stores a zero-terminated string for the resource argument
0ED6:         	res_argument:
0ED6: 00000000		defs	arg_size+1
0EDA: 00...   	
              		
              	; Current resource being accessed
0EE7:         	res_current:
0EE7: 0000    		defs	2
              		
              	; Resource buffer
0EE9:         	res_buffer:
0EE9: 00000000		defs	128
0EED: 00...   	
              		
              	; Sector counter
0F69:         	res_sectors:
0F69: 0000    		defs	2
              		
              	; Do we need to read?
0F6B:         	res_do_read:
0F6B: 00      		defs	1
              		
              	; Resource bankmap
0F6C:         	res_bankmap:
0F6C: 0000    		defs	2
              		
              	; Loading pointer
0F6E:         	res_pointer:
0F6E: 0000    		defs	2
              		
              	; File control block for use in loading resources
0F70:         	res_fcb:
0F70: 00000000		defs	36
0F74: 00...   	
0F70:         	res_fcb_drive	equ	res_fcb
0F71:         	res_fcb_name	equ	res_fcb+1
0F79:         	res_fcb_type	equ	res_fcb+9
0F7C:         	res_fcb_ex	equ	res_fcb+12
0F7D:         	res_fcb_s1	equ	res_fcb+13
0F7E:         	res_fcb_s2	equ	res_fcb+14
0F7F:         	res_fcb_rc	equ	res_fcb+15
0F80:         	res_fcb_data	equ	res_fcb+16
0F90:         	res_fcb_cr	equ	res_fcb+32
0F91:         	res_fcb_r0	equ	res_fcb+33
0F92:         	res_fcb_r1	equ	res_fcb+34
0F93:         	res_fcb_r2	equ	res_fcb+35
              	#include "TRAP.asm"
              	;
              	;********************************************************************
              	;*
              	;*                     T R A P   H A N D L E R
              	;* 
              	;*    Responsible for handling various traps from the ZMM. Both
              	;*    interrupt and I/O traps will be pre-processed before being
              	;*    sent to the virtualization core for device-specific handling
              	;*
              	;********************************************************************
              	
              	; -------------------------------
              	; ********  Trap Handler ********
              	; -------------------------------
              	
              	.area	_TEXT
              	
              	; Entry point for traps
04FB:         	trap_entry:
              		; Save value of SP
04FB: ED73940F		ld	(trap_sp_value),sp
04FF: 310070  		ld	sp,kri_stack
              		
              		; Save value of AF
0502: F5      		push	af
              		
              		; Check in on device interrupts
0503: CD0F0A  		call	irq_handle
              		
              		; Grab the value of the ISR register
0506: DB30    		in	a,(zmm_isr)
              		
              		; Do we actually need to handle an I/O trap?
0508: B7      		or	a
0509: F2E406  		jp	p,trap_continue
              		
              		; OK, a trap did occur.
              		; Are we doing "classic" I/O or extended I/O?
050C:         	trap_io:	
050C: FEE8    		cp	0b11101000
050E: DA2805  		jp	c,trap_io_ext
              		
              		; In or out?
0511: FEEC    		cp	0b11101100
0513: DA1F05  		jp	c,0$
              		
              		; In it is
0516: CD1D0A  		call	in_handle
0519: 32FF6F  		ld	(trap_a_value),a
051C: C3E406  		jp	trap_continue
              		
              		; Out it is
051F: 3AFF6F  	0$:	ld	a,(trap_a_value)
0522: CD430A  		call	out_handle
0525: C3E406  		jp	trap_continue
              	
              	
              	; It's an extended I/O instruction
0528:         	trap_io_ext:
              	
              		; Input or output?
0528: 0F      		rrca
0529: DA9E05  		jp	c,trap_io_ex_out
              		
              		; Extended input instruction
              		; INI-class?
052C: 0F      		rrca
052D: DAF805  		jp	c,trap_io_inx
              		
              		; Left or right column
0530: 0F      		rrca
0531: DA5B05  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
0534: 0F      		rrca
0535: DA4A05  		jp	c,1$
              		
              		; B or H?
0538: 0F      		rrca
0539: DA4305  		jp	c,2$
              		
              		; It's B
053C: CD1D0A  		call	in_handle
053F: 47      		ld	b,a
0540: C38505  		jp	90$
              		
              		; It's H	
0543: CD1D0A  	2$:	call	in_handle
0546: 67      		ld	h,a
0547: C38505  		jp	90$
              	
              		; D or 0?
054A: 0F      	1$:	rrca
054B: DA5505  		jp	c,3$
              	
              		; It's D
054E: CD1D0A  		call	in_handle
0551: 57      		ld	d,a
0552: C38505  		jp	90$
              		
              		; It's 0
0555: CD1D0A  	3$:	call	in_handle
0558: C38505  		jp	90$
              		
              		
              		; Right column
              		; C, E, L, or A?
055B: 0F      	0$:	rrca
055C: DA7105  		jp	c,4$
              		
              		; C or L?
055F: 0F      		rrca
0560: DA6A05  		jp	c,5$
              		
              		; It's C
0563: CD1D0A  		call	in_handle
0566: 4F      		ld	c,a
0567: C38505  		jp	90$
              	
              		; It's L
056A: CD1D0A  	5$:	call	in_handle
056D: 6F      		ld	l,a
056E: C38505  		jp	90$
              		
              		; E or A?
0571: 0F      	4$:	rrca
0572: DA7C05  		jp	c,6$
              		
              		; It's E
0575: CD1D0A  		call	in_handle
0578: 5F      		ld	e,a
0579: C38505  		jp	90$
              	
              		; It's A
057C: CD1D0A  	6$:	call	in_handle
057F: 32FF6F  		ld	(trap_a_value),a
0582: C38505  		jp	90$
              		
              		; Extended IN instructions require special flag states
              		; lets set them and return
0585: E5      	90$:	push	hl
0586: 21FE6F  		ld	hl,trap_f_value
0589: CB46    		bit	0,(hl)
058B: E1      		pop	hl
              		
              		; If it's zero, we don't need the carry flag
058C: CA9705  		jp	z,91$ 
              		
              		; Update flags and persist carry flag
058F: B7      		or	a
0590: 37      		scf
0591: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Do trap restore
0594: C3E506  		jp	trap_restore
              		
              		; Update flags and reset carry flag
0597: B7      	91$:	or	a
0598: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Do trap restore
059B: C3E506  		jp	trap_restore
              		
              	; Extended output instruction
059E:         	trap_io_ex_out:
              	
              		; OUTI-class?
059E: 0F      		rrca
059F: DA6E06  		jp	c,trap_io_outx
              		
              		; Left or right column?
05A2: 0F      		rrca
05A3: DACE05  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
05A6: 0F      		rrca
05A7: DABC05  		jp	c,1$
              		
              		; B or H?
05AA: 0F      		rrca
05AB: DAB505  		jp	c,2$
              		
              		; It's B
05AE: 78      		ld	a,b
05AF: CD430A  		call	out_handle
05B2: C3E406  		jp	trap_continue
              		
              		; It's H	
05B5: 7C      	2$:	ld	a,h
05B6: CD430A  		call	out_handle
05B9: C3E406  		jp	trap_continue
              	
              		; D or 0?
05BC: 0F      	1$:	rrca
05BD: DAC705  		jp	c,3$
              	
              		; It's D
05C0: 7A      		ld	a,d
05C1: CD430A  		call	out_handle
05C4: C3E406  		jp	trap_continue
              		
              		; It's 0
05C7: AF      	3$:	xor	a
05C8: CD430A  		call	out_handle
05CB: C3E406  		jp	trap_continue
              		
              		
              		; Right column
              		; C, E, L, or A?
05CE: 0F      	0$:	rrca
05CF: DAE405  		jp	c,4$
              		
              		; C or L?
05D2: 0F      		rrca
05D3: DADD05  		jp	c,5$
              		
              		; It's C
05D6: 79      		ld	a,c
05D7: CD430A  		call	out_handle
05DA: C3E406  		jp	trap_continue
              	
              		; It's L
05DD: 7D      	5$:	ld	a,l
05DE: CD430A  		call	out_handle
05E1: C3E406  		jp	trap_continue
              		
              		; E or A?
05E4: 0F      	4$:	rrca
05E5: DAEF05  		jp	c,6$
              		
              		; It's E
05E8: 7B      		ld	a,e
05E9: CD430A  		call	out_handle
05EC: C3E406  		jp	trap_continue
              	
              		; It's A
05EF: 3AFF6F  	6$:	ld	a,(trap_a_value)
05F2: CD430A  		call	out_handle
05F5: C3E406  		jp	trap_continue
              	
              	
              		; INX class instructions
              		; The CPU should handle the differences between INX and INXR
05F8:         	trap_io_inx:
              		; Left or right column?
05F8: 0F      		rrca
05F9: DA3506  		jp	c,trap_io_ind
              		
              		; Left column, it's 'I' class
05FC: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
05FD: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
05FE: 7C      		ld	a,h
05FF: 07      		rlca
0600: DA1306  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0603: 07      		rlca
0604: DA0D06  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0607: 3AD20E  		ld	a,(zmm_bnk0_state)
060A: C32006  		jp	3$
              		
              		; 0x4000 - 0x7FFF
060D: 3AD30E  	1$:	ld	a,(zmm_bnk1_state)
0610: C32006  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0613: 07      	0$:	rlca
0614: DA1D06  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
0617: 3AD40E  		ld	a,(zmm_bnk2_state)
061A: C32006  		jp	3$
              	
              		; 0xC000 - 0xFFFF
061D: 3AD50E  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0620: E67F    	3$:	and	0b01111111
0622: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0624: 3EC0    		ld	a,0b11000000
0626: B4      		or	h
0627: 67      		ld	h,a
              		
              		; Do the input
0628: CD1D0A  		call	in_handle
062B: 77      		ld	(hl),a
              		
              		; Fix banks
062C: 3AD50E  		ld	a,(zmm_bnk3_state)
062F: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0631: E1      		pop	hl
0632: C3E406  		jp	trap_continue
              		
              		; Right column, it's 'D' class
0635:         	trap_io_ind:
0635: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0636: 23      		inc	hl	; Increment to reverse 'D' class instruction
0637: 7C      		ld	a,h
0638: 07      		rlca
0639: DA4C06  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
063C: 07      		rlca
063D: DA4606  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0640: 3AD20E  		ld	a,(zmm_bnk0_state)
0643: C35906  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0646: 3AD30E  	1$:	ld	a,(zmm_bnk1_state)
0649: C35906  		jp	3$
              			
              		; 0x8000 - 0xFFFF
064C: 07      	0$:	rlca
064D: DA5606  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
0650: 3AD40E  		ld	a,(zmm_bnk2_state)
0653: C35906  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0656: 3AD50E  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0659: E67F    	3$:	and	0b01111111
065B: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
065D: 3EC0    		ld	a,0b11000000
065F: B4      		or	h
0660: 67      		ld	h,a
              		
              		; Do the input
0661: CD1D0A  		call	in_handle
0664: 77      		ld	(hl),a
              		
              		; Fix banks
0665: 3AD50E  		ld	a,(zmm_bnk3_state)
0668: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
066A: E1      		pop	hl
066B: C3E406  		jp	trap_continue
              	
              		; OUTX-class instructions
              		; The CPU should handle the differences between OUTX and OTXR
066E:         	trap_io_outx:
              	
              		; Left or right column?
066E: 0F      		rrca
066F: DAAB06  		jp	c,trap_io_outd
              		
              		; Left column, it's 'I' class
0672: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0673: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
0674: 7C      		ld	a,h
0675: 07      		rlca
0676: DA8906  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0679: 07      		rlca
067A: DA8306  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
067D: 3AD20E  		ld	a,(zmm_bnk0_state)
0680: C39606  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0683: 3AD30E  	1$:	ld	a,(zmm_bnk1_state)
0686: C39606  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0689: 07      	0$:	rlca
068A: DA9306  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
068D: 3AD40E  		ld	a,(zmm_bnk2_state)
0690: C39606  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0693: 3AD50E  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0696: E67F    	3$:	and	0b01111111
0698: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
069A: 3EC0    		ld	a,0b11000000
069C: B4      		or	h
069D: 67      		ld	h,a
              		
              		; Do the output
069E: 7E      		ld	a,(hl)
069F: CD430A  		call	out_handle
              		
              		; Fix banks
06A2: 3AD50E  		ld	a,(zmm_bnk3_state)
06A5: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
06A7: E1      		pop	hl
              		
06A8: C3E406  		jp	trap_continue
              		
              		; Right column, it's 'D' class
06AB:         	trap_io_outd:
06AB: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
06AC: 23      		inc	hl	; Increment to reverse 'D' class instruction
06AD: 7C      		ld	a,h
06AE: 07      		rlca
06AF: DAC206  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
06B2: 07      		rlca
06B3: DABC06  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
06B6: 3AD20E  		ld	a,(zmm_bnk0_state)
06B9: C3CF06  		jp	3$
              		
              		; 0x4000 - 0x7FFF
06BC: 3AD30E  	1$:	ld	a,(zmm_bnk1_state)
06BF: C3CF06  		jp	3$
              			
              		; 0x8000 - 0xFFFF
06C2: 07      	0$:	rlca
06C3: DACC06  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
06C6: 3AD40E  		ld	a,(zmm_bnk2_state)
06C9: C3CF06  		jp	3$
              	
              		; 0xC000 - 0xFFFF
06CC: 3AD50E  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
06CF: E67F    	3$:	and	0b01111111
06D1: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
06D3: 3EC0    		ld	a,0b11000000
06D5: B4      		or	h
06D6: 67      		ld	h,a
              		
              		; Do the output
06D7: 7E      		ld	a,(hl)
06D8: CD430A  		call	out_handle
              		
              		; Fix banks
06DB: 3AD50E  		ld	a,(zmm_bnk3_state)
06DE: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
06E0: E1      		pop	hl
06E1: C3E406  		jp	trap_continue
              	
              		
              	; Continue execution
06E4:         	trap_continue:
              		; Restore AF
06E4: F1      		pop	af
              		
              		; Restore stack and return
              		; Maybe invoke the debugger as well
06E5:         	trap_restore:
              		
              		; Reset trap state
06E5:         	trap_res_flag:
06E5: 00      		nop
06E6: 00      		nop
06E7: 00      		nop
06E8: D337    		out	(zmm_trap),a
              		
              		; Restore old SP
06EA: ED7B940F		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
06EE: 00      		nop
06EF: ED45    		retn
              		
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize trap handling stuff
              	;
              	; Returns nothing
              	; Uses: AF, HL
06F1:         	trap_init:
              		; Install trap vector
06F1: 3EC3    		ld	a,0xC3
06F3: 326600  		ld	(nmi_address),a
06F6: 21FB04  		ld	hl,trap_entry
06F9: 226700  		ld	(nmi_vector),hl
              		
06FC: C9      		ret
              		
              		
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value of untrapped SP value
0F94:         	trap_sp_value:
0F94: 0000    		defs	2
              	#include "IRQ.asm"
              	;
              	;********************************************************************
              	;*
              	;*             I N T E R R U P T   M A N A G E M E N T
              	;* 
              	;*    Manages "real" system interrupts on the host hardware.
              	;*    Also deals with mocking interrupts to the virtual machine
              	;*    if it is needed.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize interrupt stuff
              	;
              	; Returns nothing
              	; Uses: AF
06FD:         	irq_init:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06FD: 3E07    		ld	a,7		; AY register = 7
06FF: D341    		out	(nabu_ay_latch),a
0701: DB40    		in	a,(nabu_ay_data)
0703: E63F    		and	0x3F
0705: F640    		or	0x40
0707: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off all interrupts
0709: 3E0E    		ld	a,14		; AY register = 14	
070B: D341    		out	(nabu_ay_latch),a
070D: AF      		xor	a
070E: D340    		out	(nabu_ay_data),a
0710: 32960F  		ld	(irq_mask_state),a
              		
              		; Return
0713: C9      		ret
              		
              		
              	; Turns on the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
0714:         	irq_vdp_on:
0714: 3A960F  		ld	a,(irq_mask_state)
0717: F610    		or	0b00010000
0719: 32960F  		ld	(irq_mask_state),a
              		
071C: C37F07  		jp	irq_restore
              		
              	; Turns off the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
071F:         	irq_vdp_off:
071F: 3A960F  		ld	a,(irq_mask_state)
0722: E6EF    		and	~0b00010000
0724: 32960F  		ld	(irq_mask_state),a
              		
0727: C37F07  		jp	irq_restore
              		
              	; Turns on the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
072A:         	irq_keyb_on:
072A: 3A960F  		ld	a,(irq_mask_state)
072D: F620    		or	0b00100000
072F: 32960F  		ld	(irq_mask_state),a
              		
0732: C37F07  		jp	irq_restore
              		
              	; Turns off the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
0735:         	irq_keyb_off:
0735: 3A960F  		ld	a,(irq_mask_state)
0738: E6DF    		and	~0b00100000
073A: 32960F  		ld	(irq_mask_state),a
              		
073D: C37F07  		jp	irq_restore
              	
              	; Turns on the HCCA output
              	;
              	; Returns nothing
              	; Uses: AF
0740:         	irq_hcca_o_on:
0740: 3A960F  		ld	a,(irq_mask_state)
0743: F640    		or	0b01000000
0745: 32960F  		ld	(irq_mask_state),a
              		
0748: C37F07  		jp	irq_restore
              		
              	; Turns off the HCCA output
              	;
              	; Returns nothing
              	; Uses: AF
074B:         	irq_hcca_o_off:
074B: 3A960F  		ld	a,(irq_mask_state)
074E: E6BF    		and	~0b01000000
0750: 32960F  		ld	(irq_mask_state),a
              		
0753: C37F07  		jp	irq_restore
              		
              	; Turns on the HCCA input
              	;
              	; Returns nothing
              	; Uses: AF
0756:         	irq_hcca_i_on:
0756: 3A960F  		ld	a,(irq_mask_state)
0759: F680    		or	0b10000000
075B: 32960F  		ld	(irq_mask_state),a
              		
075E: C37F07  		jp	irq_restore
              		
              	; Turns off the HCCA input
              	;
              	; Returns nothing
              	; Uses: AF
0761:         	irq_hcca_i_off:
0761: 3A960F  		ld	a,(irq_mask_state)
0764: E67F    		and	~0b10000000
0766: 32960F  		ld	(irq_mask_state),a
              		
0769: C37F07  		jp	irq_restore
              		
              	; Returns the IRQ status byte
              	;
              	; Returns A = IRQ status
              	; Uses: AF
076C:         	irq_status:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
076C: 3E07    		ld	a,7		; AY register = 7
076E: D341    		out	(nabu_ay_latch),a
0770: DB40    		in	a,(nabu_ay_data)
0772: E63F    		and	0x3F
0774: F640    		or	0x40
0776: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
0778: 3E0F    		ld	a,15		; AY register = 15	
077A: D341    		out	(nabu_ay_latch),a
077C: DB40    		in	a,(nabu_ay_data)
077E: C9      		ret
              		
              	; Restore the IRQ mask from 
              	;
              	; Returns nothing
              	; Uses: AF
077F:         	irq_restore:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
077F: 3E07    		ld	a,7		; AY register = 7
0781: D341    		out	(nabu_ay_latch),a
0783: DB40    		in	a,(nabu_ay_data)
0785: E63F    		and	0x3F
0787: F640    		or	0x40
0789: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
078B: 3E0E    		ld	a,14		; AY register = 14	
078D: D341    		out	(nabu_ay_latch),a
078F: 3A960F  		ld	a,(irq_mask_state)
0792: D340    		out	(nabu_ay_data),a
0794: C9      		ret
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value interrupt mask
0F96:         	irq_mask_state:
0F96: 00      		defs	1
              	#include "DEBUG.asm"
              	;
              	;**************************************************************
              	;*
              	;*        V I R T U A L   M A C H I N E   D E B U G G E R
              	;*
              	;*    Proves a machine-language monitor for debugging the
              	;*    virtual machine. Does standard monitor stuff.
              	;* 
              	;**************************************************************
              	
              	; ---------------------------
              	; ********  Debugger ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Handle for the debugger
0795:         	debug_handle:
              	
              		; Save machine context
0795: ED739A0F		ld	(debug_temp),sp
0799: 31B50F  		ld	sp,debug_state
              		
              		; Dump registers
079C: F5      		push	af
079D: C5      		push	bc
079E: D5      		push	de
079F: E5      		push	hl
07A0: D9      		exx
07A1: 08      		ex	af,af'
07A2: F5      		push	af
07A3: C5      		push	bc
07A4: D5      		push	de
07A5: E5      		push	hl
07A6: DDE5    		push	ix
07A8: FDE5    		push	iy
              		
07AA: ED7B9A0F		ld	sp,(debug_temp)
              		
              		; Check to see if we are skipping over stuff
07AE: 3A9E0F  		ld	a,(debug_f_over)
07B1: B7      		or	a
07B2: CAC507  		jp	z,0$
              		
              		; Check stack pointer
07B5: 2A940F  		ld	hl,(trap_sp_value)
07B8: ED5B9F0F		ld	de,(debug_over_sp)
07BC: ED52    		sbc	hl,de
07BE: C2A708  		jp	nz,debug_continue
              		
              		; Reset over flag
07C1: AF      		xor	a
07C2: 329E0F  		ld	(debug_f_over),a
              		
07C5:         	0$:
              		
              		; Debugger stuff starts here
              		; Populate register dump string
07C5: 01B50F  		ld	bc,debug_state
07C8: 21300B  		ld	hl,str_rdump_af
07CB: CDC908  		call	debug_rtohex
07CE: 21390B  		ld	hl,str_rdump_bc
07D1: CDC908  		call	debug_rtohex
07D4: 21420B  		ld	hl,str_rdump_de
07D7: CDC908  		call	debug_rtohex
07DA: 214B0B  		ld	hl,str_rdump_hl
07DD: CDC908  		call	debug_rtohex
07E0: 21580B  		ld	hl,str_rdump_aaf
07E3: CDC908  		call	debug_rtohex
07E6: 21610B  		ld	hl,str_rdump_abc
07E9: CDC908  		call	debug_rtohex
07EC: 216A0B  		ld	hl,str_rdump_ade
07EF: CDC908  		call	debug_rtohex
07F2: 21730B  		ld	hl,str_rdump_ahl
07F5: CDC908  		call	debug_rtohex
07F8: 21800B  		ld	hl,str_rdump_ix
07FB: CDC908  		call	debug_rtohex
07FE: 21890B  		ld	hl,str_rdump_iy
0801: CDC908  		call	debug_rtohex
              		
              		; Display stack pointer
0804: 2A940F  		ld	hl,(trap_sp_value)
0807: 23      		inc	hl
0808: 23      		inc	hl
0809: 7C      		ld	a,h
080A: CD6B09  		call	tohex
080D: ED53F60A		ld	(str_rdump_sp),de
0811: 7D      		ld	a,l
0812: CD6B09  		call	tohex
0815: ED53F80A		ld	(str_rdump_sp+2),de
              			
              		; Extract PC from capture area
0819: 2A940F  		ld	hl,(trap_sp_value)
081C: 7C      		ld	a,h
081D: E67F    		and	zmm_capt_res
081F: F670    		or	zmm_capt_set
0821: 67      		ld	h,a
0822: 7E      		ld	a,(hl)
0823: 329C0F  		ld	(debug_pc_state),a
0826: CD6B09  		call	tohex
0829: ED53EF0A		ld	(str_rdump_pc+2),de
082D: 23      		inc	hl
082E: 7C      		ld	a,h
082F: E67F    		and	zmm_capt_res
0831: F670    		or	zmm_capt_set
0833: 67      		ld	h,a
0834: 7E      		ld	a,(hl)
0835: 329D0F  		ld	(debug_pc_state+1),a
0838: CD6B09  		call	tohex
083B: ED53ED0A		ld	(str_rdump_pc),de
              		
              		; Display instruction
083F: 2A9C0F  		ld	hl,(debug_pc_state)
0842: CD6501  		call	mem_fvbyte
0845: CD6B09  		call	tohex
0848: ED53010B		ld	(str_rdump_isr),de
084C: 23      		inc	hl
084D: CD6501  		call	mem_fvbyte
0850: CD6B09  		call	tohex
0853: ED53030B		ld	(str_rdump_isr+2),de
0857: 23      		inc	hl
0858: CD6501  		call	mem_fvbyte
085B: CD6B09  		call	tohex
085E: ED53050B		ld	(str_rdump_isr+4),de
0862: 23      		inc	hl
0863: CD6501  		call	mem_fvbyte
0866: CD6B09  		call	tohex
0869: ED53070B		ld	(str_rdump_isr+6),de
              		
              		; Print
086D: 11E70A  		ld	de,str_rdump
0870: CD2909  		call	cpm_print
              		
              	; Query the user for an operation to perform
0873:         	debug_query:
0873: CD4F09  		call	cpm_getc
0876: 79      		ld	a,c
              		
              		; Exit?
0877: FE51    		cp	'Q'
0879: CA6309  		jp	z,cpm_exit
              		
              		; Over?
087C: FE4F    		cp	'O'
087E: CA8908  		jp	z,debug_over
              		
              		; Upper?
0881: FE55    		cp	'U'
0883: CA9708  		jp	z,debug_upper
              		
              		
              		; Ok, just continue then
0886: C3A708  		jp	debug_continue
              	
              	
              	;	ld	de,str_prompt
              	;	call	cpm_print
              	;	ld	de,input_buff
              	;	call	cpm_input
              	
              		
              	; Do not enter debugger until stack is equal to the original value
0889:         	debug_over:
0889: 2A940F  		ld	hl,(trap_sp_value)
088C: 229F0F  		ld	(debug_over_sp),hl
              		
088F: 3EFF    		ld	a,0xFF
0891: 329E0F  		ld	(debug_f_over),a
              		
0894: C3A708  		jp	debug_continue
              		
              	; Do not enter debugger until current function has been returned from
0897:         	debug_upper:
0897: 2A940F  		ld	hl,(trap_sp_value)
089A: 23      		inc	hl
089B: 23      		inc	hl
089C: 229F0F  		ld	(debug_over_sp),hl
              		
089F: 3EFF    		ld	a,0xFF
08A1: 329E0F  		ld	(debug_f_over),a
              		
08A4: C3A708  		jp	debug_continue	
              		
              	; Go back to the virutal machine
08A7:         	debug_continue:
              		
              		; Restore IRQ state
08A7: CD7F07  		call	irq_restore
              		
              		; Restore machine context
08AA: ED739A0F		ld	(debug_temp),sp
08AE: 31A10F  		ld	sp,debug_state-20
              		
              		; Restore registers
08B1: FDE1    		pop	iy
08B3: DDE1    		pop	ix
08B5: E1      		pop	hl
08B6: D1      		pop	de
08B7: C1      		pop	bc
08B8: F1      		pop	af
08B9: D9      		exx
08BA: 08      		ex	af,af'
08BB: E1      		pop	hl
08BC: D1      		pop	de
08BD: C1      		pop	bc
08BE: F1      		pop	af
              		
              		; Go back to trap handler
08BF: ED7B9A0F		ld	sp,(debug_temp)
08C3: C9      		ret
              	
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	
              	; Initalize the debugger
              	;
              	; Returns nothing
              	; Uses: AF
08C4:         	debug_init:
              		
              		; Reset flags
08C4: AF      		xor	a
08C5: 329E0F  		ld	(debug_f_over),a
              		
08C8: C9      		ret
              	
              	; Converts a register to hexadecimal
              	; BC = Address of register value
              	; HL = Address of hex string
              	;
              	; Returns BC=BC=2
              	; Uses: AF, BC, DE, HL
08C9:         	debug_rtohex:
08C9: 0B      		dec	bc
08CA: 0A      		ld	a,(bc)
08CB: C5      		push	bc
08CC: CD6B09  		call	tohex
08CF: C1      		pop	bc
08D0: 73      		ld	(hl),e
08D1: 23      		inc	hl
08D2: 72      		ld	(hl),d
08D3: 23      		inc	hl
08D4: 0B      		dec	bc
08D5: 0A      		ld	a,(bc)
08D6: C5      		push	bc
08D7: CD6B09  		call 	tohex
08DA: C1      		pop	bc
08DB: 73      		ld	(hl),e
08DC: 23      		inc	hl
08DD: 72      		ld	(hl),d
08DE: C9      		ret
              	
              	; Bind the debugger to the trap handler
              	; Any trap can now be used to invoke the machine language monitor
              	;
              	; Returns nothing
              	; Uses: A, HL
08DF:         	debug_bind:
              	
              		; Save previous binding
08DF: 3AE506  		ld	a,(trap_res_flag)
08E2: 2AE606  		ld	hl,(trap_res_flag+1)
08E5: 32970F  		ld	(debug_pbind),a
08E8: 22980F  		ld	(debug_pbind+1),hl
              		
              		; Bind debugger handle
08EB: 3ECD    		ld	a,0xCD
08ED: 219507  		ld	hl,debug_handle
08F0: 32E506  		ld	(trap_res_flag),a
08F3: 22E606  		ld	(trap_res_flag+1),hl
              		
08F6: C9      		ret
              		
              	; Unbind the debugger and allow traps to process normally
              	;
              	; Returns nothjing
              	; Uses: A, HL
08F7:         	debug_unbind:
              		
              		; Restore previous binding
08F7: 3A970F  		ld	a,(debug_pbind)
08FA: 2A980F  		ld	hl,(debug_pbind+1)
08FD: 32E506  		ld	(trap_res_flag),a
0900: 22E606  		ld	(trap_res_flag+1),hl
              		
0903: C9      		ret
              		
              		
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Register dump string
0AE7:         	str_rdump:
0AE7: 1E17    		defb	0x1E,0x17
0AE9: 50433A20		defb	'PC: '
0AED:         	str_rdump_pc:
0AED: 58585858		defb	'XXXX SP: '
0AF1: 2053503A	
0AF5: 20      	
0AF6:         	str_rdump_sp:
0AF6: 58585858		defb	'XXXX NEXT: '
0AFA: 204E4558	
0AFE: 543A20  	
0B01:         	str_rdump_isr:
0B01: 58585858		defb	'XXXXXXXX',0x0A,0x0D
0B05: 58585858	
0B09: 0A0D    	
              	
0B0B: 464C4147		defb	'FLAGS: '
0B0F: 533A20  	
0B12:         	str_rdump_flag:
0B12: 2D2D2D2D		defb	'-------- EI: '
0B16: 2D2D2D2D	
0B1A: 2045493A	
0B1E: 20      	
0B1F:         	str_rdump_ei:
0B1F: 2D20492F		defb	'- I/O: '
0B23: 4F3A20  	
0B26:         	str_rdump_io:
0B26: 2D0A0D  		defb	'-',0x0A,0x0D
              		
0B29: 523D2041		defb	'R= AF: '
0B2D: 463A20  	
0B30:         	str_rdump_af:
0B30: 58585858		defb	'XXXX BC: '
0B34: 2042433A	
0B38: 20      	
0B39:         	str_rdump_bc:
0B39: 58585858		defb	'XXXX DE: '
0B3D: 2044453A	
0B41: 20      	
0B42:         	str_rdump_de:
0B42: 58585858		defb	'XXXX HL: '
0B46: 20484C3A	
0B4A: 20      	
0B4B:         	str_rdump_hl:
0B4B: 58585858		defb	'XXXX',0x0A,0x0D
0B4F: 0A0D    	
              		
0B51: 583D2041		defb	'X= AF: '
0B55: 463A20  	
0B58:         	str_rdump_aaf:
0B58: 58585858		defb	'XXXX BC: '
0B5C: 2042433A	
0B60: 20      	
0B61:         	str_rdump_abc:
0B61: 58585858		defb	'XXXX DE: '
0B65: 2044453A	
0B69: 20      	
0B6A:         	str_rdump_ade:
0B6A: 58585858		defb	'XXXX HL: '
0B6E: 20484C3A	
0B72: 20      	
0B73:         	str_rdump_ahl:
0B73: 58585858		defb	'XXXX',0x0A,0x0D
0B77: 0A0D    	
              		
0B79: 453D2049		defb	'E= IX: '
0B7D: 583A20  	
0B80:         	str_rdump_ix:
0B80: 58585858		defb	'XXXX IY: '
0B84: 2049593A	
0B88: 20      	
0B89:         	str_rdump_iy:
0B89: 58585858		defb	'XXXX',0x0A,0x0D,'$'
0B8D: 0A0D24  	
              		
              	; Debug prompt
0B90:         	str_prompt
0B90: 0A0D2A24		defb	0x0A,0x0D,'*','$'
              		
              	; Input buffer
0B94:         	input_buff:
0B94: 28      		defb	40
0B95: 00000000		defs	41
0B99: 00...   	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Previous trap bind
0F97:         	debug_pbind:
0F97: 000000  		defs	3
              		
              	; General purpose memory register
              	; Usually used in context swaps
0F9A:         	debug_temp:
0F9A: 0000    		defs	2
              		
              	; Debug program counter value
0F9C:         	debug_pc_state:
0F9C: 0000    		defs	2
              		
              	; Debug skip over flag
0F9E:         	debug_f_over:
0F9E: 00      		defs	1
              		
              	; Debug skip over stack value
0F9F:         	debug_over_sp:
0F9F: 0000    		defs	2
              		
              	; Machine state
              	; IY	-20
              	; IX	-18
              	; 'HL	-16
              	; 'DE	-14
              	; 'BC	-12
              	; 'AF 	-10
              	; HL	-8
              	; DE	-6
              	; BC	-4
              	; AF	-2
              	; --- TOP ---
0FA1: 00000000		defs	20
0FA5: 00...   	
0FB5:         	debug_state:
              	
              	; --------------------------------
              	; ******** KRISYS Startup ********
              	; --------------------------------
              	
              	.area	_TEXT
              		
              		; KRISYS entry point
0904:         	kri_start:	
              		; Set up stack
0904: F3      		di
0905: 310070  		ld	sp,kri_stack
0908: 216309  		ld	hl,cpm_exit
090B: E5      		push	hl
              		
              		; Print "hello" splash
090C: 0E09    		ld	c,bdos_print
090E: 11BE0B  		ld	de,str_splash
0911: CD0500  		call	bdos
              		
              		; Initalize subcomponents
0914: CDFD06  		call	irq_init
0917: CDE401  		call	zmm_init
091A: CDF106  		call	trap_init
091D: CD0301  		call	mem_map_init
0920: CDF002  		call	res_init
0923: CDC408  		call 	debug_init
              		
              		; Start the core
0926: C38209  		jp	core_start
              		
              	; ------------------------------
              	; ******** CP/M Service ********
              	; ------------------------------
              		
              	; Print something to the CP/M console
              	; DE = Address of string to print
              	;
              	; Returns nothing
              	; Uses: All
0929:         	cpm_print:
              		; Save control register state
0929: 3AD10E  		ld	a,(zmm_ctrl_state)
092C: F5      		push	af
              		
              		; Go to real mode
092D: CD4B02  		call zmm_set_real
              		
              		; Do BDOS call
0930: 0E09    		ld	c,bdos_print
0932: CD0500  		call	bdos
              		
              		; Restore register
0935: F1      		pop	af
0936: 32D10E  		ld	(zmm_ctrl_state),a
0939: C33A02  		jp	zmm_ctrl_set
              		
              	; Gets a line of input from the console
              	; DE = Address of result
              	;
              	; Returns nothing
              	; Uses: All
093C:         	cpm_input:
              		; Save control register state
093C: 3AD10E  		ld	a,(zmm_ctrl_state)
093F: F5      		push	af
              		
              		; Go to real mode
0940: CD4B02  		call zmm_set_real
              		
              		; Do BDOS call
0943: 0E0A    		ld	c,bdos_input
0945: CD0500  		call	bdos
              		
              		; Restore register
0948: F1      		pop	af
0949: 32D10E  		ld	(zmm_ctrl_state),a
094C: C33A02  		jp	zmm_ctrl_set
              		
              	; Gets a character from the console
              	;
              	; Returns C = character returns
              	; Uses: All
094F:         	cpm_getc:
              		; Save control register state
094F: 3AD10E  		ld	a,(zmm_ctrl_state)
0952: F5      		push	af
              		
              		; Go to real mode
0953: CD4B02  		call zmm_set_real
              		
              		; Do BDOS call
0956: 0E01    		ld	c,bdos_con_in
0958: CD0500  		call	bdos
095B: 4F      		ld	c,a
              		
              		; Restore register
095C: F1      		pop	af
095D: 32D10E  		ld	(zmm_ctrl_state),a
0960: C33A02  		jp	zmm_ctrl_set
              		
              	; Go back to CP/M
              	;
              	; Does not return
              	; Uses: N/A
0963:         	cpm_exit:
0963: CD4B02  		call	zmm_set_real
0966: 0E00    		ld	c,bdos_exit
0968: CD0500  		call	bdos	
              		
              	; ----------------------
              	; ******** Misc ********
              	; ----------------------
              		
              	; Converts the value into an 8 bit hex number
              	; A = Number to convert
              	;
              	; Returns DE = result
              	; Uses: AF, DE
096B: 57      	tohex:	ld	d,a
096C: CD7609  		call	0$
096F: 5F      		ld	e,a
0970: 7A      		ld	a,d
0971: CD7A09  		call	1$
0974: 57      		ld	d,a
0975: C9      		ret
              		
0976: 1F      	0$:	rra
0977: 1F      		rra
0978: 1F      		rra
0979: 1F      		rra
097A: F6F0    	1$:	or	0xF0
097C: 27      		daa
097D: C6A0    		add	a,0xA0
097F: CE40    		adc	a,0x40
0981: C9      		ret
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0BBE:         	str_splash:
0BBE: 4944454E		defb	'IDENTITY KRISYS HYPERVISOR, CP/M EDT.',0x0A,0x0D
0BC2: 54495459	
0BC6: 204B5249	
0BCA: 53595320	
0BCE: 48595045	
0BD2: 52564953	
0BD6: 4F522C20	
0BDA: 43502F4D	
0BDE: 20454454	
0BE2: 2E0A0D  	
0BE5: 5645522E		defb	'VER. 0.0.1, GAVIN TERSTEEG 2024'
0BE9: 20302E30	
0BED: 2E312C20	
0BF1: 47415649	
0BF5: 4E205445	
0BF9: 52535445	
0BFD: 45472032	
0C01: 303234  	
              		
              	; Carriage return, line break
0C04:         	str_crlf:
0C04: 0A0D24  		defb	0x0A,0x0D,'$' 
              		
              	
              	; ---------------------------
              	; ******** Core Init ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Start of SG-1000 core
0982:         	core_start:
              	
              		; Try to find rom resource
0982: 11070C  		ld	de,str_rom
0985: CD9204  		call	res_locate
0988: B7      		or	a
0989: C28303  		jp	nz,res_missing
              		
              		; Open the resource
098C: CDA003  		call	res_open
              		
              		; Load resources into bankmap
098F: 21B50F  		ld	hl,bm_rom
0992: 010001  		ld	bc,256
0995: CDFA02  		call	res_load
              		
              		; Program the I/O map
0998: 110B0C  		ld	de,str_prgm
099B: CD2909  		call	cpm_print
              		
              		; Do input map
099E: CD4002  		call	zmm_set_virt
09A1: CD5602  		call	zmm_prgm_in
09A4: 21500C  		ld	hl,io_map_input
09A7: 110080  		ld	de,zmm_map
09AA: 010001  		ld	bc,256
09AD: EDB0    		ldir
              		
              		; Do output map
09AF: CD6102  		call	zmm_prgm_out
09B2: 21500D  		ld	hl,io_map_output
09B5: 110080  		ld	de,zmm_map
09B8: 010001  		ld	bc,256
09BB: EDB0    		ldir
              		
              		; Allocate free ram
09BD: 11240C  		ld	de,str_ram_alloc
09C0: CD2909  		call	cpm_print
              		
              		; Lower RAM
09C3: 1601    		ld	d,1
09C5: CD9D01  		call	mem_alloc
09C8: CDA402  		call	zmm_bnk2_set
              		
              		; Upper RAM
09CB: 1601    		ld	d,1
09CD: CD9D01  		call	mem_alloc
09D0: CDAA02  		call	zmm_bnk3_set
              		
              		; Set up interrupt modes
09D3: CD6C02  		call	zmm_irq_inter
09D6: CD8D02  		call	zmm_irq_off
09D9: CD1407  		call	irq_vdp_on
              		
              		; Mount ROM
09DC: 3AB50F  		ld	a,(bm_rom)
09DF: CD9802  		call	zmm_bnk0_set
09E2: CDB002  		call	zmm_bnk0_wp
09E5: 3AB60F  		ld	a,(bm_rom+1)
09E8: CD9E02  		call	zmm_bnk1_set
09EB: CDC002  		call	zmm_bnk1_wp
              		
              		; Bind debugger
              		; call	debug_bind
              		
              		; Start up VM
09EE: 11350C  		ld	de,str_vm_start
09F1: CD2909  		call	cpm_print
              	
09F4: CD4002  		call	zmm_set_virt
09F7: 210000  		ld	hl,0x0000
09FA: C30102  		jp	zmm_vm_start
              	
              	
              	; Remaps address space so all reads of the VDP address register results in a trap
              	;
              	; Returns nothing
              	; Uses: AF
09FD:         	sg_vdpr_trap:
09FD: CD5602  		call	zmm_prgm_in
0A00: 3E37    		ld	a,zmm_trap
              		; ld	(zmm_map+0x81),a
              		; ld	(zmm_map+0x83),a
              		; ld	(zmm_map+0x85),a
              		; ld	(zmm_map+0x87),a
              		; ld	(zmm_map+0x89),a
              		; ld	(zmm_map+0x8B),a
              		; ld	(zmm_map+0x8D),a
              		; ld	(zmm_map+0x8F),a
              		; ld	(zmm_map+0x91),a
              		; ld	(zmm_map+0x93),a
              		; ld	(zmm_map+0x95),a
              		; ld	(zmm_map+0x97),a
              		; ld	(zmm_map+0x99),a
              		; ld	(zmm_map+0x9B),a
              		; ld	(zmm_map+0x9D),a
              		; ld	(zmm_map+0x9F),a
              		; ld	(zmm_map+0xA1),a
              		; ld	(zmm_map+0xA3),a
              		; ld	(zmm_map+0xA5),a
              		; ld	(zmm_map+0xA7),a
              		; ld	(zmm_map+0xA9),a
              		; ld	(zmm_map+0xAB),a
              		; ld	(zmm_map+0xAD),a
              		; ld	(zmm_map+0xAF),a
              		; ld	(zmm_map+0xB1),a
              		; ld	(zmm_map+0xB3),a
              		; ld	(zmm_map+0xB5),a
              		; ld	(zmm_map+0xB7),a
              		; ld	(zmm_map+0xB9),a
              		; ld	(zmm_map+0xBB),a
              		; ld	(zmm_map+0xBD),a
0A02: 32BF80  		ld	(zmm_map+0xBF),a
0A05: C9      		ret
              		
              	; Untraps all VDP register read operations
              	;
              	; Returns nothing
              	; Uses: AF
0A06:         	sg_vdpr_untrap:
0A06: CD5602  		call	zmm_prgm_in
0A09: 3EA1    		ld	a,nabu_vdp_addr
              		; ld	(zmm_map+0x81),a
              		; ld	(zmm_map+0x83),a
              		; ld	(zmm_map+0x85),a
              		; ld	(zmm_map+0x87),a
              		; ld	(zmm_map+0x89),a
              		; ld	(zmm_map+0x8B),a
              		; ld	(zmm_map+0x8D),a
              		; ld	(zmm_map+0x8F),a
              		; ld	(zmm_map+0x91),a
              		; ld	(zmm_map+0x93),a
              		; ld	(zmm_map+0x95),a
              		; ld	(zmm_map+0x97),a
              		; ld	(zmm_map+0x99),a
              		; ld	(zmm_map+0x9B),a
              		; ld	(zmm_map+0x9D),a
              		; ld	(zmm_map+0x9F),a
              		; ld	(zmm_map+0xA1),a
              		; ld	(zmm_map+0xA3),a
              		; ld	(zmm_map+0xA5),a
              		; ld	(zmm_map+0xA7),a
              		; ld	(zmm_map+0xA9),a
              		; ld	(zmm_map+0xAB),a
              		; ld	(zmm_map+0xAD),a
              		; ld	(zmm_map+0xAF),a
              		; ld	(zmm_map+0xB1),a
              		; ld	(zmm_map+0xB3),a
              		; ld	(zmm_map+0xB5),a
              		; ld	(zmm_map+0xB7),a
              		; ld	(zmm_map+0xB9),a
              		; ld	(zmm_map+0xBB),a
              		; ld	(zmm_map+0xBD),a
0A0B: 32BF80  		ld	(zmm_map+0xBF),a
0A0E: C9      		ret
              		
              	; -----------------------------------
              	; ******** Interrupt Handler ********
              	; -----------------------------------
              		
              	.area	_TEXT
              		
              	; Handle "real" interrupts from devices (if needed)
              	; All registers except AF must remain unchanged!
0A0F:         	irq_handle:
0A0F: CD6C07  		call	irq_status
0A12: 0F      		rrca
0A13: D0      		ret	nc
              		
              		; Ok, we hit a VDP interrupt
0A14: CD1F07  		call	irq_vdp_off
0A17: CD8202  		call	zmm_irq_on
0A1A: C3FD09  		jp	sg_vdpr_trap
              		
              		
              	; -----------------------------
              	; ******** I/O Handler ********
              	; -----------------------------
              		
              	.area	_TEXT
              	
              	; Handle an IN instruction
              	; Inputted value should be returned in register A
              	; All registers except AF must remain unchanged!
0A1D:         	in_handle:
0A1D: DB33    		in	a,(zmm_addr_lo)
0A1F: 07      		rlca
0A20: DA2D0A  		jp	c,0$
              		
0A23: 07      		rlca
0A24: DA2A0A  		jp	c,1$
              		
              		; Device 0
0A27: C3400A  		jp	99$
              		
              		; Device 1
0A2A: C3400A  	1$:	jp	99$
              	
0A2D: 07      	0$:	rlca
0A2E: DA3D0A  		jp	c,2$
              		
              		; Device 2: VDP
0A31: CD060A  		call	sg_vdpr_untrap
0A34: CD8D02  		call	zmm_irq_off
0A37: CD1407  		call	irq_vdp_on
0A3A: DBA1    		in	a,(nabu_vdp_addr)
0A3C: C9      		ret
              		
              		; Device 3
0A3D: C3400A  	2$:	jp	99$
              		
              	
              		; Unknown device
0A40: 3EFF    	99$:	ld	a,0xFF
0A42: C9      		ret
              	
              	; Handle an OUT instruction
              	; A = Value outputted by virtual machine
              	; All registers except AF must remain unchanged!
0A43:         	out_handle:
0A43: C9      		ret
              		
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Resource strings
0C07:         	str_rom:
0C07: 524F4D00		defb	'ROM',0
              		
              	; Bootup strings
0C0B:         	str_prgm:
0C0B: 50524F47		defb	'PROGRAMMING VM I/O MAP',0x0A,0x0D,'$'
0C0F: 52414D4D	
0C13: 494E4720	
0C17: 564D2049	
0C1B: 2F4F204D	
0C1F: 41500A0D	
0C23: 24      	
              		
              	; Bootup strings
0C24:         	str_ram_alloc:
0C24: 414C4C4F		defb	'ALLOCATING RAM',0x0A,0x0D,'$'
0C28: 43415449	
0C2C: 4E472052	
0C30: 414D0A0D	
0C34: 24      	
              		
              	; Bootup strings
0C35:         	str_vm_start:
0C35: 53544152		defb	'STARTING VM NOW',0x0A,0x0D,'$'
0C39: 54494E47	
0C3D: 20564D20	
0C41: 4E4F570A	
0C45: 0D24    	
              		
              	; Debug string
0C47:         	str_debug:
0C47: 41203D20		defb 	'A = '
0C4B:         	str_debug_val:
0C4B: 58580A0D		defb	'XX',0x0A,0x0D,'$'
0C4F: 24      	
              	
              	
              	; ----------------------
              	; ******** Data ********
              	; ----------------------
              		
              	.area	_DATA
              	
0037:         	TRAP	equ	zmm_trap	; Trap Vector
00A0:         	_VDD	equ	nabu_vdp_data	; VDP Data
00A1:         	_VDA	equ	nabu_vdp_addr	; VDP Address
              	
              	; Virtual machine I/O maps
              	; Input map
0C50:         	io_map_input:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
0C50: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
0C54: 37...   	
0C60: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
0C64: 37...   	
0C70: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
0C74: 37...   	
0C80: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
0C84: 37...   	
0C90: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
0C94: 37...   	
0CA0: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
0CA4: 37...   	
0CB0: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
0CB4: 37...   	
0CC0: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
0CC4: 37...   	
0CD0: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x8*
0CD4: A0A1A0A1	
0CD8: A0A1A0A1	
0CDC: A0A1A0A1	
0CE0: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x9*
0CE4: A0A1A0A1	
0CE8: A0A1A0A1	
0CEC: A0A1A0A1	
0CF0: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xA*
0CF4: A0A1A0A1	
0CF8: A0A1A0A1	
0CFC: A0A1A0A1	
0D00: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xB*
0D04: A0A1A0A1	
0D08: A0A1A0A1	
0D0C: A0A1A0A1	
0D10: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
0D14: 37...   	
0D20: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
0D24: 37...   	
0D30: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
0D34: 37...   	
0D40: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
0D44: 37...   	
              	
              	; Output map
0D50:         	io_map_output:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
0D50: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
0D54: 37...   	
0D60: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
0D64: 37...   	
0D70: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
0D74: 37...   	
0D80: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
0D84: 37...   	
0D90: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
0D94: 37...   	
0DA0: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
0DA4: 37...   	
0DB0: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
0DB4: 37...   	
0DC0: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
0DC4: 37...   	
0DD0: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x8*
0DD4: A0A1A0A1	
0DD8: A0A1A0A1	
0DDC: A0A1A0A1	
0DE0: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x9*
0DE4: A0A1A0A1	
0DE8: A0A1A0A1	
0DEC: A0A1A0A1	
0DF0: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xA*
0DF4: A0A1A0A1	
0DF8: A0A1A0A1	
0DFC: A0A1A0A1	
0E00: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xB*
0E04: A0A1A0A1	
0E08: A0A1A0A1	
0E0C: A0A1A0A1	
0E10: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
0E14: 37...   	
0E20: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
0E24: 37...   	
0E30: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
0E34: 37...   	
0E40: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
0E44: 37...   	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
0FB5:         	bm_rom:
0FB5: 0000    		defs	2


; +++ segments +++

#CODE _TEXT    = $0100 =   256,  size = $0944 =  2372
#CODE _DATA    = $0A44 =  2628,  size = $040C =  1036
#DATA _BSS     = $0E50 =  3664,  size = $0167 =   359

; +++ global symbols +++

TRAP             = $0037 =    55  _DATA   KSG1000.asm:275
_BSS             = $0E50 =  3664  _BSS    KRISYS.asm:28 (unused)
_BSS_end         = $0FB7 =  4023  _BSS    KRISYS.asm:28
_BSS_size        = $0167 =   359  _BSS    KRISYS.asm:28 (unused)
_DATA            = $0A44 =  2628  _DATA   KRISYS.asm:27 (unused)
_DATA_end        = $0E50 =  3664  _DATA   KRISYS.asm:27
_DATA_size       = $040C =  1036  _DATA   KRISYS.asm:27 (unused)
_TEXT            = $0100 =   256  _TEXT   KRISYS.asm:26 (unused)
_TEXT_end        = $0A44 =  2628  _TEXT   KRISYS.asm:26
_TEXT_size       = $0944 =  2372  _TEXT   KRISYS.asm:26 (unused)
_VDA             = $00A1 =   161  _DATA   KSG1000.asm:277
_VDD             = $00A0 =   160  _DATA   KSG1000.asm:276
alloc_bank_map   = $0E51 =  3665  _BSS    MEMORY.asm:276
arg_size         = $0010 =    16  _BSS    RESOURCE.asm:17
banks_free       = $0E50 =  3664  _BSS    MEMORY.asm:270
bdos             = $0005 =     5  _TEXT   KRISYS.asm:49
bdos_con_in      = $0001 =     1  _TEXT   KRISYS.asm:51
bdos_con_out     = $0002 =     2  _TEXT   KRISYS.asm:52
bdos_exit        = $0000 =     0  _TEXT   KRISYS.asm:50
bdos_input       = $000A =    10  _TEXT   KRISYS.asm:54
bdos_open        = $000F =    15  _TEXT   KRISYS.asm:55
bdos_print       = $0009 =     9  _TEXT   KRISYS.asm:53
bdos_read        = $0014 =    20  _TEXT   KRISYS.asm:56
bios_set_dma     = $001A =    26  _TEXT   KRISYS.asm:57
bm_rom           = $0FB5 =  4021  _BSS    KSG1000.asm:327
core_start       = $0982 =  2434  _TEXT   KSG1000.asm:17
cpm_command      = $0080 =   128  _TEXT   KRISYS.asm:59
cpm_exit         = $0963 =  2403  _TEXT   KRISYS.asm:210
cpm_getc         = $094F =  2383  _TEXT   KRISYS.asm:188
cpm_input        = $093C =  2364  _TEXT   KRISYS.asm:167 (unused)
cpm_print        = $0929 =  2345  _TEXT   KRISYS.asm:145
debug_bind       = $08DF =  2271  _TEXT   DEBUG.asm:263 (unused)
debug_continue   = $08A7 =  2215  _TEXT   DEBUG.asm:185
debug_f_over     = $0F9E =  3998  _BSS    DEBUG.asm:375
debug_handle     = $0795 =  1941  _TEXT   DEBUG.asm:18
debug_init       = $08C4 =  2244  _TEXT   DEBUG.asm:224
debug_over       = $0889 =  2185  _TEXT   DEBUG.asm:163
debug_over_sp    = $0F9F =  3999  _BSS    DEBUG.asm:379
debug_pbind      = $0F97 =  3991  _BSS    DEBUG.asm:362
debug_pc_state   = $0F9C =  3996  _BSS    DEBUG.asm:371
debug_query      = $0873 =  2163  _TEXT   DEBUG.asm:135 (unused)
debug_rtohex     = $08C9 =  2249  _TEXT   DEBUG.asm:238
debug_state      = $0FB5 =  4021  _BSS    DEBUG.asm:395
debug_temp       = $0F9A =  3994  _BSS    DEBUG.asm:367
debug_unbind     = $08F7 =  2295  _TEXT   DEBUG.asm:283 (unused)
debug_upper      = $0897 =  2199  _TEXT   DEBUG.asm:173
in_handle        = $0A1D =  2589  _TEXT   KSG1000.asm:201
input_buff       = $0B94 =  2964  _DATA   DEBUG.asm:351 (unused)
io_map_input     = $0C50 =  3152  _DATA   KSG1000.asm:281
io_map_output    = $0D50 =  3408  _DATA   KSG1000.asm:301
irq_handle       = $0A0F =  2575  _TEXT   KSG1000.asm:181
irq_hcca_i_off   = $0761 =  1889  _TEXT   IRQ.asm:125 (unused)
irq_hcca_i_on    = $0756 =  1878  _TEXT   IRQ.asm:114 (unused)
irq_hcca_o_off   = $074B =  1867  _TEXT   IRQ.asm:103 (unused)
irq_hcca_o_on    = $0740 =  1856  _TEXT   IRQ.asm:92 (unused)
irq_init         = $06FD =  1789  _TEXT   IRQ.asm:22
irq_keyb_off     = $0735 =  1845  _TEXT   IRQ.asm:81 (unused)
irq_keyb_on      = $072A =  1834  _TEXT   IRQ.asm:70 (unused)
irq_mask_state   = $0F96 =  3990  _BSS    IRQ.asm:182
irq_restore      = $077F =  1919  _TEXT   IRQ.asm:157
irq_status       = $076C =  1900  _TEXT   IRQ.asm:136
irq_vdp_off      = $071F =  1823  _TEXT   IRQ.asm:59
irq_vdp_on       = $0714 =  1812  _TEXT   IRQ.asm:48
kri_stack        = $7000 = 28672  _TEXT   KRISYS.asm:91
kri_start        = $0904 =  2308  _TEXT   KRISYS.asm:113
mem_alloc        = $019D =   413  _TEXT   MEMORY.asm:168
mem_empty        = $01DB =   475  _TEXT   MEMORY.asm:242
mem_free         = $01BE =   446  _TEXT   MEMORY.asm:200
mem_free_all     = $01D0 =   464  _TEXT   MEMORY.asm:226 (unused)
mem_fvbyte       = $0165 =   357  _TEXT   MEMORY.asm:101
mem_getbank      = $0178 =   376  _TEXT   MEMORY.asm:128
mem_map_init     = $0103 =   259  _TEXT   MEMORY.asm:30
nabu_ay_data     = $0040 =    64  _TEXT   KRISYS.asm:85
nabu_ay_latch    = $0041 =    65  _TEXT   KRISYS.asm:86
nabu_nctl        = $0000 =     0  _TEXT   KRISYS.asm:84 (unused)
nabu_vdp_addr    = $00A1 =   161  _TEXT   KRISYS.asm:88
nabu_vdp_data    = $00A0 =   160  _TEXT   KRISYS.asm:87
nmi_address      = $0066 =   102  _TEXT   KRISYS.asm:80
nmi_vector       = $0067 =   103  _TEXT   KRISYS.asm:81
out_handle       = $0A43 =  2627  _TEXT   KSG1000.asm:236
res_argument     = $0ED6 =  3798  _BSS    RESOURCE.asm:480
res_bankmap      = $0F6C =  3948  _BSS    RESOURCE.asm:500
res_buffer       = $0EE9 =  3817  _BSS    RESOURCE.asm:488
res_current      = $0EE7 =  3815  _BSS    RESOURCE.asm:484
res_do_read      = $0F6B =  3947  _BSS    RESOURCE.asm:496
res_fcb          = $0F70 =  3952  _BSS    RESOURCE.asm:508
res_fcb_cr       = $0F90 =  3984  _BSS    RESOURCE.asm:518 (unused)
res_fcb_data     = $0F80 =  3968  _BSS    RESOURCE.asm:517 (unused)
res_fcb_drive    = $0F70 =  3952  _BSS    RESOURCE.asm:510
res_fcb_ex       = $0F7C =  3964  _BSS    RESOURCE.asm:513 (unused)
res_fcb_name     = $0F71 =  3953  _BSS    RESOURCE.asm:511
res_fcb_r0       = $0F91 =  3985  _BSS    RESOURCE.asm:519 (unused)
res_fcb_r1       = $0F92 =  3986  _BSS    RESOURCE.asm:520 (unused)
res_fcb_r2       = $0F93 =  3987  _BSS    RESOURCE.asm:521 (unused)
res_fcb_rc       = $0F7F =  3967  _BSS    RESOURCE.asm:516 (unused)
res_fcb_s1       = $0F7D =  3965  _BSS    RESOURCE.asm:514 (unused)
res_fcb_s2       = $0F7E =  3966  _BSS    RESOURCE.asm:515 (unused)
res_fcb_type     = $0F79 =  3961  _BSS    RESOURCE.asm:512
res_init         = $02F0 =   752  _TEXT   RESOURCE.asm:29
res_load         = $02FA =   762  _TEXT   RESOURCE.asm:47
res_locate       = $0492 =  1170  _TEXT   RESOURCE.asm:360
res_missing      = $0383 =   899  _TEXT   RESOURCE.asm:153
res_open         = $03A0 =   928  _TEXT   RESOURCE.asm:179
res_pointer      = $0F6E =  3950  _BSS    RESOURCE.asm:504
res_printzt      = $0483 =  1155  _TEXT   RESOURCE.asm:340
res_sectors      = $0F69 =  3945  _BSS    RESOURCE.asm:492
sg_vdpr_trap     = $09FD =  2557  _TEXT   KSG1000.asm:95
sg_vdpr_untrap   = $0A06 =  2566  _TEXT   KSG1000.asm:136
stack_size       = $0020 =    32          KRISYS.asm:31
str_arg_empty    = $0AA7 =  2727  _DATA   RESOURCE.asm:464
str_arg_fail     = $0ABE =  2750  _DATA   RESOURCE.asm:467
str_crlf         = $0C04 =  3076  _DATA   KRISYS.asm:254
str_debug        = $0C47 =  3143  _DATA   KSG1000.asm:263 (unused)
str_debug_val    = $0C4B =  3147  _DATA   KSG1000.asm:265 (unused)
str_load_a       = $0A97 =  2711  _DATA   RESOURCE.asm:457
str_load_b       = $0AA0 =  2720  _DATA   RESOURCE.asm:460
str_mem_empty    = $0A6F =  2671  _DATA   MEMORY.asm:260
str_mem_init     = $0A44 =  2628  _DATA   MEMORY.asm:254
str_mem_init_cnt = $0A69 =  2665  _DATA   MEMORY.asm:257
str_missing      = $0AD4 =  2772  _DATA   RESOURCE.asm:470
str_prgm         = $0C0B =  3083  _DATA   KSG1000.asm:251
str_prompt       = $0B90 =  2960  _DATA   DEBUG.asm:347 (unused)
str_ram_alloc    = $0C24 =  3108  _DATA   KSG1000.asm:255
str_rdump        = $0AE7 =  2791  _DATA   DEBUG.asm:302
str_rdump_aaf    = $0B58 =  2904  _DATA   DEBUG.asm:331
str_rdump_abc    = $0B61 =  2913  _DATA   DEBUG.asm:333
str_rdump_ade    = $0B6A =  2922  _DATA   DEBUG.asm:335
str_rdump_af     = $0B30 =  2864  _DATA   DEBUG.asm:321
str_rdump_ahl    = $0B73 =  2931  _DATA   DEBUG.asm:337
str_rdump_bc     = $0B39 =  2873  _DATA   DEBUG.asm:323
str_rdump_de     = $0B42 =  2882  _DATA   DEBUG.asm:325
str_rdump_ei     = $0B1F =  2847  _DATA   DEBUG.asm:315 (unused)
str_rdump_flag   = $0B12 =  2834  _DATA   DEBUG.asm:313 (unused)
str_rdump_hl     = $0B4B =  2891  _DATA   DEBUG.asm:327
str_rdump_io     = $0B26 =  2854  _DATA   DEBUG.asm:317 (unused)
str_rdump_isr    = $0B01 =  2817  _DATA   DEBUG.asm:309
str_rdump_ix     = $0B80 =  2944  _DATA   DEBUG.asm:341
str_rdump_iy     = $0B89 =  2953  _DATA   DEBUG.asm:343
str_rdump_pc     = $0AED =  2797  _DATA   DEBUG.asm:305
str_rdump_sp     = $0AF6 =  2806  _DATA   DEBUG.asm:307
str_rom          = $0C07 =  3079  _DATA   KSG1000.asm:247
str_splash       = $0BBE =  3006  _DATA   KRISYS.asm:249
str_vm_start     = $0C35 =  3125  _DATA   KSG1000.asm:259
str_zmm_init     = $0A85 =  2693  _DATA   ZMM.asm:308
tohex            = $096B =  2411  _TEXT   KRISYS.asm:224
trap_a_value     = $6FFF = 28671  _TEXT   KRISYS.asm:92
trap_continue    = $06E4 =  1764  _TEXT   TRAP.asm:476
trap_entry       = $04FB =  1275  _TEXT   TRAP.asm:19
trap_f_value     = $6FFE = 28670  _TEXT   KRISYS.asm:93
trap_init        = $06F1 =  1777  _TEXT   TRAP.asm:508
trap_io          = $050C =  1292  _TEXT   TRAP.asm:39 (unused)
trap_io_ex_out   = $059E =  1438  _TEXT   TRAP.asm:166
trap_io_ext      = $0528 =  1320  _TEXT   TRAP.asm:59
trap_io_ind      = $0635 =  1589  _TEXT   TRAP.asm:305
trap_io_inx      = $05F8 =  1528  _TEXT   TRAP.asm:246
trap_io_outd     = $06AB =  1707  _TEXT   TRAP.asm:421
trap_io_outx     = $066E =  1646  _TEXT   TRAP.asm:360
trap_res_flag    = $06E5 =  1765  _TEXT   TRAP.asm:485
trap_restore     = $06E5 =  1765  _TEXT   TRAP.asm:482
trap_sp_value    = $0F94 =  3988  _BSS    TRAP.asm:526
zmm_addr_hi      = $0032 =    50  _TEXT   KRISYS.asm:68 (unused)
zmm_addr_lo      = $0033 =    51  _TEXT   KRISYS.asm:69
zmm_bnk0         = $0030 =    48  _TEXT   KRISYS.asm:62
zmm_bnk0_set     = $0298 =   664  _TEXT   ZMM.asm:193
zmm_bnk0_state   = $0ED2 =  3794  _BSS    ZMM.asm:322
zmm_bnk0_we      = $02B8 =   696  _TEXT   ZMM.asm:242 (unused)
zmm_bnk0_wp      = $02B0 =   688  _TEXT   ZMM.asm:233
zmm_bnk1         = $0031 =    49  _TEXT   KRISYS.asm:63
zmm_bnk1_set     = $029E =   670  _TEXT   ZMM.asm:203
zmm_bnk1_state   = $0ED3 =  3795  _BSS    ZMM.asm:326
zmm_bnk1_we      = $02C8 =   712  _TEXT   ZMM.asm:260 (unused)
zmm_bnk1_wp      = $02C0 =   704  _TEXT   ZMM.asm:251
zmm_bnk2         = $0032 =    50  _TEXT   KRISYS.asm:64
zmm_bnk2_set     = $02A4 =   676  _TEXT   ZMM.asm:213
zmm_bnk2_state   = $0ED4 =  3796  _BSS    ZMM.asm:330
zmm_bnk2_we      = $02D8 =   728  _TEXT   ZMM.asm:278 (unused)
zmm_bnk2_wp      = $02D0 =   720  _TEXT   ZMM.asm:269 (unused)
zmm_bnk3         = $0033 =    51  _TEXT   KRISYS.asm:65
zmm_bnk3_set     = $02AA =   682  _TEXT   ZMM.asm:223
zmm_bnk3_state   = $0ED5 =  3797  _BSS    ZMM.asm:334
zmm_bnk3_we      = $02E8 =   744  _TEXT   ZMM.asm:296 (unused)
zmm_bnk3_wp      = $02E0 =   736  _TEXT   ZMM.asm:287 (unused)
zmm_capt_res     = $007F =   127  _TEXT   KRISYS.asm:77
zmm_capt_set     = $0070 =   112  _TEXT   KRISYS.asm:76
zmm_capture      = $7000 = 28672  _TEXT   KRISYS.asm:72
zmm_ctrl         = $0034 =    52  _TEXT   KRISYS.asm:66
zmm_ctrl_set     = $023A =   570  _TEXT   ZMM.asm:95
zmm_ctrl_state   = $0ED1 =  3793  _BSS    ZMM.asm:318
zmm_init         = $01E4 =   484  _TEXT   ZMM.asm:22
zmm_irq_inter    = $026C =   620  _TEXT   ZMM.asm:148
zmm_irq_normal   = $0277 =   631  _TEXT   ZMM.asm:159 (unused)
zmm_irq_off      = $028D =   653  _TEXT   ZMM.asm:181
zmm_irq_on       = $0282 =   642  _TEXT   ZMM.asm:170
zmm_isr          = $0030 =    48  _TEXT   KRISYS.asm:67
zmm_map          = $8000 = 32768  _TEXT   KRISYS.asm:73
zmm_prgm_in      = $0256 =   598  _TEXT   ZMM.asm:126
zmm_prgm_out     = $0261 =   609  _TEXT   ZMM.asm:137
zmm_set_real     = $024B =   587  _TEXT   ZMM.asm:115
zmm_set_virt     = $0240 =   576  _TEXT   ZMM.asm:104
zmm_top          = $C000 = 49152  _TEXT   KRISYS.asm:74
zmm_trap         = $0037 =    55  _TEXT   KRISYS.asm:70
zmm_vm_start     = $0201 =   513  _TEXT   ZMM.asm:44


total time: 0.0327 sec.
no errors
