              	; --------------------------------------
              	; zasm: assemble "KSG1000.asm"
              	; date: 2024-08-18 14:50:54
              	; --------------------------------------


              	;
              	;********************************************************************
              	;*
              	;*        K R I S Y S   S G 1 0 0 0   C O R E
              	;*
              	;********************************************************************
              	
              	#include "KRISYS.asm"
              	;
              	;********************************************************************
              	;*
              	;*              I D E N T I T Y   K R I S Y S
              	;*
              	;*      The [K]lunkly [R]emapper / [I]nterpreter [SYS]tem
              	;*
              	;*             Written by Gavin Tersteeg, 2024
              	;*              Copyleft, All Wrongs Reserved
              	;*
              	;*
              	;*   This piece of software allows different classic Z80 systems
              	;*   to run as "virtual machines" on top of existing hardware by
              	;*   use of a ZMM (Z80 MEGAMAPPER). It does this by remapping RAM
              	;*   and I/O address space ot match that of it's target system.
              	;*   Anything that can't be emulated by simple remapping is instead
              	;*   interpreted using I/O traps. 
              	;*
              	;*   This allows virtualized machines to run with an acceptable
              	;*   degree of speed and accuracy. While the ZMM is still quite
              	;*   limited in what sort of hardware can be efficiently virtualized,
              	;*   anything that avoids MMIO or graphics hardware that isn't a VDP
              	;*   generally can be made to work.
              	;* 
              	;********************************************************************
              		
              	; ----------------------------
              	; ******** ZASM Setup ********
              	; ----------------------------
              	
0020:         	stack_size = 0x20
              	
              	#target BIN
0100:         	#code	_TEXT,0x0100	; Setup to run as a CP/M executable
069B:         	#code	_DATA,_TEXT_end
0778:         	#data	_BSS,_DATA_end
              	
              	; Make sure w don't overrun available memory
              	#assert	_BSS_end < (zmm_capture-stack_size)
              	
              	.area	_TEXT
0100: C32F06  		jp	kri_start
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
              	; CP/M Stuff
0005:         	bdos		equ	0x0005
0000:         	bdos_exit	equ	0x00
0001:         	bdos_con_in	equ	0x01
0002:         	bdos_con_out	equ	0x02
0009:         	bdos_print	equ	0x09
000F:         	bdos_open	equ	0x0F
0014:         	bdos_read	equ	0x14
001A:         	bios_set_dma	equ	0x1A
              	
0080:         	cpm_command	equ	0x0080
              	
              	; Z80 MEGAMAPPER Stuff
0030:         	zmm_bnk0	equ	0x30	; 16K Bank 0 (0x0000 - 0x3FFF)
0031:         	zmm_bnk1	equ	0x31	; 16K Bank 1 (0x4000 - 0x7FFF)
0032:         	zmm_bnk2	equ	0x32	; 16K Bank 2 (0x8000 - 0xBFFF)
0033:         	zmm_bnk3	equ	0x33	; 16K Bank 3 (0xC000 - 0xFFFF)
0034:         	zmm_ctrl	equ	0x34	; ZMM Control Register
0030:         	zmm_isr		equ	0x30	; ZMM Trapped Instruction Register
0032:         	zmm_addr_hi	equ	0x32	; ZMM Trap Address High
0033:         	zmm_addr_lo	equ	0x33	; ZMM Trap Address Low
0037:         	zmm_trap	equ	0x37 	; ZMM Trap Vector
              	
7000:         	zmm_capture	equ	0x7000
8000:         	zmm_map		equ	0x8000
C000:         	zmm_top		equ	0xC000
              	
0070:         	zmm_capt_set	equ	0b01110000
007F:         	zmm_capt_res	equ	0b01111111
              	
              	; General Z80 Stuff
0066:         	nmi_address	equ	0x0066
0067:         	nmi_vector	equ	nmi_address+1
              	
              	; NABU Specific Stuff
0000:         	nabu_nctl	equ	0x00	; NABU Control Register
0040:         	nabu_ay_data	equ	0x40	; AY-3-8910 Data Port
0041:         	nabu_at_latch	equ	0x41	; AY-3-8910 Latch Port
              	
              	; Stack / Trap Management
7000:         	kri_stack	equ	zmm_capture
6FFF:         	trap_a_value	equ	kri_stack-1
6FFE:         	trap_f_value	equ	kri_stack-2
              	
              	; -------------------------------------
              	; ******** Additional Includes ********
              	; -------------------------------------
              	
              	#include "MEMORY.asm"
              	;
              	;********************************************************************
              	;*
              	;*                    Z M M   M E M O R Y
              	;* 
              	;*    The ZMM can be configured to have different amounts
              	;*    of memory installed. Instead of dicking around with 
              	;*    on-board jumpers, KRISYS will simply check what banks
              	;*    are available on startup. Memory will be dynamically
              	;*    allocated as needed by the client process.
              	;*
              	;*    Memory can be assigned to specific owners in the code.
              	;*    Valid owner IDs range from 1 to 254. Owner 0 is reserved
              	;*    for unallocatable banks.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              		
              	; Initalize the memory map
              	; Each bank of the ZMM will be probed, and writable
              	; banks will be recorded on the allocated bank map
              	;
              	; Returns nothing
              	; Uses: AF, BC, DE, HL
0103:         	mem_map_init:
              		; Go to virtual mode
0103: CDCF01  		call	zmm_set_virt
              		
              		; Reset free bank counter
0106: 3E00    		ld	a,0
0108: 327807  		ld	(banks_free),a
              		
              		; Write tags to all banks
010B: 0600    		ld	b,0
010D: 78      	0$:	ld	a,b
010E: CD3902  		call	zmm_bnk3_set
0111: 3200C0  		ld	(zmm_top),a
0114: ED44    		neg
0116: 3201C0  		ld	(zmm_top+1),a
0119: 04      		inc	b
011A: F20D01  		jp	p,0$
              		
              		; Mark any banks that record correctly
011D: 0600    		ld	b,0
011F: 217907  		ld	hl,alloc_bank_map
0122: AF      	1$:	xor	a
0123: 77      		ld	(hl),a
0124: 78      		ld	a,b
0125: CD3902  		call	zmm_bnk3_set
0128: 3A00C0  		ld	a,(zmm_top)
012B: B8      		cp	b
012C: C24401  		jp	nz,2$
012F: 3A01C0  		ld	a,(zmm_top+1)
0132: 4F      		ld	c,a
0133: 78      		ld	a,b
0134: ED44    		neg
0136: B9      		cp	c
0137: C24401  		jp	nz,2$
              	
              		; Mark it
013A: 3EFF    		ld	a,0xFF
013C: 77      		ld	(hl),a
013D: 3A7807  		ld	a,(banks_free)
0140: 3C      		inc	a
0141: 327807  		ld	(banks_free),a
              		
              		; Next
0144: 23      	2$:	inc	hl
0145: 04      		inc	b
0146: F22201  		jp	p,1$
              		
              		; Disable virtual mode
0149: CDDA01  		call	zmm_set_real
              		
              		; Print out result
014C: 3A7807  		ld	a,(banks_free)
014F: CD6606  		call	tohex
0152: ED53C006		ld	(str_mem_init_cnt),de
0156: 119B06  		ld	de,str_mem_init
0159: CD4E06  		call	cpm_print
              		
              		; Do we actually have an acceptable amount of memory?
015C: 3A7807  		ld	a,(banks_free)
015F: 3D      		dec	a
0160: 3D      		dec	a
0161: FAA301  		jp	m,mem_empty
              		
              		; We do, return
0164: C9      		ret
              		
              	; Allocates a bank of memory
              	; Will produce an error if no banks are available,
              	; check (banks_free) to avoid
              	; D = Owner ID (1-254)
              	;
              	; Returns A = Bank #
              	; Uses: AF, BC, HL
0165:         	mem_alloc:
              		; Check and decrement free memory
0165: 3A7807  		ld	a,(banks_free)
0168: 3D      		dec	a
0169: 327807  		ld	(banks_free),a
016C: FAA301  		jp	m,mem_empty
              		
              		; Look for the first free bank
016F: 217907  		ld	hl,alloc_bank_map
0172: 018000  		ld	bc,0x0080
0175: 3EFF    		ld	a,0xFF
0177: EDB1    		cpir
              		
              		; Make sure we found something
0179: C2A301  		jp	nz,mem_empty
              		
              		; Save and exit
017C: 2B      		dec	hl
017D: 72      		ld	(hl),d
017E: 017907  		ld	bc,alloc_bank_map
0181: B7      		or	a
0182: ED42    		sbc	hl,bc
0184: 6F      		ld	l,a
0185: C9      		ret
              		
              	; Frees a bank of memory
              	; Safe to use on banks that are not free / not owned
              	; A = Bank #
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
0186:         	mem_free:
              		; Find location in memory
0186: 0600    		ld	b,0
0188: 4F      		ld	c,a
0189: 217907  		ld	hl,alloc_bank_map
018C: 09      		add	hl,bc
              		
              		; Check owner
018D: 7E      		ld	a,(hl)
018E: BA      		cp	d
018F: C0      		ret	nz
              		
              		; Free bank
0190: 3EFF    		ld	a,0xFF
0192: 77      		ld	(hl),a
              		
              		; Increment banks free
0193: 217807  		ld	hl,banks_free
0196: 34      		inc	(hl)
0197: C9      		ret
              		
              	; Free all banks by owner
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
0198:         	mem_free_all:
              		; Free a bank
0198: AF      		xor	a
0199: F5      	0$:	push	af
019A: CD8601  		call	mem_free
019D: F1      		pop	af
              		
              		; Next bank
019E: 3C      		inc	a
019F: F29901  		jp	p,0$
01A2: C9      		ret
              		
              	; Error out if empty
              	;
              	; Does not return
              	; Uses: N/A
01A3:         	mem_empty:
01A3: 11C606  		ld	de,str_mem_empty
01A6: CD4E06  		call	cpm_print
01A9: C36106  		jp	cpm_exit
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
069B:         	str_mem_init:
069B: 494E4954		defb	'INITIALIZED MEMORY MAP',0x0A,0x0D
069F: 49414C49	
06A3: 5A454420	
06A7: 4D454D4F	
06AB: 5259204D	
06AF: 41500A0D	
06B3: 42414E4B		defb	'BANK COUNT = '
06B7: 20434F55	
06BB: 4E54203D	
06BF: 20      	
06C0:         	str_mem_init_cnt:
06C0: 5858480A		defb	'XXH',0x0A,0x0D,'$'
06C4: 0D24    	
              		
06C6:         	str_mem_empty:
06C6: 494E5355		defb	'INSUFFICIENT MEMORY',0x0A,0x0D,'$'
06CA: 46464943	
06CE: 49454E54	
06D2: 204D454D	
06D6: 4F52590A	
06DA: 0D24    	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Free bank count
0778:         	banks_free:
0778: 00      		defs	1
              	
              	; Allocated bank map
              	; This 128 byte table keeps track of every single 16K bank
              	; that exists on the ZMM. Populated on startup
0779:         	alloc_bank_map:
0779: 00000000		defs	128
077D: 00...   	
              	#include "ZMM.asm"
              	;
              	;********************************************************************
              	;*
              	;*                  Z M M   M A N A G E M E N T
              	;* 
              	;*    These routines are used to manage the state of the ZMM.
              	;*    This includes the setting of the registers as well as setting
              	;*    up trap and interrupt stuff.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize ZMM and reset registers
              	;
              	; Returns nothing
              	; Uses: AF
01AC:         	zmm_init:
              		; Zero out control register
01AC: 3E00    		ld	a,0
01AE: 32F907  		ld	(zmm_ctrl_state),a
01B1: 32FA07  		ld	(zmm_bnk0_state),a
01B4: 32FB07  		ld	(zmm_bnk1_state),a
01B7: 32FC07  		ld	(zmm_bnk2_state),a
01BA: 32FD07  		ld	(zmm_bnk3_state),a
              		
              		; See if we can swing in and out of virtual mode
01BD: CDCF01  		call	zmm_set_virt
01C0: CDDA01  		call	zmm_set_real
              		
              		; Tell the user that the ZMM is read
01C3: 11DC06  		ld	de,str_zmm_init
01C6: C34E06  		jp	cpm_print
              		
              	; Set the ZMM control register to the recorded state
              	; (zmm_ctrl_state) = New value of ZMM control register
              	;
              	; Returns nothing
              	; Uses: AF
01C9:         	zmm_ctrl_set:
01C9: 3AF907  		ld	a,(zmm_ctrl_state)
01CC: D334    		out	(zmm_ctrl),a
01CE: C9      		ret
              		
              	; Go to virtual mode
              	;
              	; Returns nothing
              	; Uses: AF
01CF:         	zmm_set_virt:
01CF: 3AF907  		ld	a,(zmm_ctrl_state)
01D2: F601    		or	0b00000001
01D4: 32F907  		ld	(zmm_ctrl_state),a
01D7: D334    		out	(zmm_ctrl),a
01D9: C9      		ret
              		
              	; Go to real mode
              	;
              	; Returns nothing
              	; Uses: AF
01DA:         	zmm_set_real:
01DA: 3AF907  		ld	a,(zmm_ctrl_state)
01DD: E6FE    		and	0b11111110
01DF: 32F907  		ld	(zmm_ctrl_state),a
01E2: D334    		out	(zmm_ctrl),a
01E4: C9      		ret
              		
              	; Set program direction to "IN"
              	;
              	; Returns nothing
              	; Uses: AF
01E5:         	zmm_prgm_in:
01E5: 3AF907  		ld	a,(zmm_ctrl_state)
01E8: F602    		or	0b00000010
01EA: 32F907  		ld	(zmm_ctrl_state),a
01ED: D334    		out	(zmm_ctrl),a
01EF: C9      		ret
              		
              	; Set program direction to "OUT"
              	;
              	; Returns nothing
              	; Uses: AF
01F0:         	zmm_prgm_out:
01F0: 3AF907  		ld	a,(zmm_ctrl_state)
01F3: E6FD    		and	0b11111101
01F5: 32F907  		ld	(zmm_ctrl_state),a
01F8: D334    		out	(zmm_ctrl),a
01FA: C9      		ret
              		
              	; Turn on irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
01FB:         	zmm_irq_inter:
01FB: 3AF907  		ld	a,(zmm_ctrl_state)
01FE: F604    		or	0b00000100
0200: 32F907  		ld	(zmm_ctrl_state),a
0203: D334    		out	(zmm_ctrl),a
0205: C9      		ret
              		
              	; Turn off irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
0206:         	zmm_irq_normal:
0206: 3AF907  		ld	a,(zmm_ctrl_state)
0209: E6FB    		and	0b11111011
020B: 32F907  		ld	(zmm_ctrl_state),a
020E: D334    		out	(zmm_ctrl),a
0210: C9      		ret
              	
              	; Turn on force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
0211:         	zmm_irq_on:
0211: 3AF907  		ld	a,(zmm_ctrl_state)
0214: F608    		or	0b00001000
0216: 32F907  		ld	(zmm_ctrl_state),a
0219: D334    		out	(zmm_ctrl),a
021B: C9      		ret
              		
              	; Turn off force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
021C:         	zmm_irq_off:
021C: 3AF907  		ld	a,(zmm_ctrl_state)
021F: E6F7    		and	0b11110111
0221: 32F907  		ld	(zmm_ctrl_state),a
0224: D334    		out	(zmm_ctrl),a
0226: C9      		ret
              		
              	; Set bank 0
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses: AF, B
0227:         	zmm_bnk0_set:
0227: 32FA07  		ld	(zmm_bnk0_state),a
022A: D330    		out	(zmm_bnk0),a
022C: C9      		ret
              		
              	; Set bank 1
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
022D:         	zmm_bnk1_set:
022D: 32FB07  		ld	(zmm_bnk1_state),a
0230: D331    		out	(zmm_bnk1),a
0232: C9      		ret
              		
              	; Set bank 2
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
0233:         	zmm_bnk2_set:
0233: 32FC07  		ld	(zmm_bnk2_state),a
0236: D332    		out	(zmm_bnk2),a
0238: C9      		ret
              		
              	; Set bank 3
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
0239:         	zmm_bnk3_set:
0239: 32FD07  		ld	(zmm_bnk3_state),a
023C: D333    		out	(zmm_bnk3),a
023E: C9      		ret
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
06DC:         	str_zmm_init:
06DC: 494E4954		defb	'INITIALIZED ZMM',0x0A,0x0D,'$'
06E0: 49414C49	
06E4: 5A454420	
06E8: 5A4D4D0A	
06EC: 0D24    	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
07F9:         	zmm_ctrl_state:
07F9: 00      		defs	1
              		
              	; Bank 0 state
07FA:         	zmm_bnk0_state:
07FA: 00      		defs	1
              		
              	; Bank 1 state
07FB:         	zmm_bnk1_state:
07FB: 00      		defs	1
              		
              	; Bank 2 state
07FC:         	zmm_bnk2_state:
07FC: 00      		defs	1
              		
              	; Bank 3 state
07FD:         	zmm_bnk3_state:
07FD: 00      		defs	1
              		
              	#include "RESOURCE.asm"
              	;
              	;********************************************************************
              	;*
              	;*               R E S O U R C E   M A N A G E M E N T
              	;* 
              	;*    These routines handle obtaining use-supplied resources
              	;*    such as configurations, ROM images, and storage bindings.
              	;*    During startup, these resources will be loaded to build
              	;*    the virtual machine.
              	;*
              	;********************************************************************
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
0010:         	arg_size	equ 16
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize resources
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
023F:         	res_init:
              		; Start by zero-terminating string
023F: 218000  		ld	hl,cpm_command
0242: 4E      		ld	c,(hl)
0243: 0600    		ld	b,0
0245: 09      		add	hl,bc
0246: 23      		inc	hl
0247: 70      		ld	(hl),b
              		
0248: C9      		ret
              		
              	; Loads an open resource into a bankmap
              	; Bankmap will be zero-padded to fill requested number of records
              	; HL = Address of bankmap
              	; BC = Number of records (128 byte blocks) to load
              	;
              	; Returns nothing
              	; Uses: all
0249:         	res_load:
              		; Set read flag
0249: 3EFF    		ld	a,0xFF
024B: 32A208  		ld	(res_do_read),a
              	
              		; Save args
024E: 22A308  		ld	(res_bankmap),hl
0251: ED43A008		ld	(res_sectors),bc
              	
              		; Virtual mode should be off while we do this
0255: 3AF907  		ld	a,(zmm_ctrl_state)
0258: F5      		push	af
0259: CDDA01  		call	zmm_set_real
              		
              		; Do function call
025C: CD6B02  		call	0$
              		
              		; Reset bank 3
025F: 3AFD07  		ld	a,(zmm_bnk3_state)
0262: D333    		out	(zmm_bnk3),a
              		
              		; Restore register
0264: F1      		pop	af
0265: 32F907  		ld	(zmm_ctrl_state),a
0268: C3C901  		jp	zmm_ctrl_set
              		
              		; Allocate a new bank
026B: CD6501  	0$:	call	mem_alloc
026E: 2AA308  		ld	hl,(res_bankmap)
0271: 77      		ld	(hl),a
0272: 23      		inc	hl
0273: 22A308  		ld	(res_bankmap),hl
              		
              		; Set the bank in slot 3
0276: D333    		out	(zmm_bnk3),a
              		
              		; Set DMA address
0278: 112008  		ld	de,res_buffer
027B: 0E1A    		ld	c,bios_set_dma
027D: CD0500  		call	bdos
              		
              		; Set pointer	
0280: 2100C0  		ld	hl,zmm_top
0283: 22A508  		ld	(res_pointer),hl
              		
              		; We will be loading up to 128 records at a time here
0286: 0680    		ld	b,128
              		
              		; Do read operation
0288: C5      	1$:	push	bc
0289: 11A708  		ld	de,res_fcb
028C: 0E14    		ld	c,bdos_read
028E: 3AA208  		ld	a,(res_do_read)
0291: B7      		or	a
0292: C40500  		call	nz,bdos
              		
              		; Check file I/O result
0295: B7      		or	a
0296: C4BF02  		call	nz,50$
              		
              		; Go to virtual mode
0299: CDCF01  		call	zmm_set_virt
              		
              		; Copy record to bank
029C: 212008  		ld	hl,res_buffer
029F: ED5BA508		ld	de,(res_pointer)
02A3: 018000  		ld	bc,128
02A6: EDB0    		ldir
02A8: ED53A508		ld	(res_pointer),de
              		
              		; Back to real mode
02AC: CDDA01  		call	zmm_set_real 
              		
              		; Get BC back to restore sector counter
02AF: C1      		pop	bc
              		
              		; Decrement record count
02B0: 2AA008  		ld	hl,(res_sectors)
02B3: 2B      		dec	hl
02B4: 22A008  		ld	(res_sectors),hl
02B7: 7C      		ld	a,h
02B8: B5      		or	l
02B9: C8      		ret	z
              		
              		; Go get another sector
02BA: 10CC    		djnz	1$
02BC: C36B02  		jp	0$
              	
              		; Zero buffer and reset read flag
02BF: AF      	50$:	xor	a
02C0: 32A208  		ld	(res_do_read),a
              		
02C3: 212008  		ld	hl,res_buffer
02C6: 112108  		ld	de,res_buffer+1
02C9: 017F00  		ld	bc,128-1
02CC: 77      		ld	(hl),a
02CD: EDB0    		ldir
              	
02CF: C9      		ret
              		
              	; Opens a file based on the resource argument
              	; If the file cannot be opened, an error will be thrown
              	; (res_argument) = File to open
              	;
              	; Returns nothing
              	; Uses: all
02D0:         	res_open:
              		; Virtual mode should be off while we do this
02D0: 3AF907  		ld	a,(zmm_ctrl_state)
02D3: F5      		push	af
02D4: CDDA01  		call	zmm_set_real
              		
              		; Do function call
02D7: CDE102  		call	0$
              		
              		; Restore register
02DA: F1      		pop	af
02DB: 32F907  		ld	(zmm_ctrl_state),a
02DE: C3C901  		jp	zmm_ctrl_set
              		
              		; Let the user know we are loading stuff
02E1: 0E09    	0$:	ld	c,bdos_print
02E3: 11EE06  		ld	de,str_load_a
02E6: CD0500  		call	bdos
              		
              		; Print resource name
02E9: 210F08  		ld	hl,res_current
02EC: 5E      		ld	e,(hl)
02ED: 23      		inc	hl
02EE: 56      		ld	d,(hl)
02EF: CDB503  		call	res_printzt
              		
              		; Next string
02F2: 0E09    		ld	c,bdos_print
02F4: 11F706  		ld	de,str_load_b
02F7: CD0500  		call	bdos
              		
              		; Print file name
02FA: 11FE07  		ld	de,res_argument
02FD: CDB503  		call	res_printzt
              		
              		; CRLF
0300: 0E09    		ld	c,bdos_print
0302: 117107  		ld	de,str_crlf
0305: CD0500  		call	bdos
              		
              		; Detect if there is an argument
0308: 3AFE07  		ld	a,(res_argument)
030B: B7      		or	a
030C: C21A03  		jp	nz,1$
              		
              		; No argument, error!
030F: 0E09    		ld	c,bdos_print
0311: 11FE06  		ld	de,str_arg_empty
0314: CD0500  		call	bdos
0317: C36106  		jp	cpm_exit
              	
              		; Reset fields
031A: AF      	1$:	xor	a
031B: 21A708  		ld	hl,res_fcb
031E: 11A808  		ld	de,res_fcb+1
0321: 012300  		ld	bc ,36-1
0324: 77      		ld	(hl),a
0325: EDB0    		ldir
              		
0327: 3E20    		ld	a,0x20
0329: 21A808  		ld	hl,res_fcb_name
032C: 11A908  		ld	de,res_fcb_name+1
032F: 010A00  		ld	bc ,11-1
0332: 77      		ld	(hl),a
0333: EDB0    		ldir
              	
              		; Is there a prefix?
0335: 21FE07  		ld	hl,res_argument
0338: 3AFF07  		ld	a,(res_argument+1)
033B: FE3A    		cp	':'
033D: C24F03  		jp	nz,2$
              		
              		; Set prefix
0340: 3AFE07  		ld	a,(res_argument)
0343: D640    		sub	'A'-1
0345: FE11    		cp	17
0347: D2AA03  		jp	nc,99$
034A: 32A708  		ld	(res_fcb_drive),a
034D: 23      		inc	hl
034E: 23      		inc	hl
              	
              		; HL = Proper filename start
034F: 0608    	2$:	ld	b,8
0351: 11A808  		ld	de,res_fcb_name
              		
              		; Copy it over
0354: 7E      	3$:	ld	a,(hl)
0355: B7      		or	a
0356: CAAA03  		jp	z,99$
0359: FE2A    		cp	'*'
035B: CA6B03  		jp	z,4$
035E: FE2E    		cp	'.'
0360: CA7203  		jp	z,5$
0363: 12      		ld	(de),a
0364: 13      		inc	de
0365: 23      		inc	hl
0366: 10EC    		djnz	3$
0368: C37203  		jp	5$
              	
              		; Fill remains of FCB file name
036B: 3E3F    	4$:	ld	a,'?'
036D: 12      		ld	(de),a
036E: 13      		inc	de
036F: 10FA    		djnz	4$
0371: 23      		inc	hl
              	
              		; We should either see a '.' or a null character
0372: 7E      	5$:	ld	a,(hl)
0373: B7      		or	a
0374: CA9B03  		jp	z,8$
0377: FE2E    		cp	'.'
0379: C2AA03  		jp	nz,99$
037C: 23      		inc	hl
              		
              		; Fill in extension
037D: 0603    		ld	b,3
037F: 11B008  		ld	de,res_fcb_type
              		
              		; Copy it over
0382: 7E      	6$:	ld	a,(hl)
0383: B7      		or	a
0384: CA9B03  		jp	z,8$
0387: FE2A    		cp	'*'
0389: CA9403  		jp	z,7$
038C: 12      		ld	(de),a
038D: 13      		inc	de
038E: 23      		inc	hl
038F: 10F1    		djnz	6$
0391: C39B03  		jp	8$
              		
              		; Fill remains of FCB file extension
0394: 3E3F    	7$:	ld	a,'?'
0396: 12      		ld	(de),a
0397: 13      		inc	de
0398: 10D1    		djnz	4$
039A: 23      		inc	hl
              	
              		; We should get a zero
039B: 7E      	8$:	ld 	a,(hl)
039C: B7      		or	a
039D: C2AA03  		jp	nz,99$
              		
              		; It is filled in, attempt to open
03A0: 0E0F    		ld	c,bdos_open
03A2: 11A708  		ld	de,res_fcb
03A5: CD0500  		call	bdos
              		
              		; Check error
03A8: 3C      		inc	a
03A9: C0      		ret	nz
              		
              		; Error!
03AA: 0E09    	99$:	ld	c,bdos_print
03AC: 111507  		ld	de,str_arg_fail
03AF: CD0500  		call	bdos
03B2: C36106  		jp	cpm_exit
              		
              		
              	; Print a zero terminated string
              	; We should be in real mode for this
              	; DE = String
              	;
              	; Returns nothing
              	; Uses: All
03B5:         	res_printzt:
03B5: 1A      	0$:	ld	a,(de)
03B6: B7      		or	a
03B7: C8      		ret	z
              		
              		; Print character
03B8: D5      		push	de
03B9: 5F      		ld	e,a
03BA: 0E02    		ld	c,bdos_con_out
03BC: CD0500  		call	bdos
03BF: D1      		pop	de
03C0: 13      		inc	de
03C1: C3B503  		jp	0$
              	
              	; Find a resource from the command line
              	; If the resource is found, the contents will be cached in memory
              	; DE = Name of resource (upper case only) 
              	;
              	; Returns A = 0xFF if no resource is found
              	; Uses: AF, BC, DE, HL
03C4:         	res_locate:
              		; Save resource
03C4: ED530F08		ld	(res_current),de
              	
              		; Travel to the start of arguments
03C8: 218100  		ld	hl,cpm_command+1
03CB: 7E      	0$:	ld	a,(hl)
03CC: B7      		or	a
03CD: CA2A04  		jp	z,99$
03D0: FE21    		cp	0x21
03D2: D2D903  		jp	nc,1$
03D5: 23      		inc	hl
03D6: C3CB03  		jp	0$
              		
              		; Found an argument
              		; Check it against the contents of (DE)
              		; Also must start with '-'
03D9: FE2D    	1$:	cp	'-'
03DB: C2EC03  		jp	nz,3$
03DE: 23      		inc	hl
03DF: D5      		push	de
03E0: 1A      	2$:	ld	a,(de)
              		
              		; Check if at end of string
03E1: B7      		or	a
03E2: CAFA03  		jp	z,4$
              		
              		; No? Well lets see if (de) = (hl)
03E5: BE      		cp	(hl)
03E6: 23      		inc	hl
03E7: 13      		inc	de
03E8: CAE003  		jp	z,2$
              		
              		; Strings are different!
              		; Escape from the current argument and continue
03EB: D1      		pop	de
03EC: 7E      	3$:	ld	a,(hl)
03ED: B7      		or	a
03EE: CA2A04  		jp	z,99$
03F1: FE21    		cp	0x21
03F3: DACB03  		jp	c,0$
03F6: 23      		inc	hl
03F7: C3EC03  		jp	3$
              	
              		; Make sure we are at the end of the argument as well
03FA: D1      	4$: 	pop	de
03FB: 7E      		ld	a,(hl)
03FC: FE21    		cp	0x21
03FE: D2EC03  		jp	nc,3$
              		
              		; Ok, lets copy the argument into memory if it exists
0401: 11FE07  		ld	de,res_argument
0404: AF      		xor	a
0405: 12      		ld	(de),a
              		
              		; Travel to the start of the argument
0406: 7E      	5$:	ld	a,(hl)
0407: B7      		or	a
0408: CA2804  		jp	z,89$
040B: FE21    		cp	0x21
040D: D21404  		jp	nc,6$
0410: 23      		inc	hl
0411: C30604  		jp	5$
              	
              		; Make sure it doesn't start with '-'
0414: FE2D    	6$:	cp	'-'
0416: CA2804  		jp	z,89$
              		
              		; Ok, lets copy up 16 bytes of this
0419: 0610    		ld	b,arg_size
041B: 7E      	7$:	ld	a,(hl)
041C: FE21    		cp	0x21
041E: DA2604  		jp	c,8$
0421: 12      		ld	(de),a
0422: 23      		inc	hl
0423: 13      		inc	de
0424: 10F5    		djnz	7$
              	
              		; Zero terminate
0426: AF      	8$:	xor	a
0427: 12      		ld	(de),a
              		
              		; Good ending
0428: AF      	89$:	xor	a
0429: C9      		ret
              	
              		; Bad ending
042A: 3EFF    	99$:	ld	a,0xFF
042C: C9      		ret
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Loading string components
06EE:         	str_load_a:
06EE: 4C4F4144		defb	'LOADING $'
06F2: 494E4720	
06F6: 24      	
              		
06F7:         	str_load_b:
06F7: 2046524F		defb	' FROM $'
06FB: 4D2024  	
              		
              	; Error messages
06FE:         	str_arg_empty:
06FE: 4E4F2041		defb	'NO ARGUMENT PROVIDED',0x0A,0x0D,'$'
0702: 5247554D	
0706: 454E5420	
070A: 50524F56	
070E: 49444544	
0712: 0A0D24  	
              		
0715:         	str_arg_fail:
0715: 4641494C		defb	'FAILED TO OPEN FILE',0x0A,0x0D,'$'
0719: 45442054	
071D: 4F204F50	
0721: 454E2046	
0725: 494C450A	
0729: 0D24    	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Stores a zero-terminated string for the resource argument
07FE:         	res_argument:
07FE: 00000000		defs	arg_size+1
0802: 00...   	
              		
              	; Current resource being accessed
080F:         	res_current:
080F: 00000000		defs	arg_size+1
0813: 00...   	
              		
              	; Resource buffer
0820:         	res_buffer:
0820: 00000000		defs	128
0824: 00...   	
              		
              	; Sector counter
08A0:         	res_sectors:
08A0: 0000    		defs	2
              		
              	; Do we need to read?
08A2:         	res_do_read:
08A2: 00      		defs	1
              		
              	; Resource bankmap
08A3:         	res_bankmap:
08A3: 0000    		defs	2
              		
              	; Loading pointer
08A5:         	res_pointer:
08A5: 0000    		defs	2
              		
              	; File control block for use in loading resources
08A7:         	res_fcb:
08A7: 00000000		defs	36
08AB: 00...   	
08A7:         	res_fcb_drive	equ	res_fcb
08A8:         	res_fcb_name	equ	res_fcb+1
08B0:         	res_fcb_type	equ	res_fcb+9
08B3:         	res_fcb_ex	equ	res_fcb+12
08B4:         	res_fcb_s1	equ	res_fcb+13
08B5:         	res_fcb_s2	equ	res_fcb+14
08B6:         	res_fcb_rc	equ	res_fcb+15
08B7:         	res_fcb_data	equ	res_fcb+16
08C7:         	res_fcb_cr	equ	res_fcb+32
08C8:         	res_fcb_r0	equ	res_fcb+33
08C9:         	res_fcb_r1	equ	res_fcb+34
08CA:         	res_fcb_r2	equ	res_fcb+35
              	#include "TRAP.asm"
              	;
              	;********************************************************************
              	;*
              	;*                     T R A P   H A N D L E R
              	;* 
              	;*    Responsible for handling various traps from the ZMM. Both
              	;*    interrupt and I/O traps will be pre-processed before being
              	;*    sent to the virtualization core for device-specific handling
              	;*
              	;********************************************************************
              	
              	; -------------------------------
              	; ********  Trap Handler ********
              	; -------------------------------
              	
              	.area	_TEXT
              	
              	; Entry point for traps
042D:         	trap_entry:
              		; Save value of SP
042D: ED73CB08		ld	(trap_sp_value),sp
0431: 310070  		ld	sp,kri_stack
              		
              		; Save value of AF
0434: F5      		push	af
              		
              		; Check in on device interrupts
0435: CD9606  		call	irq_handle
              		
              		; Grab the value of the ISR register
0438: DB30    		in	a,(zmm_isr)
              		
              		; Do we actually need to handle a trap?
043A: B7      		or	a
043B: F21C06  		jp	p,trap_continue
              		
              		; OK, a trap did occur.
              		; Are we doing "classic" I/O or extended I/O?
043E: FEE8    		cp	0b11101000
0440: DA5A04  		jp	c,trap_io_ext
              		
              		; In or out?
0443: FEEC    		cp	0b11101100
0445: DA5104  		jp	c,0$
              		
              		; In it is
0448: CD9706  		call	in_handle
044B: 32FF6F  		ld	(trap_a_value),a
044E: C31C06  		jp	trap_continue
              		
              		; Out it is
0451: 3AFF6F  	0$:	ld	a,(trap_a_value)
0454: CD9A06  		call	out_handle
0457: C31C06  		jp	trap_continue
              	
              	
              	; It's an extended I/O instruction
045A:         	trap_io_ext:
              		; Input or output?
045A: 0F      		rrca
045B: DAD604  		jp	c,trap_io_ex_out
              		
              		; Extended input instruction
              		; INI-class?
045E: 0F      		rrca
045F: DA3005  		jp	c,trap_io_inx
              		
              		; Left or right column
0462: 0F      		rrca
0463: DA8D04  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
0466: 0F      		rrca
0467: DA7C04  		jp	c,1$
              		
              		; B or H?
046A: 0F      		rrca
046B: DA7504  		jp	c,2$
              		
              		; It's B
046E: CD9706  		call	in_handle
0471: 47      		ld	b,a
0472: C3B704  		jp	90$
              		
              		; It's H	
0475: CD9706  	2$:	call	in_handle
0478: 67      		ld	h,a
0479: C3B704  		jp	90$
              	
              		; D or 0?
047C: 0F      	1$:	rrca
047D: DA8704  		jp	c,3$
              	
              		; It's D
0480: CD9706  		call	in_handle
0483: 57      		ld	d,a
0484: C3B704  		jp	90$
              		
              		; It's 0
0487: CD9706  	3$:	call	in_handle
048A: C3B704  		jp	90$
              		
              		
              		; Right column
              		; C, E, L, or A?
048D: 0F      	0$:	rrca
048E: DAA304  		jp	c,4$
              		
              		; C or L?
0491: 0F      		rrca
0492: DA9C04  		jp	c,5$
              		
              		; It's C
0495: CD9706  		call	in_handle
0498: 4F      		ld	c,a
0499: C3B704  		jp	90$
              	
              		; It's L
049C: CD9706  	5$:	call	in_handle
049F: 6F      		ld	l,a
04A0: C3B704  		jp	90$
              		
              		; E or A?
04A3: 0F      	4$:	rrca
04A4: DAAE04  		jp	c,6$
              		
              		; It's E
04A7: CD9706  		call	in_handle
04AA: 5F      		ld	e,a
04AB: C3B704  		jp	90$
              	
              		; It's A
04AE: CD9706  	6$:	call	in_handle
04B1: 32FF6F  		ld	(trap_a_value),a
04B4: C3B704  		jp	90$
              		
              		; Extended IN instructions require special flag states
              		; lets set them and return
04B7: E5      	90$:	push	hl
04B8: 21FE6F  		ld	hl,trap_f_value
04BB: CB46    		bit	0,(hl)
04BD: E1      		pop	hl
              		
              		; If it's zero, we don't need the carry flag
04BE: CACC04  		jp	z,91$ 
              		
              		; Update flags and persist carry flag
04C1: B7      		or	a
04C2: 37      		scf
04C3: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Restore old SP
04C6: ED7BCB08		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
04CA: ED45    		retn
              		
              		; Update flags and reset carry flag
04CC: B7      	91$:	or	a
04CD: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Restore old SP
04D0: ED7BCB08		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
04D4: ED45    		retn
              		
              	; Extended output instruction
04D6:         	trap_io_ex_out:
              		; OUTI-class?
04D6: 0F      		rrca
04D7: DAA605  		jp	c,trap_io_outx
              		
              		; Left or right column?
04DA: 0F      		rrca
04DB: DA0605  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
04DE: 0F      		rrca
04DF: DAF404  		jp	c,1$
              		
              		; B or H?
04E2: 0F      		rrca
04E3: DAED04  		jp	c,2$
              		
              		; It's B
04E6: 78      		ld	a,b
04E7: CD9A06  		call	out_handle
04EA: C31C06  		jp	trap_continue
              		
              		; It's H	
04ED: 7C      	2$:	ld	a,h
04EE: CD9A06  		call	out_handle
04F1: C31C06  		jp	trap_continue
              	
              		; D or 0?
04F4: 0F      	1$:	rrca
04F5: DAFF04  		jp	c,3$
              	
              		; It's D
04F8: 7A      		ld	a,d
04F9: CD9A06  		call	out_handle
04FC: C31C06  		jp	trap_continue
              		
              		; It's 0
04FF: AF      	3$:	xor	a
0500: CD9A06  		call	out_handle
0503: C31C06  		jp	trap_continue
              		
              		
              		; Right column
              		; C, E, L, or A?
0506: 0F      	0$:	rrca
0507: DA1C05  		jp	c,4$
              		
              		; C or L?
050A: 0F      		rrca
050B: DA1505  		jp	c,5$
              		
              		; It's C
050E: 79      		ld	a,c
050F: CD9A06  		call	out_handle
0512: C31C06  		jp	trap_continue
              	
              		; It's L
0515: 7D      	5$:	ld	a,l
0516: CD9A06  		call	out_handle
0519: C31C06  		jp	trap_continue
              		
              		; E or A?
051C: 0F      	4$:	rrca
051D: DA2705  		jp	c,6$
              		
              		; It's E
0520: 7B      		ld	a,e
0521: CD9A06  		call	out_handle
0524: C31C06  		jp	trap_continue
              	
              		; It's A
0527: 3AFF6F  	6$:	ld	a,(trap_a_value)
052A: CD9A06  		call	out_handle
052D: C31C06  		jp	trap_continue
              	
              	
              		; INX class instructions
              		; The CPU should handle the differences between INX and INXR
0530:         	trap_io_inx:
              		; Left or right column?
0530: 0F      		rrca
0531: DA6D05  		jp	c,trap_io_ind
              		
              		; Left column, it's 'I' class
0534: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0535: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
0536: 7C      		ld	a,h
0537: 07      		rlca
0538: DA4B05  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
053B: 07      		rlca
053C: DA4505  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
053F: 3AFA07  		ld	a,(zmm_bnk0_state)
0542: C35805  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0545: 3AFB07  	1$:	ld	a,(zmm_bnk1_state)
0548: C35805  		jp	3$
              			
              		; 0x8000 - 0xFFFF
054B: 07      	0$:	rlca
054C: DA5505  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
054F: 3AFC07  		ld	a,(zmm_bnk2_state)
0552: C35805  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0555: 3AFD07  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0558: E67F    	3$:	and	0b01111111
055A: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
055C: 3EC0    		ld	a,0b11000000
055E: B4      		or	h
055F: 67      		ld	h,a
              		
              		; Do the input
0560: CD9706  		call	in_handle
0563: 77      		ld	(hl),a
              		
              		; Fix banks
0564: 3AFD07  		ld	a,(zmm_bnk3_state)
0567: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0569: E1      		pop	hl
056A: C31C06  		jp	trap_continue
              		
              		; Right column, it's 'D' class
056D:         	trap_io_ind:
056D: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
056E: 23      		inc	hl	; Increment to reverse 'D' class instruction
056F: 7C      		ld	a,h
0570: 07      		rlca
0571: DA8405  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0574: 07      		rlca
0575: DA7E05  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0578: 3AFA07  		ld	a,(zmm_bnk0_state)
057B: C39105  		jp	3$
              		
              		; 0x4000 - 0x7FFF
057E: 3AFB07  	1$:	ld	a,(zmm_bnk1_state)
0581: C39105  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0584: 07      	0$:	rlca
0585: DA8E05  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
0588: 3AFC07  		ld	a,(zmm_bnk2_state)
058B: C39105  		jp	3$
              	
              		; 0xC000 - 0xFFFF
058E: 3AFD07  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0591: E67F    	3$:	and	0b01111111
0593: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0595: 3EC0    		ld	a,0b11000000
0597: B4      		or	h
0598: 67      		ld	h,a
              		
              		; Do the input
0599: CD9706  		call	in_handle
059C: 77      		ld	(hl),a
              		
              		; Fix banks
059D: 3AFD07  		ld	a,(zmm_bnk3_state)
05A0: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
05A2: E1      		pop	hl
05A3: C31C06  		jp	trap_continue
              	
              		; OUTX-class instructions
              		; The CPU should handle the differences between OUTX and OTXR
05A6:         	trap_io_outx:
              		; Left or right column?
05A6: 0F      		rrca
05A7: DAE305  		jp	c,trap_io_outd
              		
              		; Left column, it's 'I' class
05AA: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
05AB: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
05AC: 7C      		ld	a,h
05AD: 07      		rlca
05AE: DAC105  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
05B1: 07      		rlca
05B2: DABB05  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
05B5: 3AFA07  		ld	a,(zmm_bnk0_state)
05B8: C3CE05  		jp	3$
              		
              		; 0x4000 - 0x7FFF
05BB: 3AFB07  	1$:	ld	a,(zmm_bnk1_state)
05BE: C3CE05  		jp	3$
              			
              		; 0x8000 - 0xFFFF
05C1: 07      	0$:	rlca
05C2: DACB05  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
05C5: 3AFC07  		ld	a,(zmm_bnk2_state)
05C8: C3CE05  		jp	3$
              	
              		; 0xC000 - 0xFFFF
05CB: 3AFD07  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
05CE: E67F    	3$:	and	0b01111111
05D0: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
05D2: 3EC0    		ld	a,0b11000000
05D4: B4      		or	h
05D5: 67      		ld	h,a
              		
              		; Do the output
05D6: 7E      		ld	a,(hl)
05D7: CD9A06  		call	out_handle
              		
              		; Fix banks
05DA: 3AFD07  		ld	a,(zmm_bnk3_state)
05DD: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
05DF: E1      		pop	hl
05E0: C31C06  		jp	trap_continue
              		
              		; Right column, it's 'D' class
05E3:         	trap_io_outd:
05E3: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
05E4: 23      		inc	hl	; Increment to reverse 'D' class instruction
05E5: 7C      		ld	a,h
05E6: 07      		rlca
05E7: DAFA05  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
05EA: 07      		rlca
05EB: DAF405  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
05EE: 3AFA07  		ld	a,(zmm_bnk0_state)
05F1: C30706  		jp	3$
              		
              		; 0x4000 - 0x7FFF
05F4: 3AFB07  	1$:	ld	a,(zmm_bnk1_state)
05F7: C30706  		jp	3$
              			
              		; 0x8000 - 0xFFFF
05FA: 07      	0$:	rlca
05FB: DA0406  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
05FE: 3AFC07  		ld	a,(zmm_bnk2_state)
0601: C30706  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0604: 3AFD07  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0607: E67F    	3$:	and	0b01111111
0609: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
060B: 3EC0    		ld	a,0b11000000
060D: B4      		or	h
060E: 67      		ld	h,a
              		
              		; Do the output
060F: 7E      		ld	a,(hl)
0610: CD9A06  		call	out_handle
              		
              		; Fix banks
0613: 3AFD07  		ld	a,(zmm_bnk3_state)
0616: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0618: E1      		pop	hl
0619: C31C06  		jp	trap_continue
              	
              		
              	; Continue execution
061C:         	trap_continue:
              		; Restore AF
061C: F1      		pop	af
              		
              		; Restore old SP
061D: ED7BCB08		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
0621: ED45    		retn
              		
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize trap handling stuff
              	;
              	; Returns nothing
              	; Uses: AF, HL
0623:         	trap_init:
              		; Install trap vector
0623: 3EC3    		ld	a,0xC3
0625: 326600  		ld	(nmi_address),a
0628: 212D04  		ld	hl,trap_entry
062B: 226700  		ld	(nmi_vector),hl
              		
062E: C9      		ret
              		
              		
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value of untrapped SP value
08CB:         	trap_sp_value:
08CB: 0000    		defs	2
              	
              	; --------------------------------
              	; ******** KRISYS Startup ********
              	; --------------------------------
              	
              	.area	_TEXT
              		
              		; KRISYS entry point
062F:         	kri_start:	
              		; Set up stack
062F: F3      		di
0630: 310070  		ld	sp,kri_stack
0633: 216106  		ld	hl,cpm_exit
0636: E5      		push	hl
              		
              		; Print "hello" splash
0637: 0E09    		ld	c,bdos_print
0639: 112B07  		ld	de,str_splash
063C: CD0500  		call	bdos
              		
              		; Initalize subcomponents
063F: CDAC01  		call	zmm_init
0642: CD2306  		call	trap_init
0645: CD0301  		call	mem_map_init
0648: CD3F02  		call	res_init
              		
              		
              		; Start the core
064B: C37D06  		jp	core_start
              		
              	; ------------------------------
              	; ******** CP/M Service ********
              	; ------------------------------
              		
              	; Print something to the CP/M console
              	; DE = Address of string to print
              	;
              	; Returns nothing
              	; Uses: All
064E:         	cpm_print:
              		; Save control register state
064E: 3AF907  		ld	a,(zmm_ctrl_state)
0651: F5      		push	af
              		
              		; Go to real mode
0652: CDDA01  		call zmm_set_real
              		
              		; Do BDOS call
0655: 0E09    		ld	c,bdos_print
0657: CD0500  		call	bdos
              		
              		; Restore register
065A: F1      		pop	af
065B: 32F907  		ld	(zmm_ctrl_state),a
065E: C3C901  		jp	zmm_ctrl_set
              		
              	; Go back to CP/M
              	;
              	; Does not return
              	; Uses: N/A
0661:         	cpm_exit:
0661: 0E00    		ld	c,bdos_exit
0663: CD0500  		call	bdos	
              		
              	; ----------------------
              	; ******** Misc ********
              	; ----------------------
              		
              	; Converts the value into an 8 bit hex number
              	; A = Number to convert
              	;
              	; Returns DE = result
              	; Uses: AF, DE
0666: 57      	tohex:	ld	d,a
0667: CD7106  		call	0$
066A: 5F      		ld	e,a
066B: 7A      		ld	a,d
066C: CD7506  		call	1$
066F: 57      		ld	d,a
0670: C9      		ret
              		
0671: 1F      	0$:	rra
0672: 1F      		rra
0673: 1F      		rra
0674: 1F      		rra
0675: F6F0    	1$:	or	0xF0
0677: 27      		daa
0678: C6A0    		add	a,0xA0
067A: CE40    		adc	a,0x40
067C: C9      		ret
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
072B:         	str_splash:
072B: 4944454E		defb	'IDENTITY KRISYS HYPERVISOR, CP/M EDT.',0x0A,0x0D
072F: 54495459	
0733: 204B5249	
0737: 53595320	
073B: 48595045	
073F: 52564953	
0743: 4F522C20	
0747: 43502F4D	
074B: 20454454	
074F: 2E0A0D  	
0752: 5645522E		defb	'VER. 0.0.1, GAVIN TERSTEEG 2024'
0756: 20302E30	
075A: 2E312C20	
075E: 47415649	
0762: 4E205445	
0766: 52535445	
076A: 45472032	
076E: 303234  	
              		
              	; Carriage return, line break
0771:         	str_crlf:
0771: 0A0D24  		defb	0x0A,0x0D,'$' 
              		
              	
              	; ---------------------------
              	; ******** Core Init ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Start of SG-1000 core
067D:         	core_start:
              	
              		; Try to find rom resource
067D: 117407  		ld	de,str_rom
0680: CDC403  		call	res_locate
0683: B7      		or	a
0684: C26106  		jp	nz,cpm_exit
              		
              		; Open the resource
0687: CDD002  		call	res_open
              		
              		; Load resources into bankmap
068A: 21CD08  		ld	hl,bm_rom
068D: 010001  		ld	bc,256
0690: CD4902  		call	res_load
              	
0693: C36106  		jp	cpm_exit
              		
              		
              	; -----------------------------------
              	; ******** Interrupt Handler ********
              	; -----------------------------------
              		
              	.area	_TEXT
              		
              	; Handle "real" interrupts from devices (if needed)
              	; All registers except AF must remain unchanged!
0696:         	irq_handle:
0696: C9      		ret
              		
              		
              	; -----------------------------
              	; ******** I/O Handler ********
              	; -----------------------------
              		
              	.area	_TEXT
              	
              	; Handle an IN instruction
              	; Inputted value should be returned in register A
              	; All registers except AF must remain unchanged!
0697:         	in_handle:
0697: 3EFF    		ld	a,0xFF
0699: C9      		ret
              	
              	; Handle an OUT instruction
              	; A = Value outputted by virtual machine
              	; All registers except AF must remain unchanged!
069A:         	out_handle:
069A: C9      		ret
              		
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Resource strings
0774:         	str_rom:
0774: 524F4D00		defb	'ROM',0
              		
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
08CD:         	bm_rom:
08CD: 0000    		defs	2


; +++ segments +++

#CODE _TEXT    = $0100 =   256,  size = $059B =  1435
#CODE _DATA    = $069B =  1691,  size = $00DD =   221
#DATA _BSS     = $0778 =  1912,  size = $0157 =   343

; +++ global symbols +++

_BSS             = $0778 =  1912  _BSS    KRISYS.asm:28 (unused)
_BSS_end         = $08CF =  2255  _BSS    KRISYS.asm:28
_BSS_size        = $0157 =   343  _BSS    KRISYS.asm:28 (unused)
_DATA            = $069B =  1691  _DATA   KRISYS.asm:27 (unused)
_DATA_end        = $0778 =  1912  _DATA   KRISYS.asm:27
_DATA_size       = $00DD =   221  _DATA   KRISYS.asm:27 (unused)
_TEXT            = $0100 =   256  _TEXT   KRISYS.asm:26 (unused)
_TEXT_end        = $069B =  1691  _TEXT   KRISYS.asm:26
_TEXT_size       = $059B =  1435  _TEXT   KRISYS.asm:26 (unused)
alloc_bank_map   = $0779 =  1913  _BSS    MEMORY.asm:211
arg_size         = $0010 =    16  _BSS    RESOURCE.asm:17
banks_free       = $0778 =  1912  _BSS    MEMORY.asm:205
bdos             = $0005 =     5  _TEXT   KRISYS.asm:49
bdos_con_in      = $0001 =     1  _TEXT   KRISYS.asm:51 (unused)
bdos_con_out     = $0002 =     2  _TEXT   KRISYS.asm:52
bdos_exit        = $0000 =     0  _TEXT   KRISYS.asm:50
bdos_open        = $000F =    15  _TEXT   KRISYS.asm:54
bdos_print       = $0009 =     9  _TEXT   KRISYS.asm:53
bdos_read        = $0014 =    20  _TEXT   KRISYS.asm:55
bios_set_dma     = $001A =    26  _TEXT   KRISYS.asm:56
bm_rom           = $08CD =  2253  _BSS    KSG1000.asm:86
core_start       = $067D =  1661  _TEXT   KSG1000.asm:17
cpm_command      = $0080 =   128  _TEXT   KRISYS.asm:58
cpm_exit         = $0661 =  1633  _TEXT   KRISYS.asm:160
cpm_print        = $064E =  1614  _TEXT   KRISYS.asm:139
in_handle        = $0697 =  1687  _TEXT   KSG1000.asm:57
irq_handle       = $0696 =  1686  _TEXT   KSG1000.asm:44
kri_stack        = $7000 = 28672  _TEXT   KRISYS.asm:88
kri_start        = $062F =  1583  _TEXT   KRISYS.asm:108
mem_alloc        = $0165 =   357  _TEXT   MEMORY.asm:103
mem_empty        = $01A3 =   419  _TEXT   MEMORY.asm:177
mem_free         = $0186 =   390  _TEXT   MEMORY.asm:135
mem_free_all     = $0198 =   408  _TEXT   MEMORY.asm:161 (unused)
mem_map_init     = $0103 =   259  _TEXT   MEMORY.asm:30
nabu_at_latch    = $0041 =    65  _TEXT   KRISYS.asm:85 (unused)
nabu_ay_data     = $0040 =    64  _TEXT   KRISYS.asm:84 (unused)
nabu_nctl        = $0000 =     0  _TEXT   KRISYS.asm:83 (unused)
nmi_address      = $0066 =   102  _TEXT   KRISYS.asm:79
nmi_vector       = $0067 =   103  _TEXT   KRISYS.asm:80
out_handle       = $069A =  1690  _TEXT   KSG1000.asm:64
res_argument     = $07FE =  2046  _BSS    RESOURCE.asm:454
res_bankmap      = $08A3 =  2211  _BSS    RESOURCE.asm:474
res_buffer       = $0820 =  2080  _BSS    RESOURCE.asm:462
res_current      = $080F =  2063  _BSS    RESOURCE.asm:458
res_do_read      = $08A2 =  2210  _BSS    RESOURCE.asm:470
res_fcb          = $08A7 =  2215  _BSS    RESOURCE.asm:482
res_fcb_cr       = $08C7 =  2247  _BSS    RESOURCE.asm:492 (unused)
res_fcb_data     = $08B7 =  2231  _BSS    RESOURCE.asm:491 (unused)
res_fcb_drive    = $08A7 =  2215  _BSS    RESOURCE.asm:484
res_fcb_ex       = $08B3 =  2227  _BSS    RESOURCE.asm:487 (unused)
res_fcb_name     = $08A8 =  2216  _BSS    RESOURCE.asm:485
res_fcb_r0       = $08C8 =  2248  _BSS    RESOURCE.asm:493 (unused)
res_fcb_r1       = $08C9 =  2249  _BSS    RESOURCE.asm:494 (unused)
res_fcb_r2       = $08CA =  2250  _BSS    RESOURCE.asm:495 (unused)
res_fcb_rc       = $08B6 =  2230  _BSS    RESOURCE.asm:490 (unused)
res_fcb_s1       = $08B4 =  2228  _BSS    RESOURCE.asm:488 (unused)
res_fcb_s2       = $08B5 =  2229  _BSS    RESOURCE.asm:489 (unused)
res_fcb_type     = $08B0 =  2224  _BSS    RESOURCE.asm:486
res_init         = $023F =   575  _TEXT   RESOURCE.asm:29
res_load         = $0249 =   585  _TEXT   RESOURCE.asm:47
res_locate       = $03C4 =   964  _TEXT   RESOURCE.asm:337
res_open         = $02D0 =   720  _TEXT   RESOURCE.asm:153
res_pointer      = $08A5 =  2213  _BSS    RESOURCE.asm:478
res_printzt      = $03B5 =   949  _TEXT   RESOURCE.asm:317
res_sectors      = $08A0 =  2208  _BSS    RESOURCE.asm:466
stack_size       = $0020 =    32          KRISYS.asm:31
str_arg_empty    = $06FE =  1790  _DATA   RESOURCE.asm:441
str_arg_fail     = $0715 =  1813  _DATA   RESOURCE.asm:444
str_crlf         = $0771 =  1905  _DATA   KRISYS.asm:203
str_load_a       = $06EE =  1774  _DATA   RESOURCE.asm:434
str_load_b       = $06F7 =  1783  _DATA   RESOURCE.asm:437
str_mem_empty    = $06C6 =  1734  _DATA   MEMORY.asm:195
str_mem_init     = $069B =  1691  _DATA   MEMORY.asm:189
str_mem_init_cnt = $06C0 =  1728  _DATA   MEMORY.asm:192
str_rom          = $0774 =  1908  _DATA   KSG1000.asm:75
str_splash       = $072B =  1835  _DATA   KRISYS.asm:198
str_zmm_init     = $06DC =  1756  _DATA   ZMM.asm:184
tohex            = $0666 =  1638  _TEXT   KRISYS.asm:173
trap_a_value     = $6FFF = 28671  _TEXT   KRISYS.asm:89
trap_continue    = $061C =  1564  _TEXT   TRAP.asm:477
trap_entry       = $042D =  1069  _TEXT   TRAP.asm:19
trap_f_value     = $6FFE = 28670  _TEXT   KRISYS.asm:90
trap_init        = $0623 =  1571  _TEXT   TRAP.asm:497
trap_io_ex_out   = $04D6 =  1238  _TEXT   TRAP.asm:170
trap_io_ext      = $045A =  1114  _TEXT   TRAP.asm:58
trap_io_ind      = $056D =  1389  _TEXT   TRAP.asm:308
trap_io_inx      = $0530 =  1328  _TEXT   TRAP.asm:249
trap_io_outd     = $05E3 =  1507  _TEXT   TRAP.asm:422
trap_io_outx     = $05A6 =  1446  _TEXT   TRAP.asm:363
trap_sp_value    = $08CB =  2251  _BSS    TRAP.asm:515
zmm_addr_hi      = $0032 =    50  _TEXT   KRISYS.asm:67 (unused)
zmm_addr_lo      = $0033 =    51  _TEXT   KRISYS.asm:68 (unused)
zmm_bnk0         = $0030 =    48  _TEXT   KRISYS.asm:61
zmm_bnk0_set     = $0227 =   551  _TEXT   ZMM.asm:142 (unused)
zmm_bnk0_state   = $07FA =  2042  _BSS    ZMM.asm:198
zmm_bnk1         = $0031 =    49  _TEXT   KRISYS.asm:62
zmm_bnk1_set     = $022D =   557  _TEXT   ZMM.asm:152 (unused)
zmm_bnk1_state   = $07FB =  2043  _BSS    ZMM.asm:202
zmm_bnk2         = $0032 =    50  _TEXT   KRISYS.asm:63
zmm_bnk2_set     = $0233 =   563  _TEXT   ZMM.asm:162 (unused)
zmm_bnk2_state   = $07FC =  2044  _BSS    ZMM.asm:206
zmm_bnk3         = $0033 =    51  _TEXT   KRISYS.asm:64
zmm_bnk3_set     = $0239 =   569  _TEXT   ZMM.asm:172
zmm_bnk3_state   = $07FD =  2045  _BSS    ZMM.asm:210
zmm_capt_res     = $007F =   127  _TEXT   KRISYS.asm:76 (unused)
zmm_capt_set     = $0070 =   112  _TEXT   KRISYS.asm:75 (unused)
zmm_capture      = $7000 = 28672  _TEXT   KRISYS.asm:71
zmm_ctrl         = $0034 =    52  _TEXT   KRISYS.asm:65
zmm_ctrl_set     = $01C9 =   457  _TEXT   ZMM.asm:44
zmm_ctrl_state   = $07F9 =  2041  _BSS    ZMM.asm:194
zmm_init         = $01AC =   428  _TEXT   ZMM.asm:22
zmm_irq_inter    = $01FB =   507  _TEXT   ZMM.asm:97 (unused)
zmm_irq_normal   = $0206 =   518  _TEXT   ZMM.asm:108 (unused)
zmm_irq_off      = $021C =   540  _TEXT   ZMM.asm:130 (unused)
zmm_irq_on       = $0211 =   529  _TEXT   ZMM.asm:119 (unused)
zmm_isr          = $0030 =    48  _TEXT   KRISYS.asm:66
zmm_map          = $8000 = 32768  _TEXT   KRISYS.asm:72 (unused)
zmm_prgm_in      = $01E5 =   485  _TEXT   ZMM.asm:75 (unused)
zmm_prgm_out     = $01F0 =   496  _TEXT   ZMM.asm:86 (unused)
zmm_set_real     = $01DA =   474  _TEXT   ZMM.asm:64
zmm_set_virt     = $01CF =   463  _TEXT   ZMM.asm:53
zmm_top          = $C000 = 49152  _TEXT   KRISYS.asm:73
zmm_trap         = $0037 =    55  _TEXT   KRISYS.asm:69 (unused)


total time: 0.5352 sec.
no errors
