              	; --------------------------------------
              	; zasm: assemble "KSG1000.asm"
              	; date: 2024-09-04 00:00:56
              	; --------------------------------------


              	;
              	;********************************************************************
              	;*
              	;*        K R I S Y S   S G 1 0 0 0   C O R E
              	;*
              	;********************************************************************
              	
              	#include "KRISYS.asm"
              	;
              	;********************************************************************
              	;*
              	;*              I D E N T I T Y   K R I S Y S
              	;*
              	;*      The [K]lunkly [R]emapper / [I]nterpreter [SYS]tem
              	;*
              	;*             Written by Gavin Tersteeg, 2024
              	;*              Copyleft, All Wrongs Reserved
              	;*
              	;*
              	;*   This piece of software allows different classic Z80 systems
              	;*   to run as "virtual machines" on top of existing hardware by
              	;*   use of a ZMM (Z80 MEGAMAPPER). It does this by remapping RAM
              	;*   and I/O address space ot match that of it's target system.
              	;*   Anything that can't be emulated by simple remapping is instead
              	;*   interpreted using I/O traps. 
              	;*
              	;*   This allows virtualized machines to run with an acceptable
              	;*   degree of speed and accuracy. While the ZMM is still quite
              	;*   limited in what sort of hardware can be efficiently virtualized,
              	;*   anything that avoids MMIO or graphics hardware that isn't a VDP
              	;*   generally can be made to work.
              	;* 
              	;********************************************************************
              		
              	; ----------------------------
              	; ******** ZASM Setup ********
              	; ----------------------------
              	
0020:         	stack_size = 0x20
              	
              	#target BIN
0100:         	#code	_TEXT,0x0100	; Setup to run as a CP/M executable
0BA1:         	#code	_DATA,_TEXT_end
0FAD:         	#data	_BSS,_DATA_end
              	
              	; Make sure we don't overrun available memory
              	#assert	_BSS_end < (zmm_capture-stack_size)
              	
              	.area	_TEXT
0100: C30209  		jp	kri_start
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
              	; CP/M Stuff
0005:         	bdos		equ	0x0005
0000:         	bdos_exit	equ	0x00
0001:         	bdos_con_in	equ	0x01
0002:         	bdos_con_out	equ	0x02
0009:         	bdos_print	equ	0x09
000A:         	bdos_input	equ	0x0A
000F:         	bdos_open	equ	0x0F
0014:         	bdos_read	equ	0x14
001A:         	bios_set_dma	equ	0x1A
              	
0080:         	cpm_command	equ	0x0080
              	
              	; Z80 MEGAMAPPER Stuff
0030:         	zmm_bnk0	equ	0x30	; 16K Bank 0 (0x0000 - 0x3FFF)
0031:         	zmm_bnk1	equ	0x31	; 16K Bank 1 (0x4000 - 0x7FFF)
0032:         	zmm_bnk2	equ	0x32	; 16K Bank 2 (0x8000 - 0xBFFF)
0033:         	zmm_bnk3	equ	0x33	; 16K Bank 3 (0xC000 - 0xFFFF)
0034:         	zmm_ctrl	equ	0x34	; ZMM Control Register
0030:         	zmm_isr		equ	0x30	; ZMM Trapped Instruction Register
0032:         	zmm_addr_hi	equ	0x32	; ZMM Trap Address High
0033:         	zmm_addr_lo	equ	0x33	; ZMM Trap Address Low
0037:         	zmm_trap	equ	0x37 	; ZMM Trap Vector
              	
7000:         	zmm_capture	equ	0x7000
8000:         	zmm_map		equ	0x8000
C000:         	zmm_top		equ	0xC000
              	
0070:         	zmm_capt_set	equ	0b01110000
007F:         	zmm_capt_res	equ	0b01111111
              	
              	; General Z80 Stuff
0066:         	nmi_address	equ	0x0066
0067:         	nmi_vector	equ	nmi_address+1
              	
              	; NABU Specific Stuff
0000:         	nabu_nctl	equ	0x00	; NABU Control Register
0040:         	nabu_ay_data	equ	0x40	; AY-3-8910 Data Port
0041:         	nabu_ay_latch	equ	0x41	; AY-3-8910 Latch Port
0090:         	nabu_key_data	equ	0x90	; NABU Keyboard Data
0091:         	nabu_key_stat	equ	0x91	; NABU Keyboard Status
00A0:         	nabu_vdp_data	equ	0xA0	; VDP Data Port
00A1:         	nabu_vdp_addr	equ	0xA1	; VDP Address Port
              	
              	; Stack / Trap Management
7000:         	kri_stack	equ	zmm_capture
6FFF:         	trap_a_value	equ	kri_stack-1
6FFE:         	trap_f_value	equ	kri_stack-2
              	
              	; -------------------------------------
              	; ******** Additional Includes ********
              	; -------------------------------------
              	
              	#include "MEMORY.asm"
              	;
              	;********************************************************************
              	;*
              	;*                    Z M M   M E M O R Y
              	;* 
              	;*    The ZMM can be configured to have different amounts
              	;*    of memory installed. Instead of dicking around with 
              	;*    on-board jumpers, KRISYS will simply check what banks
              	;*    are available on startup. Memory will be dynamically
              	;*    allocated as needed by the client process.
              	;*
              	;*    Memory can be assigned to specific owners in the code.
              	;*    Valid owner IDs range from 1 to 254. Owner 0 is reserved
              	;*    for unallocatable banks.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              		
              	; Initalize the memory map
              	; Each bank of the ZMM will be probed, and writable
              	; banks will be recorded on the allocated bank map
              	;
              	; Returns nothing
              	; Uses: AF, BC, DE, HL
0103:         	mem_map_init:
              		; Go to virtual mode
0103: CD3E02  		call	zmm_set_virt
              		
              		; Reset free bank counter
0106: 3E00    		ld	a,0
0108: 32AD0F  		ld	(banks_free),a
              		
              		; Write tags to all banks
010B: 0600    		ld	b,0
010D: 78      	0$:	ld	a,b
010E: CDA802  		call	zmm_bnk3_set
0111: 3200C0  		ld	(zmm_top),a
0114: ED44    		neg
0116: 3201C0  		ld	(zmm_top+1),a
0119: 04      		inc	b
011A: F20D01  		jp	p,0$
              		
              		; Mark any banks that record correctly
011D: 0600    		ld	b,0
011F: 21AE0F  		ld	hl,alloc_bank_map
0122: AF      	1$:	xor	a
0123: 77      		ld	(hl),a
0124: 78      		ld	a,b
0125: CDA802  		call	zmm_bnk3_set
0128: 3A00C0  		ld	a,(zmm_top)
012B: B8      		cp	b
012C: C24401  		jp	nz,2$
012F: 3A01C0  		ld	a,(zmm_top+1)
0132: 4F      		ld	c,a
0133: 78      		ld	a,b
0134: ED44    		neg
0136: B9      		cp	c
0137: C24401  		jp	nz,2$
              	
              		; Mark it
013A: 3EFF    		ld	a,0xFF
013C: 77      		ld	(hl),a
013D: 3AAD0F  		ld	a,(banks_free)
0140: 3C      		inc	a
0141: 32AD0F  		ld	(banks_free),a
              		
              		; Next
0144: 23      	2$:	inc	hl
0145: 04      		inc	b
0146: F22201  		jp	p,1$
              		
              		; Disable virtual mode
0149: CD4902  		call	zmm_set_real
              		
              		; Print out result
014C: 3AAD0F  		ld	a,(banks_free)
014F: CD6909  		call	tohex
0152: ED53C60B		ld	(str_mem_init_cnt),de
0156: 11A10B  		ld	de,str_mem_init
0159: CD2709  		call	cpm_print
              		
              		; Do we actually have an acceptable amount of memory?
015C: 3AAD0F  		ld	a,(banks_free)
015F: 3D      		dec	a
0160: 3D      		dec	a
0161: FADB01  		jp	m,mem_empty
              		
              		; We do, return
0164: C9      		ret
              		
              	; Fetch byte from virtual memory
              	; HL = Address to fetch
              	;
              	; Returns A = Fetched byte
              	; Uses: AF
0165:         	mem_fvbyte:
              		; Calculate target bank
0165: CD7801  		call	mem_getbank
0168: D333    		out	(zmm_bnk3),a
              		
              		; Grab byte
016A: E5      		push	hl
016B: 7C      		ld	a,h
016C: F6C0    		or	0b11000000
016E: 67      		ld	h,a
016F: 66      		ld	h,(hl)
              		
              		; Restore original bank
0170: 3A3210  		ld	a,(zmm_bnk3_state)
0173: D333    		out	(zmm_bnk3),a
0175: 7C      		ld	a,h
              		
              		; Return
0176: E1      		pop	hl
0177: C9      		ret
              	
              	
              	; Gets the bank that an address points to
              	; HL = Address to analyse
              	;
              	; Returns A = Value of write-enabled bank
              	; Uses: AF
0178:         	mem_getbank:
0178: 7C      		ld	a,h
0179: 07      		rlca
017A: DA8D01  		jp	c,0$
              		
              		; Lower 32K
017D: 07      		rlca
017E: DA8701  		jp	c,1$
              		
              		; 0-15K
0181: 3A2F10  		ld	a,(zmm_bnk0_state)
0184: E67F    		and	0b01111111
0186: C9      		ret
              		
              		; 16K-31K
0187: 3A3010  	1$:	ld	a,(zmm_bnk1_state)
018A: E67F    		and	0b01111111
018C: C9      		ret
              	
              		; Upper 32K
018D: 07      	0$:	rlca
018E: DA9701  		jp	c,2$
              		
              		; 32K-47K
0191: 3A3110  		ld	a,(zmm_bnk2_state)
0194: E67F    		and	0b01111111
0196: C9      		ret
              	
              		; 48K-63K
0197: 3A3210  	2$:	ld	a,(zmm_bnk3_state)
019A: E67F    		and	0b01111111
019C: C9      		ret
              		
              	; Allocates a bank of memory
              	; Will produce an error if no banks are available,
              	; check (banks_free) to avoid
              	; D = Owner ID (1-254)
              	;
              	; Returns A = Bank #
              	; Uses: AF, BC, HL
019D:         	mem_alloc:
              		; Check and decrement free memory
019D: 3AAD0F  		ld	a,(banks_free)
01A0: 3D      		dec	a
01A1: 32AD0F  		ld	(banks_free),a
01A4: FADB01  		jp	m,mem_empty
              		
              		; Look for the first free bank
01A7: 21AE0F  		ld	hl,alloc_bank_map
01AA: 018000  		ld	bc,0x0080
01AD: 3EFF    		ld	a,0xFF
01AF: EDB1    		cpir
              		
              		; Make sure we found something
01B1: C2DB01  		jp	nz,mem_empty
              		
              		; Save and exit
01B4: 2B      		dec	hl
01B5: 72      		ld	(hl),d
01B6: 01AE0F  		ld	bc,alloc_bank_map
01B9: B7      		or	a
01BA: ED42    		sbc	hl,bc
01BC: 7D      		ld	a,l
01BD: C9      		ret
              		
              	; Frees a bank of memory
              	; Safe to use on banks that are not free / not owned
              	; A = Bank #
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
01BE:         	mem_free:
              		; Find location in memory
01BE: 0600    		ld	b,0
01C0: 4F      		ld	c,a
01C1: 21AE0F  		ld	hl,alloc_bank_map
01C4: 09      		add	hl,bc
              		
              		; Check owner
01C5: 7E      		ld	a,(hl)
01C6: BA      		cp	d
01C7: C0      		ret	nz
              		
              		; Free bank
01C8: 3EFF    		ld	a,0xFF
01CA: 77      		ld	(hl),a
              		
              		; Increment banks free
01CB: 21AD0F  		ld	hl,banks_free
01CE: 34      		inc	(hl)
01CF: C9      		ret
              		
              	; Free all banks by owner
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
01D0:         	mem_free_all:
              		; Free a bank
01D0: AF      		xor	a
01D1: F5      	0$:	push	af
01D2: CDBE01  		call	mem_free
01D5: F1      		pop	af
              		
              		; Next bank
01D6: 3C      		inc	a
01D7: F2D101  		jp	p,0$
01DA: C9      		ret
              		
              	; Error out if empty
              	;
              	; Does not return
              	; Uses: N/A
01DB:         	mem_empty:
01DB: 11CC0B  		ld	de,str_mem_empty
01DE: CD2709  		call	cpm_print
01E1: C36109  		jp	cpm_exit
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0BA1:         	str_mem_init:
0BA1: 494E4954		defb	'INITIALIZED MEMORY MAP',0x0A,0x0D
0BA5: 49414C49	
0BA9: 5A454420	
0BAD: 4D454D4F	
0BB1: 5259204D	
0BB5: 41500A0D	
0BB9: 42414E4B		defb	'BANK COUNT = '
0BBD: 20434F55	
0BC1: 4E54203D	
0BC5: 20      	
0BC6:         	str_mem_init_cnt:
0BC6: 5858480A		defb	'XXH',0x0A,0x0D,'$'
0BCA: 0D24    	
              		
0BCC:         	str_mem_empty:
0BCC: 494E5355		defb	'INSUFFICIENT MEMORY',0x0A,0x0D,'$'
0BD0: 46464943	
0BD4: 49454E54	
0BD8: 204D454D	
0BDC: 4F52590A	
0BE0: 0D24    	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Free bank count
0FAD:         	banks_free:
0FAD: 00      		defs	1
              	
              	; Allocated bank map
              	; This 128 byte table keeps track of every single 16K bank
              	; that exists on the ZMM. Populated on startup
0FAE:         	alloc_bank_map:
0FAE: 00000000		defs	128
0FB2: 00...   	
              	#include "ZMM.asm"
              	;
              	;********************************************************************
              	;*
              	;*                  Z M M   M A N A G E M E N T
              	;* 
              	;*    These routines are used to manage the state of the ZMM.
              	;*    This includes the setting of the registers as well as setting
              	;*    up trap and interrupt stuff.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize ZMM and reset registers
              	;
              	; Returns nothing
              	; Uses: AF
01E4:         	zmm_init:
              		; Zero out control register
01E4: 3E00    		ld	a,0
01E6: 322E10  		ld	(zmm_ctrl_state),a
01E9: 322F10  		ld	(zmm_bnk0_state),a
01EC: 323010  		ld	(zmm_bnk1_state),a
01EF: 323110  		ld	(zmm_bnk2_state),a
01F2: 323210  		ld	(zmm_bnk3_state),a
              		
              		; See if we can swing in and out of virtual mode
01F5: CD3E02  		call	zmm_set_virt
01F8: CD4902  		call	zmm_set_real
              		
              		; Tell the user that the ZMM is ready
01FB: 11E20B  		ld	de,str_zmm_init
01FE: C32709  		jp	cpm_print
              		
              	; Start execution of the virtual machine at a specific location
              	; HL = Address to start execution at
              	; 
              	; Does not return
              	; Uses: All registers zeroed
0201:         	zmm_vm_start:
0201: 310000  		ld	sp,0x0000
              		
              		; Completely empty out capture zone
0204: E5      		push	hl
0205: 210070  		ld	hl,zmm_capture
0208: 110170  		ld	de,zmm_capture+1
020B: 01FF0F  		ld	bc,0x1000-1
020E: AF      		xor	a
020F: 77      		ld	(hl),a
0210: EDB0    		ldir
0212: E1      		pop	hl
              		
0213: 7D      		ld	a,l
0214: 320070  		ld	(zmm_capture),a
0217: 7C      		ld	a,h
0218: 320170  		ld	(zmm_capture + 1),a
              		
              		; Reset I/O trap flag just in case
021B: D337    		out	(zmm_trap),a
              		
              		; Zero everything
021D: AF      		xor	a
021E: 47      		ld	b,a
021F: 4F      		ld	c,a
0220: 57      		ld 	d,a
0221: 5F      		ld	e,a
0222: 67      		ld	h,a
0223: 6F      		ld	l,a
0224: D9      		exx
0225: 08      		ex	af,af'
0226: AF      		xor	a
0227: 47      		ld	b,a
0228: 4F      		ld	c,a
0229: 57      		ld 	d,a
022A: 5F      		ld	e,a
022B: 67      		ld	h,a
022C: 6F      		ld	l,a
              		
022D: DD210000		ld	ix,0
0231: FD210000		ld	iy,0
              		
              		; Enter virtual machine
0235: 00      		nop
0236: ED45    		retn
              		
              	; Set the ZMM control register to the recorded state
              	; (zmm_ctrl_state) = New value of ZMM control register
              	;
              	; Returns nothing
              	; Uses: AF
0238:         	zmm_ctrl_set:
0238: 3A2E10  		ld	a,(zmm_ctrl_state)
023B: D334    		out	(zmm_ctrl),a
023D: C9      		ret
              		
              	; Go to virtual mode
              	;
              	; Returns nothing
              	; Uses: AF
023E:         	zmm_set_virt:
023E: 3A2E10  		ld	a,(zmm_ctrl_state)
0241: F601    		or	0b00000001
0243: 322E10  		ld	(zmm_ctrl_state),a
0246: D334    		out	(zmm_ctrl),a
0248: C9      		ret
              		
              	; Go to real mode
              	;
              	; Returns nothing
              	; Uses: AF
0249:         	zmm_set_real:
0249: 3A2E10  		ld	a,(zmm_ctrl_state)
024C: E6FE    		and	0b11111110
024E: 322E10  		ld	(zmm_ctrl_state),a
0251: D334    		out	(zmm_ctrl),a
0253: C9      		ret
              		
              	; Set program direction to "IN"
              	;
              	; Returns nothing
              	; Uses: AF
0254:         	zmm_prgm_in:
0254: 3A2E10  		ld	a,(zmm_ctrl_state)
0257: F602    		or	0b00000010
0259: 322E10  		ld	(zmm_ctrl_state),a
025C: D334    		out	(zmm_ctrl),a
025E: C9      		ret
              		
              	; Set program direction to "OUT"
              	;
              	; Returns nothing
              	; Uses: AF
025F:         	zmm_prgm_out:
025F: 3A2E10  		ld	a,(zmm_ctrl_state)
0262: E6FD    		and	0b11111101
0264: 322E10  		ld	(zmm_ctrl_state),a
0267: D334    		out	(zmm_ctrl),a
0269: C9      		ret
              		
              	; Turn on irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
026A:         	zmm_irq_inter:
026A: 3A2E10  		ld	a,(zmm_ctrl_state)
026D: F604    		or	0b00000100
026F: 322E10  		ld	(zmm_ctrl_state),a
0272: D334    		out	(zmm_ctrl),a
0274: C9      		ret
              		
              	; Turn off irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
0275:         	zmm_irq_normal:
0275: 3A2E10  		ld	a,(zmm_ctrl_state)
0278: E6FB    		and	0b11111011
027A: 322E10  		ld	(zmm_ctrl_state),a
027D: D334    		out	(zmm_ctrl),a
027F: C9      		ret
              	
              	; Turn on force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
0280:         	zmm_irq_on:
0280: 3A2E10  		ld	a,(zmm_ctrl_state)
0283: F608    		or	0b00001000
0285: 322E10  		ld	(zmm_ctrl_state),a
0288: D334    		out	(zmm_ctrl),a
028A: C9      		ret
              		
              	; Turn off force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
028B:         	zmm_irq_off:
028B: 3A2E10  		ld	a,(zmm_ctrl_state)
028E: E6F7    		and	0b11110111
0290: 322E10  		ld	(zmm_ctrl_state),a
0293: D334    		out	(zmm_ctrl),a
0295: C9      		ret
              		
              	; Set bank 0
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses: AF, B
0296:         	zmm_bnk0_set:
0296: 322F10  		ld	(zmm_bnk0_state),a
0299: D330    		out	(zmm_bnk0),a
029B: C9      		ret
              		
              	; Set bank 1
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
029C:         	zmm_bnk1_set:
029C: 323010  		ld	(zmm_bnk1_state),a
029F: D331    		out	(zmm_bnk1),a
02A1: C9      		ret
              		
              	; Set bank 2
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
02A2:         	zmm_bnk2_set:
02A2: 323110  		ld	(zmm_bnk2_state),a
02A5: D332    		out	(zmm_bnk2),a
02A7: C9      		ret
              		
              	; Set bank 3
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
02A8:         	zmm_bnk3_set:
02A8: 323210  		ld	(zmm_bnk3_state),a
02AB: D333    		out	(zmm_bnk3),a
02AD: C9      		ret
              		
              		
              	; Write protect bank 0
              	;
              	; Returns nothing
              	; Uses: AF
02AE:         	zmm_bnk0_wp:
02AE: 3A2F10  		ld	a,(zmm_bnk0_state)
02B1: F680    		or	0b10000000
02B3: C39602  		jp 	zmm_bnk0_set
              		
              	; Write enable bank 0
              	;
              	; Returns nothing
              	; Uses: AF
02B6:         	zmm_bnk0_we:
02B6: 3A2F10  		ld	a,(zmm_bnk0_state)
02B9: E67F    		and	~0b10000000
02BB: C39602  		jp 	zmm_bnk0_set
              		
              	; Write protect bank 1
              	;
              	; Returns nothing
              	; Uses: AF
02BE:         	zmm_bnk1_wp:
02BE: 3A3010  		ld	a,(zmm_bnk1_state)
02C1: F680    		or	0b10000000
02C3: C39C02  		jp 	zmm_bnk1_set
              		
              	; Write enable bank 1
              	;
              	; Returns nothing
              	; Uses: AF
02C6:         	zmm_bnk1_we:
02C6: 3A3010  		ld	a,(zmm_bnk1_state)
02C9: E67F    		and	~0b10000000
02CB: C39C02  		jp 	zmm_bnk1_set
              		
              	; Write protect bank 2
              	;
              	; Returns nothing
              	; Uses: AF
02CE:         	zmm_bnk2_wp:
02CE: 3A3110  		ld	a,(zmm_bnk2_state)
02D1: F680    		or	0b10000000
02D3: C3A202  		jp 	zmm_bnk2_set
              		
              	; Write enable bank 2
              	;
              	; Returns nothing
              	; Uses: AF
02D6:         	zmm_bnk2_we:
02D6: 3A3110  		ld	a,(zmm_bnk2_state)
02D9: E67F    		and	~0b10000000
02DB: C3A202  		jp 	zmm_bnk2_set
              		
              	; Write protect bank 3
              	;
              	; Returns nothing
              	; Uses: AF
02DE:         	zmm_bnk3_wp:
02DE: 3A3210  		ld	a,(zmm_bnk3_state)
02E1: F680    		or	0b10000000
02E3: C3A802  		jp 	zmm_bnk3_set
              		
              	; Write enable bank 3
              	;
              	; Returns nothing
              	; Uses: AF
02E6:         	zmm_bnk3_we:
02E6: 3A3210  		ld	a,(zmm_bnk3_state)
02E9: E67F    		and	~0b10000000
02EB: C3A802  		jp 	zmm_bnk3_set
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0BE2:         	str_zmm_init:
0BE2: 494E4954		defb	'INITIALIZED ZMM',0x0A,0x0D,'$'
0BE6: 49414C49	
0BEA: 5A454420	
0BEE: 5A4D4D0A	
0BF2: 0D24    	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
102E:         	zmm_ctrl_state:
102E: 00      		defs	1
              		
              	; Bank 0 state
102F:         	zmm_bnk0_state:
102F: 00      		defs	1
              		
              	; Bank 1 state
1030:         	zmm_bnk1_state:
1030: 00      		defs	1
              		
              	; Bank 2 state
1031:         	zmm_bnk2_state:
1031: 00      		defs	1
              		
              	; Bank 3 state
1032:         	zmm_bnk3_state:
1032: 00      		defs	1
              		
              	#include "RESOURCE.asm"
              	;
              	;********************************************************************
              	;*
              	;*               R E S O U R C E   M A N A G E M E N T
              	;* 
              	;*    These routines handle obtaining use-supplied resources
              	;*    such as configurations, ROM images, and storage bindings.
              	;*    During startup, these resources will be loaded to build
              	;*    the virtual machine.
              	;*
              	;********************************************************************
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
0010:         	arg_size	equ 16
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize resources
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
02EE:         	res_init:
              		; Start by zero-terminating string
02EE: 218000  		ld	hl,cpm_command
02F1: 4E      		ld	c,(hl)
02F2: 0600    		ld	b,0
02F4: 09      		add	hl,bc
02F5: 23      		inc	hl
02F6: 70      		ld	(hl),b
              		
02F7: C9      		ret
              		
              	; Loads an open resource into a bankmap
              	; Bankmap will be zero-padded to fill requested number of records
              	; HL = Address of bankmap
              	; BC = Number of records (128 byte blocks) to load
              	;
              	; Returns nothing
              	; Uses: all
02F8:         	res_load:
              		; Set read flag
02F8: 3EFF    		ld	a,0xFF
02FA: 32C810  		ld	(res_do_read),a
              	
              		; Save args
02FD: 22C910  		ld	(res_bankmap),hl
0300: ED43C610		ld	(res_sectors),bc
              	
              		; Virtual mode should be off while we do this
0304: 3A2E10  		ld	a,(zmm_ctrl_state)
0307: F5      		push	af
0308: CD4902  		call	zmm_set_real
              		
              		; Do function call
030B: CD1A03  		call	0$
              		
              		; Reset bank 3
030E: 3A3210  		ld	a,(zmm_bnk3_state)
0311: D333    		out	(zmm_bnk3),a
              		
              		; Restore register
0313: F1      		pop	af
0314: 322E10  		ld	(zmm_ctrl_state),a
0317: C33802  		jp	zmm_ctrl_set
              		
              		; Allocate a new bank
031A: 1601    	0$:	ld	d,1
031C: CD9D01  		call	mem_alloc
031F: 2AC910  		ld	hl,(res_bankmap)
0322: 77      		ld	(hl),a
0323: 23      		inc	hl
0324: 22C910  		ld	(res_bankmap),hl
              		
              		; Set the bank in slot 3
0327: D333    		out	(zmm_bnk3),a
              		
              		; Set DMA address
0329: 114610  		ld	de,res_buffer
032C: 0E1A    		ld	c,bios_set_dma
032E: CD0500  		call	bdos
              		
              		; Set pointer	
0331: 2100C0  		ld	hl,zmm_top
0334: 22CB10  		ld	(res_pointer),hl
              		
              		; We will be loading up to 128 records at a time here
0337: 0680    		ld	b,128
              		
              		; Do read operation
0339: C5      	1$:	push	bc
033A: 11CD10  		ld	de,res_fcb
033D: 0E14    		ld	c,bdos_read
033F: 3AC810  		ld	a,(res_do_read)
0342: B7      		or	a
0343: C40500  		call	nz,bdos
              		
              		; Check file I/O result
0346: B7      		or	a
0347: C47003  		call	nz,50$
              		
              		; Go to virtual mode
034A: CD3E02  		call	zmm_set_virt
              		
              		; Copy record to bank
034D: 214610  		ld	hl,res_buffer
0350: ED5BCB10		ld	de,(res_pointer)
0354: 018000  		ld	bc,128
0357: EDB0    		ldir
0359: ED53CB10		ld	(res_pointer),de
              		
              		; Back to real mode
035D: CD4902  		call	zmm_set_real 
              		
              		; Get BC back to restore sector counter
0360: C1      		pop	bc
              		
              		; Decrement record count
0361: 2AC610  		ld	hl,(res_sectors)
0364: 2B      		dec	hl
0365: 22C610  		ld	(res_sectors),hl
0368: 7C      		ld	a,h
0369: B5      		or	l
036A: C8      		ret	z
              		
              		; Go get another sector
036B: 10CC    		djnz	1$
036D: C31A03  		jp	0$
              	
              		; Zero buffer and reset read flag
0370: AF      	50$:	xor	a
0371: 32C810  		ld	(res_do_read),a
              		
0374: 214610  		ld	hl,res_buffer
0377: 114710  		ld	de,res_buffer+1
037A: 017F00  		ld	bc,128-1
037D: 77      		ld	(hl),a
037E: EDB0    		ldir
              	
0380: C9      		ret
              		
              	; Throws an error a missing resource
              	; Resource name will be last attempted to locate
              	;
              	; Does not return
              	; Uses: N/A
0381:         	res_missing:
0381: CD4902  		call	zmm_set_real
              		
              		; Print error message
0384: 0E09    		ld	c,bdos_print
0386: 11310C  		ld	de,str_missing
0389: CD0500  		call	bdos
              		
              		; Print resource name
038C: ED5B4410		ld	de,(res_current)
0390: CD8104  		call	res_printzt
              		
              		; CRLF
0393: 0E09    		ld	c,bdos_print
0395: 11610D  		ld	de,str_crlf
0398: CD0500  		call	bdos
              		
              		; Exit
039B: C36109  		jp	cpm_exit
              		
              	; Opens a file based on the resource argument
              	; If the file cannot be opened, an error will be thrown
              	; (res_argument) = File to open
              	;
              	; Returns nothing
              	; Uses: all
039E:         	res_open:
              		; Virtual mode should be off while we do this
039E: 3A2E10  		ld	a,(zmm_ctrl_state)
03A1: F5      		push	af
03A2: CD4902  		call	zmm_set_real
              		
              		; Do function call
03A5: CDAF03  		call	0$
              		
              		; Restore register
03A8: F1      		pop	af
03A9: 322E10  		ld	(zmm_ctrl_state),a
03AC: C33802  		jp	zmm_ctrl_set
              		
              		; Let the user know we are loading stuff
03AF: 0E09    	0$:	ld	c,bdos_print
03B1: 11F40B  		ld	de,str_load_a
03B4: CD0500  		call	bdos
              		
              		; Print resource name
03B7: ED5B4410		ld	de,(res_current)
03BB: CD8104  		call	res_printzt
              		
              		; Next string
03BE: 0E09    		ld	c,bdos_print
03C0: 11FD0B  		ld	de,str_load_b
03C3: CD0500  		call	bdos
              		
              		; Print file name
03C6: 113310  		ld	de,res_argument
03C9: CD8104  		call	res_printzt
              		
              		; CRLF
03CC: 0E09    		ld	c,bdos_print
03CE: 11610D  		ld	de,str_crlf
03D1: CD0500  		call	bdos
              		
              		; Detect if there is an argument
03D4: 3A3310  		ld	a,(res_argument)
03D7: B7      		or	a
03D8: C2E603  		jp	nz,1$
              		
              		; No argument, error!
03DB: 0E09    		ld	c,bdos_print
03DD: 11040C  		ld	de,str_arg_empty
03E0: CD0500  		call	bdos
03E3: C36109  		jp	cpm_exit
              	
              		; Reset fields
03E6: AF      	1$:	xor	a
03E7: 21CD10  		ld	hl,res_fcb
03EA: 11CE10  		ld	de,res_fcb+1
03ED: 012300  		ld	bc ,36-1
03F0: 77      		ld	(hl),a
03F1: EDB0    		ldir
              		
03F3: 3E20    		ld	a,0x20
03F5: 21CE10  		ld	hl,res_fcb_name
03F8: 11CF10  		ld	de,res_fcb_name+1
03FB: 010A00  		ld	bc ,11-1
03FE: 77      		ld	(hl),a
03FF: EDB0    		ldir
              	
              		; Is there a prefix?
0401: 213310  		ld	hl,res_argument
0404: 3A3410  		ld	a,(res_argument+1)
0407: FE3A    		cp	':'
0409: C21B04  		jp	nz,2$
              		
              		; Set prefix
040C: 3A3310  		ld	a,(res_argument)
040F: D640    		sub	'A'-1
0411: FE11    		cp	17
0413: D27604  		jp	nc,99$
0416: 32CD10  		ld	(res_fcb_drive),a
0419: 23      		inc	hl
041A: 23      		inc	hl
              	
              		; HL = Proper filename start
041B: 0608    	2$:	ld	b,8
041D: 11CE10  		ld	de,res_fcb_name
              		
              		; Copy it over
0420: 7E      	3$:	ld	a,(hl)
0421: B7      		or	a
0422: CA7604  		jp	z,99$
0425: FE2A    		cp	'*'
0427: CA3704  		jp	z,4$
042A: FE2E    		cp	'.'
042C: CA3E04  		jp	z,5$
042F: 12      		ld	(de),a
0430: 13      		inc	de
0431: 23      		inc	hl
0432: 10EC    		djnz	3$
0434: C33E04  		jp	5$
              	
              		; Fill remains of FCB file name
0437: 3E3F    	4$:	ld	a,'?'
0439: 12      		ld	(de),a
043A: 13      		inc	de
043B: 10FA    		djnz	4$
043D: 23      		inc	hl
              	
              		; We should either see a '.' or a null character
043E: 7E      	5$:	ld	a,(hl)
043F: B7      		or	a
0440: CA6704  		jp	z,8$
0443: FE2E    		cp	'.'
0445: C27604  		jp	nz,99$
0448: 23      		inc	hl
              		
              		; Fill in extension
0449: 0603    		ld	b,3
044B: 11D610  		ld	de,res_fcb_type
              		
              		; Copy it over
044E: 7E      	6$:	ld	a,(hl)
044F: B7      		or	a
0450: CA6704  		jp	z,8$
0453: FE2A    		cp	'*'
0455: CA6004  		jp	z,7$
0458: 12      		ld	(de),a
0459: 13      		inc	de
045A: 23      		inc	hl
045B: 10F1    		djnz	6$
045D: C36704  		jp	8$
              		
              		; Fill remains of FCB file extension
0460: 3E3F    	7$:	ld	a,'?'
0462: 12      		ld	(de),a
0463: 13      		inc	de
0464: 10D1    		djnz	4$
0466: 23      		inc	hl
              	
              		; We should get a zero
0467: 7E      	8$:	ld 	a,(hl)
0468: B7      		or	a
0469: C27604  		jp	nz,99$
              		
              		; It is filled in, attempt to open
046C: 0E0F    		ld	c,bdos_open
046E: 11CD10  		ld	de,res_fcb
0471: CD0500  		call	bdos
              		
              		; Check error
0474: 3C      		inc	a
0475: C0      		ret	nz
              		
              		; Error!
0476: 0E09    	99$:	ld	c,bdos_print
0478: 111B0C  		ld	de,str_arg_fail
047B: CD0500  		call	bdos
047E: C36109  		jp	cpm_exit
              		
              		
              	; Print a zero terminated string
              	; We should be in real mode for this
              	; DE = String
              	;
              	; Returns nothing
              	; Uses: All
0481:         	res_printzt:
0481: 1A      	0$:	ld	a,(de)
0482: B7      		or	a
0483: C8      		ret	z
              		
              		; Print character
0484: D5      		push	de
0485: 5F      		ld	e,a
0486: 0E02    		ld	c,bdos_con_out
0488: CD0500  		call	bdos
048B: D1      		pop	de
048C: 13      		inc	de
048D: C38104  		jp	0$
              	
              	; Find a resource from the command line
              	; If the resource is found, the contents will be cached in memory
              	; DE = Name of resource (upper case only) 
              	;
              	; Returns A = 0xFF if no resource is found
              	; Uses: AF, BC, DE, HL
0490:         	res_locate:
              		; Save resource
0490: ED534410		ld	(res_current),de
              	
              		; Travel to the start of arguments
0494: 218100  		ld	hl,cpm_command+1
0497: 7E      	0$:	ld	a,(hl)
0498: B7      		or	a
0499: CAF604  		jp	z,99$
049C: FE21    		cp	0x21
049E: D2A504  		jp	nc,1$
04A1: 23      		inc	hl
04A2: C39704  		jp	0$
              		
              		; Found an argument
              		; Check it against the contents of (DE)
              		; Also must start with '-'
04A5: FE2D    	1$:	cp	'-'
04A7: C2B804  		jp	nz,3$
04AA: 23      		inc	hl
04AB: D5      		push	de
04AC: 1A      	2$:	ld	a,(de)
              		
              		; Check if at end of string
04AD: B7      		or	a
04AE: CAC604  		jp	z,4$
              		
              		; No? Well lets see if (de) = (hl)
04B1: BE      		cp	(hl)
04B2: 23      		inc	hl
04B3: 13      		inc	de
04B4: CAAC04  		jp	z,2$
              		
              		; Strings are different!
              		; Escape from the current argument and continue
04B7: D1      		pop	de
04B8: 7E      	3$:	ld	a,(hl)
04B9: B7      		or	a
04BA: CAF604  		jp	z,99$
04BD: FE21    		cp	0x21
04BF: DA9704  		jp	c,0$
04C2: 23      		inc	hl
04C3: C3B804  		jp	3$
              	
              		; Make sure we are at the end of the argument as well
04C6: D1      	4$: 	pop	de
04C7: 7E      		ld	a,(hl)
04C8: FE21    		cp	0x21
04CA: D2B804  		jp	nc,3$
              		
              		; Ok, lets copy the argument into memory if it exists
04CD: 113310  		ld	de,res_argument
04D0: AF      		xor	a
04D1: 12      		ld	(de),a
              		
              		; Travel to the start of the argument
04D2: 7E      	5$:	ld	a,(hl)
04D3: B7      		or	a
04D4: CAF404  		jp	z,89$
04D7: FE21    		cp	0x21
04D9: D2E004  		jp	nc,6$
04DC: 23      		inc	hl
04DD: C3D204  		jp	5$
              	
              		; Make sure it doesn't start with '-'
04E0: FE2D    	6$:	cp	'-'
04E2: CAF404  		jp	z,89$
              		
              		; Ok, lets copy up 16 bytes of this
04E5: 0610    		ld	b,arg_size
04E7: 7E      	7$:	ld	a,(hl)
04E8: FE21    		cp	0x21
04EA: DAF204  		jp	c,8$
04ED: 12      		ld	(de),a
04EE: 23      		inc	hl
04EF: 13      		inc	de
04F0: 10F5    		djnz	7$
              	
              		; Zero terminate
04F2: AF      	8$:	xor	a
04F3: 12      		ld	(de),a
              		
              		; Good ending
04F4: AF      	89$:	xor	a
04F5: C9      		ret
              	
              		; Bad ending
04F6: 3EFF    	99$:	ld	a,0xFF
04F8: C9      		ret
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Loading string components
0BF4:         	str_load_a:
0BF4: 4C4F4144		defb	'LOADING $'
0BF8: 494E4720	
0BFC: 24      	
              		
0BFD:         	str_load_b:
0BFD: 2046524F		defb	' FROM $'
0C01: 4D2024  	
              		
              	; Error messages
0C04:         	str_arg_empty:
0C04: 4E4F2041		defb	'NO ARGUMENT PROVIDED',0x0A,0x0D,'$'
0C08: 5247554D	
0C0C: 454E5420	
0C10: 50524F56	
0C14: 49444544	
0C18: 0A0D24  	
              		
0C1B:         	str_arg_fail:
0C1B: 4641494C		defb	'FAILED TO OPEN FILE',0x0A,0x0D,'$'
0C1F: 45442054	
0C23: 4F204F50	
0C27: 454E2046	
0C2B: 494C450A	
0C2F: 0D24    	
              		
0C31:         	str_missing:
0C31: 4D495353		defb	'MISSING RESOURCE: $'
0C35: 494E4720	
0C39: 5245534F	
0C3D: 55524345	
0C41: 3A2024  	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Stores a zero-terminated string for the resource argument
1033:         	res_argument:
1033: 00000000		defs	arg_size+1
1037: 00...   	
              		
              	; Current resource being accessed
1044:         	res_current:
1044: 0000    		defs	2
              		
              	; Resource buffer
1046:         	res_buffer:
1046: 00000000		defs	128
104A: 00...   	
              		
              	; Sector counter
10C6:         	res_sectors:
10C6: 0000    		defs	2
              		
              	; Do we need to read?
10C8:         	res_do_read:
10C8: 00      		defs	1
              		
              	; Resource bankmap
10C9:         	res_bankmap:
10C9: 0000    		defs	2
              		
              	; Loading pointer
10CB:         	res_pointer:
10CB: 0000    		defs	2
              		
              	; File control block for use in loading resources
10CD:         	res_fcb:
10CD: 00000000		defs	36
10D1: 00...   	
10CD:         	res_fcb_drive	equ	res_fcb
10CE:         	res_fcb_name	equ	res_fcb+1
10D6:         	res_fcb_type	equ	res_fcb+9
10D9:         	res_fcb_ex	equ	res_fcb+12
10DA:         	res_fcb_s1	equ	res_fcb+13
10DB:         	res_fcb_s2	equ	res_fcb+14
10DC:         	res_fcb_rc	equ	res_fcb+15
10DD:         	res_fcb_data	equ	res_fcb+16
10ED:         	res_fcb_cr	equ	res_fcb+32
10EE:         	res_fcb_r0	equ	res_fcb+33
10EF:         	res_fcb_r1	equ	res_fcb+34
10F0:         	res_fcb_r2	equ	res_fcb+35
              	#include "TRAP.asm"
              	;
              	;********************************************************************
              	;*
              	;*                     T R A P   H A N D L E R
              	;* 
              	;*    Responsible for handling various traps from the ZMM. Both
              	;*    interrupt and I/O traps will be pre-processed before being
              	;*    sent to the virtualization core for device-specific handling
              	;*
              	;********************************************************************
              	
              	; -------------------------------
              	; ********  Trap Handler ********
              	; -------------------------------
              	
              	.area	_TEXT
              	
              	; Entry point for traps
04F9:         	trap_entry:
              		; Save value of SP
04F9: ED73F110		ld	(trap_sp_value),sp
04FD: 310070  		ld	sp,kri_stack
              		
              		; Save value of AF
0500: F5      		push	af
              		
              		; Check in on device interrupts
0501: CD480B  		call	irq_handle
              		
              		; Grab the value of the ISR register
0504: DB30    		in	a,(zmm_isr)
              		
              		; Do we actually need to handle an I/O trap?
0506: B7      		or	a
0507: F2E206  		jp	p,trap_continue
              		
              		; OK, a trap did occur.
              		; Are we doing "classic" I/O or extended I/O?
050A:         	trap_io:	
050A: FEE8    		cp	0b11101000
050C: DA2605  		jp	c,trap_io_ext
              		
              		; In or out?
050F: FEEC    		cp	0b11101100
0511: DA1D05  		jp	c,0$
              		
              		; In it is
0514: CD5D0B  		call	in_handle
0517: 32FF6F  		ld	(trap_a_value),a
051A: C3E206  		jp	trap_continue
              		
              		; Out it is
051D: 3AFF6F  	0$:	ld	a,(trap_a_value)
0520: CD8F0B  		call	out_handle
0523: C3E206  		jp	trap_continue
              	
              	
              	; It's an extended I/O instruction
0526:         	trap_io_ext:
              	
              		; Input or output?
0526: 0F      		rrca
0527: DA9C05  		jp	c,trap_io_ex_out
              		
              		; Extended input instruction
              		; INI-class?
052A: 0F      		rrca
052B: DAF605  		jp	c,trap_io_inx
              		
              		; Left or right column
052E: 0F      		rrca
052F: DA5905  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
0532: 0F      		rrca
0533: DA4805  		jp	c,1$
              		
              		; B or H?
0536: 0F      		rrca
0537: DA4105  		jp	c,2$
              		
              		; It's B
053A: CD5D0B  		call	in_handle
053D: 47      		ld	b,a
053E: C38305  		jp	90$
              		
              		; It's H	
0541: CD5D0B  	2$:	call	in_handle
0544: 67      		ld	h,a
0545: C38305  		jp	90$
              	
              		; D or 0?
0548: 0F      	1$:	rrca
0549: DA5305  		jp	c,3$
              	
              		; It's D
054C: CD5D0B  		call	in_handle
054F: 57      		ld	d,a
0550: C38305  		jp	90$
              		
              		; It's 0
0553: CD5D0B  	3$:	call	in_handle
0556: C38305  		jp	90$
              		
              		
              		; Right column
              		; C, E, L, or A?
0559: 0F      	0$:	rrca
055A: DA6F05  		jp	c,4$
              		
              		; C or L?
055D: 0F      		rrca
055E: DA6805  		jp	c,5$
              		
              		; It's C
0561: CD5D0B  		call	in_handle
0564: 4F      		ld	c,a
0565: C38305  		jp	90$
              	
              		; It's L
0568: CD5D0B  	5$:	call	in_handle
056B: 6F      		ld	l,a
056C: C38305  		jp	90$
              		
              		; E or A?
056F: 0F      	4$:	rrca
0570: DA7A05  		jp	c,6$
              		
              		; It's E
0573: CD5D0B  		call	in_handle
0576: 5F      		ld	e,a
0577: C38305  		jp	90$
              	
              		; It's A
057A: CD5D0B  	6$:	call	in_handle
057D: 32FF6F  		ld	(trap_a_value),a
0580: C38305  		jp	90$
              		
              		; Extended IN instructions require special flag states
              		; lets set them and return
0583: E5      	90$:	push	hl
0584: 21FE6F  		ld	hl,trap_f_value
0587: CB46    		bit	0,(hl)
0589: E1      		pop	hl
              		
              		; If it's zero, we don't need the carry flag
058A: CA9505  		jp	z,91$ 
              		
              		; Update flags and persist carry flag
058D: B7      		or	a
058E: 37      		scf
058F: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Do trap restore
0592: C3E306  		jp	trap_restore
              		
              		; Update flags and reset carry flag
0595: B7      	91$:	or	a
0596: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Do trap restore
0599: C3E306  		jp	trap_restore
              		
              	; Extended output instruction
059C:         	trap_io_ex_out:
              	
              		; OUTI-class?
059C: 0F      		rrca
059D: DA6C06  		jp	c,trap_io_outx
              		
              		; Left or right column?
05A0: 0F      		rrca
05A1: DACC05  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
05A4: 0F      		rrca
05A5: DABA05  		jp	c,1$
              		
              		; B or H?
05A8: 0F      		rrca
05A9: DAB305  		jp	c,2$
              		
              		; It's B
05AC: 78      		ld	a,b
05AD: CD8F0B  		call	out_handle
05B0: C3E206  		jp	trap_continue
              		
              		; It's H	
05B3: 7C      	2$:	ld	a,h
05B4: CD8F0B  		call	out_handle
05B7: C3E206  		jp	trap_continue
              	
              		; D or 0?
05BA: 0F      	1$:	rrca
05BB: DAC505  		jp	c,3$
              	
              		; It's D
05BE: 7A      		ld	a,d
05BF: CD8F0B  		call	out_handle
05C2: C3E206  		jp	trap_continue
              		
              		; It's 0
05C5: AF      	3$:	xor	a
05C6: CD8F0B  		call	out_handle
05C9: C3E206  		jp	trap_continue
              		
              		
              		; Right column
              		; C, E, L, or A?
05CC: 0F      	0$:	rrca
05CD: DAE205  		jp	c,4$
              		
              		; C or L?
05D0: 0F      		rrca
05D1: DADB05  		jp	c,5$
              		
              		; It's C
05D4: 79      		ld	a,c
05D5: CD8F0B  		call	out_handle
05D8: C3E206  		jp	trap_continue
              	
              		; It's L
05DB: 7D      	5$:	ld	a,l
05DC: CD8F0B  		call	out_handle
05DF: C3E206  		jp	trap_continue
              		
              		; E or A?
05E2: 0F      	4$:	rrca
05E3: DAED05  		jp	c,6$
              		
              		; It's E
05E6: 7B      		ld	a,e
05E7: CD8F0B  		call	out_handle
05EA: C3E206  		jp	trap_continue
              	
              		; It's A
05ED: 3AFF6F  	6$:	ld	a,(trap_a_value)
05F0: CD8F0B  		call	out_handle
05F3: C3E206  		jp	trap_continue
              	
              	
              		; INX class instructions
              		; The CPU should handle the differences between INX and INXR
05F6:         	trap_io_inx:
              		; Left or right column?
05F6: 0F      		rrca
05F7: DA3306  		jp	c,trap_io_ind
              		
              		; Left column, it's 'I' class
05FA: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
05FB: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
05FC: 7C      		ld	a,h
05FD: 07      		rlca
05FE: DA1106  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0601: 07      		rlca
0602: DA0B06  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0605: 3A2F10  		ld	a,(zmm_bnk0_state)
0608: C31E06  		jp	3$
              		
              		; 0x4000 - 0x7FFF
060B: 3A3010  	1$:	ld	a,(zmm_bnk1_state)
060E: C31E06  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0611: 07      	0$:	rlca
0612: DA1B06  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
0615: 3A3110  		ld	a,(zmm_bnk2_state)
0618: C31E06  		jp	3$
              	
              		; 0xC000 - 0xFFFF
061B: 3A3210  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
061E: E67F    	3$:	and	0b01111111
0620: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0622: 3EC0    		ld	a,0b11000000
0624: B4      		or	h
0625: 67      		ld	h,a
              		
              		; Do the input
0626: CD5D0B  		call	in_handle
0629: 77      		ld	(hl),a
              		
              		; Fix banks
062A: 3A3210  		ld	a,(zmm_bnk3_state)
062D: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
062F: E1      		pop	hl
0630: C3E206  		jp	trap_continue
              		
              		; Right column, it's 'D' class
0633:         	trap_io_ind:
0633: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0634: 23      		inc	hl	; Increment to reverse 'D' class instruction
0635: 7C      		ld	a,h
0636: 07      		rlca
0637: DA4A06  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
063A: 07      		rlca
063B: DA4406  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
063E: 3A2F10  		ld	a,(zmm_bnk0_state)
0641: C35706  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0644: 3A3010  	1$:	ld	a,(zmm_bnk1_state)
0647: C35706  		jp	3$
              			
              		; 0x8000 - 0xFFFF
064A: 07      	0$:	rlca
064B: DA5406  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
064E: 3A3110  		ld	a,(zmm_bnk2_state)
0651: C35706  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0654: 3A3210  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0657: E67F    	3$:	and	0b01111111
0659: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
065B: 3EC0    		ld	a,0b11000000
065D: B4      		or	h
065E: 67      		ld	h,a
              		
              		; Do the input
065F: CD5D0B  		call	in_handle
0662: 77      		ld	(hl),a
              		
              		; Fix banks
0663: 3A3210  		ld	a,(zmm_bnk3_state)
0666: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0668: E1      		pop	hl
0669: C3E206  		jp	trap_continue
              	
              		; OUTX-class instructions
              		; The CPU should handle the differences between OUTX and OTXR
066C:         	trap_io_outx:
              	
              		; Left or right column?
066C: 0F      		rrca
066D: DAA906  		jp	c,trap_io_outd
              		
              		; Left column, it's 'I' class
0670: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0671: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
0672: 7C      		ld	a,h
0673: 07      		rlca
0674: DA8706  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0677: 07      		rlca
0678: DA8106  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
067B: 3A2F10  		ld	a,(zmm_bnk0_state)
067E: C39406  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0681: 3A3010  	1$:	ld	a,(zmm_bnk1_state)
0684: C39406  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0687: 07      	0$:	rlca
0688: DA9106  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
068B: 3A3110  		ld	a,(zmm_bnk2_state)
068E: C39406  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0691: 3A3210  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0694: E67F    	3$:	and	0b01111111
0696: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0698: 3EC0    		ld	a,0b11000000
069A: B4      		or	h
069B: 67      		ld	h,a
              		
              		; Do the output
069C: 7E      		ld	a,(hl)
069D: CD8F0B  		call	out_handle
              		
              		; Fix banks
06A0: 3A3210  		ld	a,(zmm_bnk3_state)
06A3: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
06A5: E1      		pop	hl
              		
06A6: C3E206  		jp	trap_continue
              		
              		; Right column, it's 'D' class
06A9:         	trap_io_outd:
06A9: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
06AA: 23      		inc	hl	; Increment to reverse 'D' class instruction
06AB: 7C      		ld	a,h
06AC: 07      		rlca
06AD: DAC006  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
06B0: 07      		rlca
06B1: DABA06  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
06B4: 3A2F10  		ld	a,(zmm_bnk0_state)
06B7: C3CD06  		jp	3$
              		
              		; 0x4000 - 0x7FFF
06BA: 3A3010  	1$:	ld	a,(zmm_bnk1_state)
06BD: C3CD06  		jp	3$
              			
              		; 0x8000 - 0xFFFF
06C0: 07      	0$:	rlca
06C1: DACA06  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
06C4: 3A3110  		ld	a,(zmm_bnk2_state)
06C7: C3CD06  		jp	3$
              	
              		; 0xC000 - 0xFFFF
06CA: 3A3210  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
06CD: E67F    	3$:	and	0b01111111
06CF: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
06D1: 3EC0    		ld	a,0b11000000
06D3: B4      		or	h
06D4: 67      		ld	h,a
              		
              		; Do the output
06D5: 7E      		ld	a,(hl)
06D6: CD8F0B  		call	out_handle
              		
              		; Fix banks
06D9: 3A3210  		ld	a,(zmm_bnk3_state)
06DC: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
06DE: E1      		pop	hl
06DF: C3E206  		jp	trap_continue
              	
              		
              	; Continue execution
06E2:         	trap_continue:
              		; Restore AF
06E2: F1      		pop	af
              		
              		; Restore stack and return
              		; Maybe invoke the debugger as well
06E3:         	trap_restore:
              		
              		; Reset trap state
06E3:         	trap_res_flag:
06E3: 00      		nop
06E4: 00      		nop
06E5: 00      		nop
06E6: D337    		out	(zmm_trap),a
              		
              		; Restore old SP
06E8: ED7BF110		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
06EC: 00      		nop
06ED: ED45    		retn
              		
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize trap handling stuff
              	;
              	; Returns nothing
              	; Uses: AF, HL
06EF:         	trap_init:
              		; Install trap vector
06EF: 3EC3    		ld	a,0xC3
06F1: 326600  		ld	(nmi_address),a
06F4: 21F904  		ld	hl,trap_entry
06F7: 226700  		ld	(nmi_vector),hl
              		
06FA: C9      		ret
              		
              		
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value of untrapped SP value
10F1:         	trap_sp_value:
10F1: 0000    		defs	2
              	#include "IRQ.asm"
              	;
              	;********************************************************************
              	;*
              	;*             I N T E R R U P T   M A N A G E M E N T
              	;* 
              	;*    Manages "real" system interrupts on the host hardware.
              	;*    Also deals with mocking interrupts to the virtual machine
              	;*    if it is needed.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize interrupt stuff
              	;
              	; Returns nothing
              	; Uses: AF
06FB:         	irq_init:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06FB: 3E07    		ld	a,7		; AY register = 7
06FD: D341    		out	(nabu_ay_latch),a
06FF: DB40    		in	a,(nabu_ay_data)
0701: E63F    		and	0x3F
0703: F640    		or	0x40
0705: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off all interrupts
0707: 3E0E    		ld	a,14		; AY register = 14	
0709: D341    		out	(nabu_ay_latch),a
070B: AF      		xor	a
070C: D340    		out	(nabu_ay_data),a
070E: 32F310  		ld	(irq_mask_state),a
              		
              		; Return
0711: C9      		ret
              		
              		
              	; Turns on the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
0712:         	irq_vdp_on:
0712: 3AF310  		ld	a,(irq_mask_state)
0715: F610    		or	0b00010000
0717: 32F310  		ld	(irq_mask_state),a
              		
071A: C37D07  		jp	irq_restore
              		
              	; Turns off the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
071D:         	irq_vdp_off:
071D: 3AF310  		ld	a,(irq_mask_state)
0720: E6EF    		and	~0b00010000
0722: 32F310  		ld	(irq_mask_state),a
              		
0725: C37D07  		jp	irq_restore
              		
              	; Turns on the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
0728:         	irq_keyb_on:
0728: 3AF310  		ld	a,(irq_mask_state)
072B: F620    		or	0b00100000
072D: 32F310  		ld	(irq_mask_state),a
              		
0730: C37D07  		jp	irq_restore
              		
              	; Turns off the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
0733:         	irq_keyb_off:
0733: 3AF310  		ld	a,(irq_mask_state)
0736: E6DF    		and	~0b00100000
0738: 32F310  		ld	(irq_mask_state),a
              		
073B: C37D07  		jp	irq_restore
              	
              	; Turns on the HCCA output
              	;
              	; Returns nothing
              	; Uses: AF
073E:         	irq_hcca_o_on:
073E: 3AF310  		ld	a,(irq_mask_state)
0741: F640    		or	0b01000000
0743: 32F310  		ld	(irq_mask_state),a
              		
0746: C37D07  		jp	irq_restore
              		
              	; Turns off the HCCA output
              	;
              	; Returns nothing
              	; Uses: AF
0749:         	irq_hcca_o_off:
0749: 3AF310  		ld	a,(irq_mask_state)
074C: E6BF    		and	~0b01000000
074E: 32F310  		ld	(irq_mask_state),a
              		
0751: C37D07  		jp	irq_restore
              		
              	; Turns on the HCCA input
              	;
              	; Returns nothing
              	; Uses: AF
0754:         	irq_hcca_i_on:
0754: 3AF310  		ld	a,(irq_mask_state)
0757: F680    		or	0b10000000
0759: 32F310  		ld	(irq_mask_state),a
              		
075C: C37D07  		jp	irq_restore
              		
              	; Turns off the HCCA input
              	;
              	; Returns nothing
              	; Uses: AF
075F:         	irq_hcca_i_off:
075F: 3AF310  		ld	a,(irq_mask_state)
0762: E67F    		and	~0b10000000
0764: 32F310  		ld	(irq_mask_state),a
              		
0767: C37D07  		jp	irq_restore
              		
              	; Returns the IRQ status byte
              	;
              	; Returns A = IRQ status
              	; Uses: AF
076A:         	irq_status:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
076A: 3E07    		ld	a,7		; AY register = 7
076C: D341    		out	(nabu_ay_latch),a
076E: DB40    		in	a,(nabu_ay_data)
0770: E63F    		and	0x3F
0772: F640    		or	0x40
0774: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
0776: 3E0F    		ld	a,15		; AY register = 15	
0778: D341    		out	(nabu_ay_latch),a
077A: DB40    		in	a,(nabu_ay_data)
077C: C9      		ret
              		
              	; Restore the IRQ mask from 
              	;
              	; Returns nothing
              	; Uses: AF
077D:         	irq_restore:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
077D: 3E07    		ld	a,7		; AY register = 7
077F: D341    		out	(nabu_ay_latch),a
0781: DB40    		in	a,(nabu_ay_data)
0783: E63F    		and	0x3F
0785: F640    		or	0x40
0787: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
0789: 3E0E    		ld	a,14		; AY register = 14	
078B: D341    		out	(nabu_ay_latch),a
078D: 3AF310  		ld	a,(irq_mask_state)
0790: D340    		out	(nabu_ay_data),a
0792: C9      		ret
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value interrupt mask
10F3:         	irq_mask_state:
10F3: 00      		defs	1
              	#include "DEBUG.asm"
              	;
              	;**************************************************************
              	;*
              	;*        V I R T U A L   M A C H I N E   D E B U G G E R
              	;*
              	;*    Proves a machine-language monitor for debugging the
              	;*    virtual machine. Does standard monitor stuff.
              	;* 
              	;**************************************************************
              	
              	; ---------------------------
              	; ********  Debugger ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Handle for the debugger
0793:         	debug_handle:
              	
              		; Save machine context
0793: ED73F710		ld	(debug_temp),sp
0797: 311211  		ld	sp,debug_state
              		
              		; Dump registers
079A: F5      		push	af
079B: C5      		push	bc
079C: D5      		push	de
079D: E5      		push	hl
079E: D9      		exx
079F: 08      		ex	af,af'
07A0: F5      		push	af
07A1: C5      		push	bc
07A2: D5      		push	de
07A3: E5      		push	hl
07A4: DDE5    		push	ix
07A6: FDE5    		push	iy
              		
07A8: ED7BF710		ld	sp,(debug_temp)
              		
              		; Check to see if we are skipping over stuff
07AC: 3AFB10  		ld	a,(debug_f_over)
07AF: B7      		or	a
07B0: CAC307  		jp	z,0$
              		
              		; Check stack pointer
07B3: 2AF110  		ld	hl,(trap_sp_value)
07B6: ED5BFC10		ld	de,(debug_over_sp)
07BA: ED52    		sbc	hl,de
07BC: C2A508  		jp	nz,debug_continue
              		
              		; Reset over flag
07BF: AF      		xor	a
07C0: 32FB10  		ld	(debug_f_over),a
              		
07C3:         	0$:
              		
              		; Debugger stuff starts here
              		; Populate register dump string
07C3: 011211  		ld	bc,debug_state
07C6: 218D0C  		ld	hl,str_rdump_af
07C9: CDC708  		call	debug_rtohex
07CC: 21960C  		ld	hl,str_rdump_bc
07CF: CDC708  		call	debug_rtohex
07D2: 219F0C  		ld	hl,str_rdump_de
07D5: CDC708  		call	debug_rtohex
07D8: 21A80C  		ld	hl,str_rdump_hl
07DB: CDC708  		call	debug_rtohex
07DE: 21B50C  		ld	hl,str_rdump_aaf
07E1: CDC708  		call	debug_rtohex
07E4: 21BE0C  		ld	hl,str_rdump_abc
07E7: CDC708  		call	debug_rtohex
07EA: 21C70C  		ld	hl,str_rdump_ade
07ED: CDC708  		call	debug_rtohex
07F0: 21D00C  		ld	hl,str_rdump_ahl
07F3: CDC708  		call	debug_rtohex
07F6: 21DD0C  		ld	hl,str_rdump_ix
07F9: CDC708  		call	debug_rtohex
07FC: 21E60C  		ld	hl,str_rdump_iy
07FF: CDC708  		call	debug_rtohex
              		
              		; Display stack pointer
0802: 2AF110  		ld	hl,(trap_sp_value)
0805: 23      		inc	hl
0806: 23      		inc	hl
0807: 7C      		ld	a,h
0808: CD6909  		call	tohex
080B: ED53530C		ld	(str_rdump_sp),de
080F: 7D      		ld	a,l
0810: CD6909  		call	tohex
0813: ED53550C		ld	(str_rdump_sp+2),de
              			
              		; Extract PC from capture area
0817: 2AF110  		ld	hl,(trap_sp_value)
081A: 7C      		ld	a,h
081B: E67F    		and	zmm_capt_res
081D: F670    		or	zmm_capt_set
081F: 67      		ld	h,a
0820: 7E      		ld	a,(hl)
0821: 32F910  		ld	(debug_pc_state),a
0824: CD6909  		call	tohex
0827: ED534C0C		ld	(str_rdump_pc+2),de
082B: 23      		inc	hl
082C: 7C      		ld	a,h
082D: E67F    		and	zmm_capt_res
082F: F670    		or	zmm_capt_set
0831: 67      		ld	h,a
0832: 7E      		ld	a,(hl)
0833: 32FA10  		ld	(debug_pc_state+1),a
0836: CD6909  		call	tohex
0839: ED534A0C		ld	(str_rdump_pc),de
              		
              		; Display instruction
083D: 2AF910  		ld	hl,(debug_pc_state)
0840: CD6501  		call	mem_fvbyte
0843: CD6909  		call	tohex
0846: ED535E0C		ld	(str_rdump_isr),de
084A: 23      		inc	hl
084B: CD6501  		call	mem_fvbyte
084E: CD6909  		call	tohex
0851: ED53600C		ld	(str_rdump_isr+2),de
0855: 23      		inc	hl
0856: CD6501  		call	mem_fvbyte
0859: CD6909  		call	tohex
085C: ED53620C		ld	(str_rdump_isr+4),de
0860: 23      		inc	hl
0861: CD6501  		call	mem_fvbyte
0864: CD6909  		call	tohex
0867: ED53640C		ld	(str_rdump_isr+6),de
              		
              		; Print
086B: 11440C  		ld	de,str_rdump
086E: CD2709  		call	cpm_print
              		
              	; Query the user for an operation to perform
0871:         	debug_query:
0871: CD4D09  		call	cpm_getc
0874: 79      		ld	a,c
              		
              		; Exit?
0875: FE51    		cp	'Q'
0877: CA6109  		jp	z,cpm_exit
              		
              		; Over?
087A: FE4F    		cp	'O'
087C: CA8708  		jp	z,debug_over
              		
              		; Upper?
087F: FE55    		cp	'U'
0881: CA9508  		jp	z,debug_upper
              		
              		
              		; Ok, just continue then
0884: C3A508  		jp	debug_continue
              	
              	
              	;	ld	de,str_prompt
              	;	call	cpm_print
              	;	ld	de,input_buff
              	;	call	cpm_input
              	
              		
              	; Do not enter debugger until stack is equal to the original value
0887:         	debug_over:
0887: 2AF110  		ld	hl,(trap_sp_value)
088A: 22FC10  		ld	(debug_over_sp),hl
              		
088D: 3EFF    		ld	a,0xFF
088F: 32FB10  		ld	(debug_f_over),a
              		
0892: C3A508  		jp	debug_continue
              		
              	; Do not enter debugger until current function has been returned from
0895:         	debug_upper:
0895: 2AF110  		ld	hl,(trap_sp_value)
0898: 23      		inc	hl
0899: 23      		inc	hl
089A: 22FC10  		ld	(debug_over_sp),hl
              		
089D: 3EFF    		ld	a,0xFF
089F: 32FB10  		ld	(debug_f_over),a
              		
08A2: C3A508  		jp	debug_continue	
              		
              	; Go back to the virutal machine
08A5:         	debug_continue:
              		
              		; Restore IRQ state
08A5: CD7D07  		call	irq_restore
              		
              		; Restore machine context
08A8: ED73F710		ld	(debug_temp),sp
08AC: 31FE10  		ld	sp,debug_state-20
              		
              		; Restore registers
08AF: FDE1    		pop	iy
08B1: DDE1    		pop	ix
08B3: E1      		pop	hl
08B4: D1      		pop	de
08B5: C1      		pop	bc
08B6: F1      		pop	af
08B7: D9      		exx
08B8: 08      		ex	af,af'
08B9: E1      		pop	hl
08BA: D1      		pop	de
08BB: C1      		pop	bc
08BC: F1      		pop	af
              		
              		; Go back to trap handler
08BD: ED7BF710		ld	sp,(debug_temp)
08C1: C9      		ret
              	
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	
              	; Initalize the debugger
              	;
              	; Returns nothing
              	; Uses: AF
08C2:         	debug_init:
              		
              		; Reset flags
08C2: AF      		xor	a
08C3: 32FB10  		ld	(debug_f_over),a
              		
08C6: C9      		ret
              	
              	; Converts a register to hexadecimal
              	; BC = Address of register value
              	; HL = Address of hex string
              	;
              	; Returns BC=BC=2
              	; Uses: AF, BC, DE, HL
08C7:         	debug_rtohex:
08C7: 0B      		dec	bc
08C8: 0A      		ld	a,(bc)
08C9: C5      		push	bc
08CA: CD6909  		call	tohex
08CD: C1      		pop	bc
08CE: 73      		ld	(hl),e
08CF: 23      		inc	hl
08D0: 72      		ld	(hl),d
08D1: 23      		inc	hl
08D2: 0B      		dec	bc
08D3: 0A      		ld	a,(bc)
08D4: C5      		push	bc
08D5: CD6909  		call 	tohex
08D8: C1      		pop	bc
08D9: 73      		ld	(hl),e
08DA: 23      		inc	hl
08DB: 72      		ld	(hl),d
08DC: C9      		ret
              	
              	; Bind the debugger to the trap handler
              	; Any trap can now be used to invoke the machine language monitor
              	;
              	; Returns nothing
              	; Uses: A, HL
08DD:         	debug_bind:
              	
              		; Save previous binding
08DD: 3AE306  		ld	a,(trap_res_flag)
08E0: 2AE406  		ld	hl,(trap_res_flag+1)
08E3: 32F410  		ld	(debug_pbind),a
08E6: 22F510  		ld	(debug_pbind+1),hl
              		
              		; Bind debugger handle
08E9: 3ECD    		ld	a,0xCD
08EB: 219307  		ld	hl,debug_handle
08EE: 32E306  		ld	(trap_res_flag),a
08F1: 22E406  		ld	(trap_res_flag+1),hl
              		
08F4: C9      		ret
              		
              	; Unbind the debugger and allow traps to process normally
              	;
              	; Returns nothjing
              	; Uses: A, HL
08F5:         	debug_unbind:
              		
              		; Restore previous binding
08F5: 3AF410  		ld	a,(debug_pbind)
08F8: 2AF510  		ld	hl,(debug_pbind+1)
08FB: 32E306  		ld	(trap_res_flag),a
08FE: 22E406  		ld	(trap_res_flag+1),hl
              		
0901: C9      		ret
              		
              		
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Register dump string
0C44:         	str_rdump:
0C44: 1E17    		defb	0x1E,0x17
0C46: 50433A20		defb	'PC: '
0C4A:         	str_rdump_pc:
0C4A: 58585858		defb	'XXXX SP: '
0C4E: 2053503A	
0C52: 20      	
0C53:         	str_rdump_sp:
0C53: 58585858		defb	'XXXX NEXT: '
0C57: 204E4558	
0C5B: 543A20  	
0C5E:         	str_rdump_isr:
0C5E: 58585858		defb	'XXXXXXXX',0x0A,0x0D
0C62: 58585858	
0C66: 0A0D    	
              	
0C68: 464C4147		defb	'FLAGS: '
0C6C: 533A20  	
0C6F:         	str_rdump_flag:
0C6F: 2D2D2D2D		defb	'-------- EI: '
0C73: 2D2D2D2D	
0C77: 2045493A	
0C7B: 20      	
0C7C:         	str_rdump_ei:
0C7C: 2D20492F		defb	'- I/O: '
0C80: 4F3A20  	
0C83:         	str_rdump_io:
0C83: 2D0A0D  		defb	'-',0x0A,0x0D
              		
0C86: 523D2041		defb	'R= AF: '
0C8A: 463A20  	
0C8D:         	str_rdump_af:
0C8D: 58585858		defb	'XXXX BC: '
0C91: 2042433A	
0C95: 20      	
0C96:         	str_rdump_bc:
0C96: 58585858		defb	'XXXX DE: '
0C9A: 2044453A	
0C9E: 20      	
0C9F:         	str_rdump_de:
0C9F: 58585858		defb	'XXXX HL: '
0CA3: 20484C3A	
0CA7: 20      	
0CA8:         	str_rdump_hl:
0CA8: 58585858		defb	'XXXX',0x0A,0x0D
0CAC: 0A0D    	
              		
0CAE: 583D2041		defb	'X= AF: '
0CB2: 463A20  	
0CB5:         	str_rdump_aaf:
0CB5: 58585858		defb	'XXXX BC: '
0CB9: 2042433A	
0CBD: 20      	
0CBE:         	str_rdump_abc:
0CBE: 58585858		defb	'XXXX DE: '
0CC2: 2044453A	
0CC6: 20      	
0CC7:         	str_rdump_ade:
0CC7: 58585858		defb	'XXXX HL: '
0CCB: 20484C3A	
0CCF: 20      	
0CD0:         	str_rdump_ahl:
0CD0: 58585858		defb	'XXXX',0x0A,0x0D
0CD4: 0A0D    	
              		
0CD6: 453D2049		defb	'E= IX: '
0CDA: 583A20  	
0CDD:         	str_rdump_ix:
0CDD: 58585858		defb	'XXXX IY: '
0CE1: 2049593A	
0CE5: 20      	
0CE6:         	str_rdump_iy:
0CE6: 58585858		defb	'XXXX',0x0A,0x0D,'$'
0CEA: 0A0D24  	
              		
              	; Debug prompt
0CED:         	str_prompt
0CED: 0A0D2A24		defb	0x0A,0x0D,'*','$'
              		
              	; Input buffer
0CF1:         	input_buff:
0CF1: 28      		defb	40
0CF2: 00000000		defs	41
0CF6: 00...   	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Previous trap bind
10F4:         	debug_pbind:
10F4: 000000  		defs	3
              		
              	; General purpose memory register
              	; Usually used in context swaps
10F7:         	debug_temp:
10F7: 0000    		defs	2
              		
              	; Debug program counter value
10F9:         	debug_pc_state:
10F9: 0000    		defs	2
              		
              	; Debug skip over flag
10FB:         	debug_f_over:
10FB: 00      		defs	1
              		
              	; Debug skip over stack value
10FC:         	debug_over_sp:
10FC: 0000    		defs	2
              		
              	; Machine state
              	; IY	-20
              	; IX	-18
              	; 'HL	-16
              	; 'DE	-14
              	; 'BC	-12
              	; 'AF 	-10
              	; HL	-8
              	; DE	-6
              	; BC	-4
              	; AF	-2
              	; --- TOP ---
10FE: 00000000		defs	20
1102: 00...   	
1112:         	debug_state:
              	
              	; --------------------------------
              	; ******** KRISYS Startup ********
              	; --------------------------------
              	
              	.area	_TEXT
              		
              		; KRISYS entry point
0902:         	kri_start:	
              		; Set up stack
0902: F3      		di
0903: 310070  		ld	sp,kri_stack
0906: 216109  		ld	hl,cpm_exit
0909: E5      		push	hl
              		
              		; Print "hello" splash
090A: 0E09    		ld	c,bdos_print
090C: 111B0D  		ld	de,str_splash
090F: CD0500  		call	bdos
              		
              		; Initalize subcomponents
0912: CDFB06  		call	irq_init
0915: CDE401  		call	zmm_init
0918: CDEF06  		call	trap_init
091B: CD0301  		call	mem_map_init
091E: CDEE02  		call	res_init
0921: CDC208  		call 	debug_init
              		
              		; Start the core
0924: C3370A  		jp	core_start
              		
              	; ------------------------------
              	; ******** CP/M Service ********
              	; ------------------------------
              		
              	; Print something to the CP/M console
              	; DE = Address of string to print
              	;
              	; Returns nothing
              	; Uses: All
0927:         	cpm_print:
              		; Save control register state
0927: 3A2E10  		ld	a,(zmm_ctrl_state)
092A: F5      		push	af
              		
              		; Go to real mode
092B: CD4902  		call zmm_set_real
              		
              		; Do BDOS call
092E: 0E09    		ld	c,bdos_print
0930: CD0500  		call	bdos
              		
              		; Restore register
0933: F1      		pop	af
0934: 322E10  		ld	(zmm_ctrl_state),a
0937: C33802  		jp	zmm_ctrl_set
              		
              	; Gets a line of input from the console
              	; DE = Address of result
              	;
              	; Returns nothing
              	; Uses: All
093A:         	cpm_input:
              		; Save control register state
093A: 3A2E10  		ld	a,(zmm_ctrl_state)
093D: F5      		push	af
              		
              		; Go to real mode
093E: CD4902  		call zmm_set_real
              		
              		; Do BDOS call
0941: 0E0A    		ld	c,bdos_input
0943: CD0500  		call	bdos
              		
              		; Restore register
0946: F1      		pop	af
0947: 322E10  		ld	(zmm_ctrl_state),a
094A: C33802  		jp	zmm_ctrl_set
              		
              	; Gets a character from the console
              	;
              	; Returns C = character returns
              	; Uses: All
094D:         	cpm_getc:
              		; Save control register state
094D: 3A2E10  		ld	a,(zmm_ctrl_state)
0950: F5      		push	af
              		
              		; Go to real mode
0951: CD4902  		call zmm_set_real
              		
              		; Do BDOS call
0954: 0E01    		ld	c,bdos_con_in
0956: CD0500  		call	bdos
0959: 4F      		ld	c,a
              		
              		; Restore register
095A: F1      		pop	af
095B: 322E10  		ld	(zmm_ctrl_state),a
095E: C33802  		jp	zmm_ctrl_set
              		
              	; Go back to CP/M
              	;
              	; Does not return
              	; Uses: N/A
0961:         	cpm_exit:
0961: CD4902  		call	zmm_set_real
0964: 0E00    		ld	c,bdos_exit
0966: CD0500  		call	bdos	
              		
              	; ----------------------
              	; ******** Misc ********
              	; ----------------------
              		
              	; Converts the value into an 8 bit hex number
              	; A = Number to convert
              	;
              	; Returns DE = result
              	; Uses: AF, DE
0969: 57      	tohex:	ld	d,a
096A: CD7409  		call	0$
096D: 5F      		ld	e,a
096E: 7A      		ld	a,d
096F: CD7809  		call	1$
0972: 57      		ld	d,a
0973: C9      		ret
              		
0974: 1F      	0$:	rra
0975: 1F      		rra
0976: 1F      		rra
0977: 1F      		rra
0978: F6F0    	1$:	or	0xF0
097A: 27      		daa
097B: C6A0    		add	a,0xA0
097D: CE40    		adc	a,0x40
097F: C9      		ret
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0D1B:         	str_splash:
0D1B: 4944454E		defb	'IDENTITY KRISYS HYPERVISOR, CP/M EDT.',0x0A,0x0D
0D1F: 54495459	
0D23: 204B5249	
0D27: 53595320	
0D2B: 48595045	
0D2F: 52564953	
0D33: 4F522C20	
0D37: 43502F4D	
0D3B: 20454454	
0D3F: 2E0A0D  	
0D42: 5645522E		defb	'VER. 0.0.1, GAVIN TERSTEEG 2024'
0D46: 20302E30	
0D4A: 2E312C20	
0D4E: 47415649	
0D52: 4E205445	
0D56: 52535445	
0D5A: 45472032	
0D5E: 303234  	
              		
              	; Carriage return, line break
0D61:         	str_crlf:
0D61: 0A0D24  		defb	0x0A,0x0D,'$' 
              		
              	#include "SN76489.asm"
              	;
              	;**************************************************************
              	;*
              	;*         S N 7 6 4 8 9   P S G   E M U L A T O R
              	;*
              	;*    Translates audio data meant for a SN76489 PSG into
              	;*    commands for the AY-3-8910.
              	;*
              	;*    This translation isn't perfect, but for most games
              	;*    it's "good enough".
              	;* 
              	;**************************************************************
              	
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Reset the PSG emulator
              	;
              	; Returns nothing
              	; Uses: AF, HL
0980:         	snpsg_reset:
              	
              		; Reset registers
0980: 210000  		ld	hl,0
0983: 221211  		ld	(snpsg_freq),hl
0986: 221411  		ld	(snpsg_freq+2),hl
0989: 221611  		ld	(snpsg_freq+4),hl
              	
098C: 3E0F    		ld	a,0x0F
098E: 321811  		ld	(snpsg_atten),a
0991: 321911  		ld	(snpsg_atten+1),a
0994: 321A11  		ld	(snpsg_atten+2),a
0997: 321B11  		ld	(snpsg_atten+3),a
              	
099A: AF      		xor	a
099B: 321C11  		ld	(snpsg_n_ctrl),a
              	
              		; Reset AY-3-8910
099E: 3E07    		ld	a,7
09A0: D341    		out	(nabu_ay_latch),a
09A2: 3E7F    		ld	a,0b01111111
09A4: D340    		out	(nabu_ay_data),a
              	
09A6: C9      		ret
              		
              		
              		
              		
              	; Send a byte to the "SN76489"
              	; A = Byte to send
              	;
              	; Uses: AF
09A7:         	snpsg_send:
09A7: C5      		push	bc
09A8: E5      		push 	hl
              		
              		; Save latest command byte
09A9: 47      		ld	b,a
09AA: 0E00    		ld	c,0
              		
              		; Check bit 7
09AC: 07      		rlca
09AD: D2ED09  		jp	nc,30$
              		
              		; Get register offset
09B0: 07      		rlca
09B1: CB11    		rl	c
09B3: 07      		rlca
09B4: CB11    		rl	c
              		
              		; Frequency or attenuation?
09B6: 07      		rlca
09B7: D2C709  		jp	nc,10$
              		
              		; Attenuation
09BA: 78      		ld	a,b
09BB: E60F    		and	0b00001111
09BD: 0600    		ld	b,0
09BF: 211811  		ld	hl,snpsg_atten
09C2: 09      		add	hl,bc
09C3: 77      		ld	(hl),a
09C4: C3050A  		jp	80$
              		
              		; Frequency (maybe)
09C7: 3E03    	10$:	ld	a,0x03
09C9: B9      		cp	c
09CA: CAE409  		jp	z,20$
              	
              		; Frequency (low bits)
09CD: 78      		ld	a,b
09CE: 0600    		ld	b,0
09D0: CB21    		sla	c
09D2: 211211  		ld	hl,snpsg_freq
09D5: 09      		add	hl,bc
09D6: E60F    		and	0b00001111
09D8: 47      		ld	b,a
09D9: 7E      		ld	a,(hl)
09DA: E6F0    		and	0b11110000
09DC: B0      		or	b
09DD: 77      		ld	(hl),a
09DE: 221D11  		ld	(snpsg_lastf),hl
09E1: C3050A  		jp	80$
              		
              		; Noise control
09E4: 78      	20$:	ld	a,b
09E5: E60F    		and	0b00001111
09E7: 321C11  		ld	(snpsg_n_ctrl),a
09EA: C3050A  		jp	80$
              		
              		; Frequency (high bits)
09ED: 78      	30$:	ld	a,b
09EE: 0600    		ld	b,0
09F0: 07      		rlca
09F1: 07      		rlca
09F2: 07      		rlca
09F3: CB10    		rl	b
09F5: 07      		rlca
09F6: CB10    		rl	b
09F8: E6F0    		and	0b11110000
09FA: 4F      		ld	c,a
09FB: 2A1D11  		ld	hl,(snpsg_lastf)
09FE: 3E0F    		ld	a,0b00001111
0A00: A6      		and	(hl)
0A01: B1      		or	c
0A02: 77      		ld	(hl),a
0A03: 23      		inc	hl
0A04: 70      		ld	(hl),b
              		
              		; Update the state to the AY-3-8910
0A05: 3E00    	80$:	ld	a,0
0A07: 0E40    		ld	c,nabu_ay_data
0A09: 211211  		ld	hl,snpsg_freq
              		
              		; Set frequency
0A0C: D341    	81$:	out	(nabu_ay_latch),a
0A0E: EDA3    		outi
0A10: 3C      		inc	a
0A11: FE06    		cp	6
0A13: C20C0A  		jp	nz,81$
              		
              		; Set channel mask
0A16: 3E07    		ld	a,7
0A18: D341    		out	(nabu_ay_latch),a
0A1A: 3E78    		ld	a,0b01111000
0A1C: D340    		out	(nabu_ay_data),a
              		
              		; Set amplitude
0A1E: 211811  		ld	hl,snpsg_atten
0A21: 0E08    		ld	c,8
0A23: 0603    		ld	b,3
0A25: 79      	82$:	ld	a,c
0A26: D341    		out	(nabu_ay_latch),a
0A28: 7E      		ld	a,(hl)
0A29: FE0F    		cp	0x0F
0A2B: C22F0A  		jp	nz,83$
0A2E: AF      		xor	a
0A2F: D340    	83$:	out	(nabu_ay_data),a
0A31: 0C      		inc	c
0A32: 10F1    		djnz	82$
              		
0A34: E1      	99$	pop	hl
0A35: C1      		pop	bc
0A36: C9      		ret
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Channel frequency
              	; Each channel stores is frequency between 2 bytes, there are 3 channels
1112:         	snpsg_freq:
1112: 00000000		defs	6
1116: 0000    	
              		
              	; Channel attenuation
              	; Similar to frequency, but only 1 byte wide and there are 4 channels
1118:         	snpsg_atten:
1118: 00000000		defs	4
              		
              	; Noise control
111C:         	snpsg_n_ctrl:
111C: 00      		defs	1
              		
              	; Last frequency accessed
111D:         	snpsg_lastf:
111D: 0000    		defs	2
              	
              	; ---------------------------
              	; ******** Core Init ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Start of SG-1000 core
0A37:         	core_start:
              	
              		; Reset PSG
0A37: CD8009  		call	snpsg_reset
              	
              		; Try to find rom resource
0A3A: 11640D  		ld	de,str_rom
0A3D: CD9004  		call	res_locate
0A40: B7      		or	a
0A41: C28103  		jp	nz,res_missing
              		
              		; Open the resource
0A44: CD9E03  		call	res_open
              		
              		; Load resources into bankmap
0A47: 211F11  		ld	hl,bm_rom
0A4A: 010001  		ld	bc,256
0A4D: CDF802  		call	res_load
              		
              		; Program the I/O map
0A50: 11680D  		ld	de,str_prgm
0A53: CD2709  		call	cpm_print
              		
              		; Do input map
0A56: CD3E02  		call	zmm_set_virt
0A59: CD5402  		call	zmm_prgm_in
0A5C: 21AD0D  		ld	hl,io_map_input
0A5F: 110080  		ld	de,zmm_map
0A62: 010001  		ld	bc,256
0A65: EDB0    		ldir
              		
              		; Do output map
0A67: CD5F02  		call	zmm_prgm_out
0A6A: 21AD0E  		ld	hl,io_map_output
0A6D: 110080  		ld	de,zmm_map
0A70: 010001  		ld	bc,256
0A73: EDB0    		ldir
              		
              		; Allocate free ram
0A75: 11810D  		ld	de,str_ram_alloc
0A78: CD2709  		call	cpm_print
              		
              		; Lower RAM
0A7B: 1601    		ld	d,1
0A7D: CD9D01  		call	mem_alloc
0A80: CDA202  		call	zmm_bnk2_set
              		
              		; Upper RAM
0A83: 1601    		ld	d,1
0A85: CD9D01  		call	mem_alloc
0A88: CDA802  		call	zmm_bnk3_set
              		
              		; Set up interrupt modes
0A8B: CD6A02  		call	zmm_irq_inter
0A8E: CD8B02  		call	zmm_irq_off
0A91: CD1207  		call	irq_vdp_on
0A94: CD2807  		call	irq_keyb_on
              		
              		; Mount ROM
0A97: 3A1F11  		ld	a,(bm_rom)
0A9A: CD9602  		call	zmm_bnk0_set
0A9D: CDAE02  		call	zmm_bnk0_wp
0AA0: 3A2011  		ld	a,(bm_rom+1)
0AA3: CD9C02  		call	zmm_bnk1_set
0AA6: CDBE02  		call	zmm_bnk1_wp
              		
              		; Reset joystick state
0AA9: AF      		xor	a
0AAA: 322211  		ld	(sg_ctrl_sel),a
0AAD: 3D      		dec	a
0AAE: 322311  		ld	(sg_ctrl_1),a
0AB1: 322411  		ld	(sg_ctrl_2),a
              		
              		; Bind debugger
              	;	call	debug_bind
              		
              		; Start up VM
0AB4: 11920D  		ld	de,str_vm_start
0AB7: CD2709  		call	cpm_print
              	
0ABA: CD3E02  		call	zmm_set_virt
0ABD: 210000  		ld	hl,0x0000
0AC0: C30102  		jp	zmm_vm_start
              	
              	
              	; Remaps address space so all reads of the VDP address register results in a trap
              	;
              	; Returns nothing
              	; Uses: AF
0AC3:         	sg_vdpr_trap:
0AC3: CD5402  		call	zmm_prgm_in
0AC6: 3E37    		ld	a,zmm_trap
              		; ld	(zmm_map+0x81),a
              		; ld	(zmm_map+0x83),a
              		; ld	(zmm_map+0x85),a
              		; ld	(zmm_map+0x87),a
              		; ld	(zmm_map+0x89),a
              		; ld	(zmm_map+0x8B),a
              		; ld	(zmm_map+0x8D),a
              		; ld	(zmm_map+0x8F),a
              		; ld	(zmm_map+0x91),a
              		; ld	(zmm_map+0x93),a
              		; ld	(zmm_map+0x95),a
              		; ld	(zmm_map+0x97),a
              		; ld	(zmm_map+0x99),a
              		; ld	(zmm_map+0x9B),a
              		; ld	(zmm_map+0x9D),a
              		; ld	(zmm_map+0x9F),a
              		; ld	(zmm_map+0xA1),a
              		; ld	(zmm_map+0xA3),a
              		; ld	(zmm_map+0xA5),a
              		; ld	(zmm_map+0xA7),a
              		; ld	(zmm_map+0xA9),a
              		; ld	(zmm_map+0xAB),a
              		; ld	(zmm_map+0xAD),a
              		; ld	(zmm_map+0xAF),a
              		; ld	(zmm_map+0xB1),a
              		; ld	(zmm_map+0xB3),a
              		; ld	(zmm_map+0xB5),a
              		; ld	(zmm_map+0xB7),a
              		; ld	(zmm_map+0xB9),a
              		; ld	(zmm_map+0xBB),a
              		; ld	(zmm_map+0xBD),a
0AC8: 32BF80  		ld	(zmm_map+0xBF),a
0ACB: C9      		ret
              		
              	; Untraps all VDP register read operations
              	;
              	; Returns nothing
              	; Uses: AF
0ACC:         	sg_vdpr_untrap:
0ACC: CD5402  		call	zmm_prgm_in
0ACF: 3EA1    		ld	a,nabu_vdp_addr
              		; ld	(zmm_map+0x81),a
              		; ld	(zmm_map+0x83),a
              		; ld	(zmm_map+0x85),a
              		; ld	(zmm_map+0x87),a
              		; ld	(zmm_map+0x89),a
              		; ld	(zmm_map+0x8B),a
              		; ld	(zmm_map+0x8D),a
              		; ld	(zmm_map+0x8F),a
              		; ld	(zmm_map+0x91),a
              		; ld	(zmm_map+0x93),a
              		; ld	(zmm_map+0x95),a
              		; ld	(zmm_map+0x97),a
              		; ld	(zmm_map+0x99),a
              		; ld	(zmm_map+0x9B),a
              		; ld	(zmm_map+0x9D),a
              		; ld	(zmm_map+0x9F),a
              		; ld	(zmm_map+0xA1),a
              		; ld	(zmm_map+0xA3),a
              		; ld	(zmm_map+0xA5),a
              		; ld	(zmm_map+0xA7),a
              		; ld	(zmm_map+0xA9),a
              		; ld	(zmm_map+0xAB),a
              		; ld	(zmm_map+0xAD),a
              		; ld	(zmm_map+0xAF),a
              		; ld	(zmm_map+0xB1),a
              		; ld	(zmm_map+0xB3),a
              		; ld	(zmm_map+0xB5),a
              		; ld	(zmm_map+0xB7),a
              		; ld	(zmm_map+0xB9),a
              		; ld	(zmm_map+0xBB),a
              		; ld	(zmm_map+0xBD),a
0AD1: 32BF80  		ld	(zmm_map+0xBF),a
0AD4: C9      		ret
              		
              		; Exit out of the emulator
0AD5:         	sg_exit:
0AD5: CD4902  		call	zmm_set_real
0AD8: CD8009  		call	snpsg_reset
0ADB: C36109  		jp	cpm_exit
              		
              	; -----------------------------------
              	; ******** Interrupt Handler ********
              	; -----------------------------------
              		
              	.area	_TEXT
              		
              		
              	; Handle a "joystick" event
0ADE:         	sg_joystick:
              		
              		; Get the latest scancode from the keyboard
0ADE: DB90    		in	a,(nabu_key_data)
0AE0: 322111  		ld	(sg_last_stroke),a
              		
              		; Is it an 'ESC'?
0AE3: FE1B    		cp	0x1B
0AE5: CAD50A  		jp	z,sg_exit
              		
              		; Check for joystick 1
0AE8: FE80    		cp	0x80
0AEA: CAFF0A  		jp	z,20$
              		
              		; Check for joystick 2
0AED: FE81    		cp	0x81
0AEF: CA040B  		jp	z,21$
              		
              		; Check for momentary keys
0AF2: FEE0    		cp	0xE0
0AF4: D20A0B  		jp	nc,30$
              		
              		; Joystick data byte?
0AF7: E6E0    		and	0b11100000
0AF9: FEA0    		cp	0b10100000
0AFB: CA0B0B  		jp	z,40$
              		
              		; Nothing useful
0AFE: C9      		ret
              		
              		; Joystick 1 detected
0AFF: AF      	20$:	xor	a
0B00: 322211  		ld	(sg_ctrl_sel),a
0B03: C9      		ret
              		
              		; Joystick 2 detected
0B04: 3E01    	21$:	ld	a,1
0B06: 322211  		ld	(sg_ctrl_sel),a
0B09: C9      		ret
              		
              		; Handle a momentary key
0B0A: C9      	30$:	ret
              	
              		; Handle a joystick data byte
0B0B: E5      	40$:	push	hl
0B0C: 212311  		ld	hl,sg_ctrl_1
0B0F: 3A2211  		ld	a,(sg_ctrl_sel)
0B12: B7      		or	a
0B13: C2430B  		jp	nz,50$
              		
              		; Joystick 0
0B16: 3A2111  		ld	a,(sg_last_stroke)
              		
              		; Left 0
0B19: 0F      		rrca
0B1A: CBD6    		set	2,(hl)
0B1C: D2210B  		jp	nc,$+5
0B1F: CB96    		res	2,(hl)
              		
              		; Down 0
0B21: 0F      		rrca
0B22: CBCE    		set	1,(hl)
0B24: D2290B  		jp	nc,$+5
0B27: CB8E    		res	1,(hl)
              		
              		; Right 0
0B29: 0F      		rrca
0B2A: CBDE    		set	3,(hl)
0B2C: D2310B  		jp	nc,$+5
0B2F: CB9E    		res	3,(hl)
              		
              		; Up 0
0B31: 0F      		rrca
0B32: CBC6    		set	0,(hl)
0B34: D2390B  		jp	nc,$+5
0B37: CB86    		res	0,(hl)
              		
              		; Fire 0
0B39: 0F      		rrca
0B3A: CBEE    		set	5,(hl)
0B3C: D2410B  		jp	nc,$+5
0B3F: CBAE    		res	5,(hl)
              		
0B41: E1      		pop	hl
0B42: C9      		ret
              		
              		; Joystick  1
0B43: 3A2111  	50$:	ld	a,(sg_last_stroke)
              	
0B46: E1      		pop	hl
0B47: C9      		ret
              		
              		
              	; Handle "real" interrupts from devices (if needed)
              	; All registers except AF must remain unchanged!
0B48:         	irq_handle:
0B48: CD6A07  		call	irq_status
0B4B: 0F      		rrca
0B4C: D0      		ret	nc
              		
              		; Interrupt detected, VDP or keyboard?
0B4D: 0F      		rrca
0B4E: DA540B  		jp	c,0$
              	
              		; Ok, we hit a keyboard interrupt
0B51: C3DE0A  		jp	sg_joystick
              		
              		; Ok, we hit a VDP interrupt
0B54: CD1D07  	0$:	call	irq_vdp_off
0B57: CD8002  		call	zmm_irq_on
0B5A: C3C30A  		jp	sg_vdpr_trap
              		
              		
              	; -----------------------------
              	; ******** I/O Handler ********
              	; -----------------------------
              		
              	.area	_TEXT
              	
              	; Handle an IN instruction
              	; Inputted value should be returned in register A
              	; All registers except AF must remain unchanged!
0B5D:         	in_handle:
0B5D: DB33    		in	a,(zmm_addr_lo)
0B5F: 07      		rlca
0B60: DA6E0B  		jp	c,0$
              		
0B63: 07      		rlca
0B64: DA6B0B  		jp	c,10$
              		
              		; Device 0
0B67: 3A2111  		ld	a,(sg_last_stroke)
0B6A: C9      		ret
              		
              		; Device 1
0B6B: C38C0B  	10$:	jp	99$
              	
0B6E: 07      	0$:	rlca
0B6F: DA7E0B  		jp	c,20$
              		
              		; Device 2: VDP
0B72: CDCC0A  		call	sg_vdpr_untrap
0B75: CD8B02  		call	zmm_irq_off
0B78: CD1207  		call	irq_vdp_on
0B7B: DBA1    		in	a,(nabu_vdp_addr)
0B7D: C9      		ret
              		
              		; Device 3: Joystick
0B7E: DB33    	20$	in	a,(zmm_addr_lo)
0B80: 0F      		rrca
0B81: DA880B  		jp	c,25$
              		
              		; Read controller 1
0B84: 3A2311  		ld	a,(sg_ctrl_1)
0B87: C9      		ret
              		
              		; Read controller 2
0B88: 3A2411  	25$:	ld	a,(sg_ctrl_2)
0B8B: C9      		ret
              		
              	
              		; Unknown device
0B8C: 3EFF    	99$:	ld	a,0xFF
0B8E: C9      		ret
              	
              	; Handle an OUT instruction
              	; A = Value outputted by virtual machine
              	; All registers except AF must remain unchanged!
0B8F:         	out_handle:
0B8F: F5      		push	af
              	
0B90: DB33    		in	a,(zmm_addr_lo)
0B92: 07      		rlca
0B93: DA9F0B  		jp	c,99$
0B96: 07      		rlca
0B97: D29F0B  		jp	nc,99$
              		
              		; PSG
0B9A: F1      		pop	af
0B9B: CDA709  		call	snpsg_send
0B9E: C9      		ret
              	
0B9F: F1      	99$:	pop	af
0BA0: C9      		ret
              		
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Resource strings
0D64:         	str_rom:
0D64: 524F4D00		defb	'ROM',0
              		
              	; Bootup strings
0D68:         	str_prgm:
0D68: 50524F47		defb	'PROGRAMMING VM I/O MAP',0x0A,0x0D,'$'
0D6C: 52414D4D	
0D70: 494E4720	
0D74: 564D2049	
0D78: 2F4F204D	
0D7C: 41500A0D	
0D80: 24      	
              		
              	; Bootup strings
0D81:         	str_ram_alloc:
0D81: 414C4C4F		defb	'ALLOCATING RAM',0x0A,0x0D,'$'
0D85: 43415449	
0D89: 4E472052	
0D8D: 414D0A0D	
0D91: 24      	
              		
              	; Bootup strings
0D92:         	str_vm_start:
0D92: 53544152		defb	'STARTING VM NOW',0x0A,0x0D,'$'
0D96: 54494E47	
0D9A: 20564D20	
0D9E: 4E4F570A	
0DA2: 0D24    	
              		
              	; Debug string
0DA4:         	str_debug:
0DA4: 41203D20		defb 	'A = '
0DA8:         	str_debug_val:
0DA8: 58580A0D		defb	'XX',0x0A,0x0D,'$'
0DAC: 24      	
              	
              	
              	; ----------------------
              	; ******** Data ********
              	; ----------------------
              		
              	.area	_DATA
              	
0037:         	TRAP	equ	zmm_trap	; Trap Vector
00A0:         	_VDD	equ	nabu_vdp_data	; VDP Data
00A1:         	_VDA	equ	nabu_vdp_addr	; VDP Address
              	
              	; Virtual machine I/O maps
              	; Input map
0DAD:         	io_map_input:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
0DAD: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
0DB1: 37...   	
0DBD: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
0DC1: 37...   	
0DCD: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
0DD1: 37...   	
0DDD: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
0DE1: 37...   	
0DED: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
0DF1: 37...   	
0DFD: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
0E01: 37...   	
0E0D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
0E11: 37...   	
0E1D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
0E21: 37...   	
0E2D: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x8*
0E31: A0A1A0A1	
0E35: A0A1A0A1	
0E39: A0A1A0A1	
0E3D: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x9*
0E41: A0A1A0A1	
0E45: A0A1A0A1	
0E49: A0A1A0A1	
0E4D: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xA*
0E51: A0A1A0A1	
0E55: A0A1A0A1	
0E59: A0A1A0A1	
0E5D: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xB*
0E61: A0A1A0A1	
0E65: A0A1A0A1	
0E69: A0A1A0A1	
0E6D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
0E71: 37...   	
0E7D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
0E81: 37...   	
0E8D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
0E91: 37...   	
0E9D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
0EA1: 37...   	
              	
              	; Output map
0EAD:         	io_map_output:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
0EAD: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
0EB1: 37...   	
0EBD: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
0EC1: 37...   	
0ECD: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
0ED1: 37...   	
0EDD: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
0EE1: 37...   	
0EED: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
0EF1: 37...   	
0EFD: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
0F01: 37...   	
0F0D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
0F11: 37...   	
0F1D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
0F21: 37...   	
0F2D: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x8*
0F31: A0A1A0A1	
0F35: A0A1A0A1	
0F39: A0A1A0A1	
0F3D: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x9*
0F41: A0A1A0A1	
0F45: A0A1A0A1	
0F49: A0A1A0A1	
0F4D: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xA*
0F51: A0A1A0A1	
0F55: A0A1A0A1	
0F59: A0A1A0A1	
0F5D: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xB*
0F61: A0A1A0A1	
0F65: A0A1A0A1	
0F69: A0A1A0A1	
0F6D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
0F71: 37...   	
0F7D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
0F81: 37...   	
0F8D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
0F91: 37...   	
0F9D: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
0FA1: 37...   	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
111F:         	bm_rom:
111F: 0000    		defs	2
              		
              	; Last stroke from the keyboard
1121:         	sg_last_stroke:
1121: 00      		defs	1
              		
              	; Selected joystick for updating
              	; 0 = Joystick 1 selected
              	; 1 = Joystick 2 selected
1122:         	sg_ctrl_sel:
1122: 00      		defs	1
              		
              	; SG-1000 joystick states
1123:         	sg_ctrl_1:
1123: 00      		defs	1
1124:         	sg_ctrl_2:
1124: 00      		defs	1


; +++ segments +++

#CODE _TEXT    = $0100 =   256,  size = $0AA1 =  2721
#CODE _DATA    = $0BA1 =  2977,  size = $040C =  1036
#DATA _BSS     = $0FAD =  4013,  size = $0178 =   376

; +++ global symbols +++

TRAP             = $0037 =    55  _DATA   KSG1000.asm:420
_BSS             = $0FAD =  4013  _BSS    KRISYS.asm:28 (unused)
_BSS_end         = $1125 =  4389  _BSS    KRISYS.asm:28
_BSS_size        = $0178 =   376  _BSS    KRISYS.asm:28 (unused)
_DATA            = $0BA1 =  2977  _DATA   KRISYS.asm:27 (unused)
_DATA_end        = $0FAD =  4013  _DATA   KRISYS.asm:27
_DATA_size       = $040C =  1036  _DATA   KRISYS.asm:27 (unused)
_TEXT            = $0100 =   256  _TEXT   KRISYS.asm:26 (unused)
_TEXT_end        = $0BA1 =  2977  _TEXT   KRISYS.asm:26
_TEXT_size       = $0AA1 =  2721  _TEXT   KRISYS.asm:26 (unused)
_VDA             = $00A1 =   161  _DATA   KSG1000.asm:422
_VDD             = $00A0 =   160  _DATA   KSG1000.asm:421
alloc_bank_map   = $0FAE =  4014  _BSS    MEMORY.asm:276
arg_size         = $0010 =    16  _BSS    RESOURCE.asm:17
banks_free       = $0FAD =  4013  _BSS    MEMORY.asm:270
bdos             = $0005 =     5  _TEXT   KRISYS.asm:49
bdos_con_in      = $0001 =     1  _TEXT   KRISYS.asm:51
bdos_con_out     = $0002 =     2  _TEXT   KRISYS.asm:52
bdos_exit        = $0000 =     0  _TEXT   KRISYS.asm:50
bdos_input       = $000A =    10  _TEXT   KRISYS.asm:54
bdos_open        = $000F =    15  _TEXT   KRISYS.asm:55
bdos_print       = $0009 =     9  _TEXT   KRISYS.asm:53
bdos_read        = $0014 =    20  _TEXT   KRISYS.asm:56
bios_set_dma     = $001A =    26  _TEXT   KRISYS.asm:57
bm_rom           = $111F =  4383  _BSS    KSG1000.asm:472
core_start       = $0A37 =  2615  _TEXT   KSG1000.asm:18
cpm_command      = $0080 =   128  _TEXT   KRISYS.asm:59
cpm_exit         = $0961 =  2401  _TEXT   KRISYS.asm:212
cpm_getc         = $094D =  2381  _TEXT   KRISYS.asm:190
cpm_input        = $093A =  2362  _TEXT   KRISYS.asm:169 (unused)
cpm_print        = $0927 =  2343  _TEXT   KRISYS.asm:147
debug_bind       = $08DD =  2269  _TEXT   DEBUG.asm:263 (unused)
debug_continue   = $08A5 =  2213  _TEXT   DEBUG.asm:185
debug_f_over     = $10FB =  4347  _BSS    DEBUG.asm:375
debug_handle     = $0793 =  1939  _TEXT   DEBUG.asm:18
debug_init       = $08C2 =  2242  _TEXT   DEBUG.asm:224
debug_over       = $0887 =  2183  _TEXT   DEBUG.asm:163
debug_over_sp    = $10FC =  4348  _BSS    DEBUG.asm:379
debug_pbind      = $10F4 =  4340  _BSS    DEBUG.asm:362
debug_pc_state   = $10F9 =  4345  _BSS    DEBUG.asm:371
debug_query      = $0871 =  2161  _TEXT   DEBUG.asm:135 (unused)
debug_rtohex     = $08C7 =  2247  _TEXT   DEBUG.asm:238
debug_state      = $1112 =  4370  _BSS    DEBUG.asm:395
debug_temp       = $10F7 =  4343  _BSS    DEBUG.asm:367
debug_unbind     = $08F5 =  2293  _TEXT   DEBUG.asm:283 (unused)
debug_upper      = $0895 =  2197  _TEXT   DEBUG.asm:173
in_handle        = $0B5D =  2909  _TEXT   KSG1000.asm:321
input_buff       = $0CF1 =  3313  _DATA   DEBUG.asm:351 (unused)
io_map_input     = $0DAD =  3501  _DATA   KSG1000.asm:426
io_map_output    = $0EAD =  3757  _DATA   KSG1000.asm:446
irq_handle       = $0B48 =  2888  _TEXT   KSG1000.asm:294
irq_hcca_i_off   = $075F =  1887  _TEXT   IRQ.asm:125 (unused)
irq_hcca_i_on    = $0754 =  1876  _TEXT   IRQ.asm:114 (unused)
irq_hcca_o_off   = $0749 =  1865  _TEXT   IRQ.asm:103 (unused)
irq_hcca_o_on    = $073E =  1854  _TEXT   IRQ.asm:92 (unused)
irq_init         = $06FB =  1787  _TEXT   IRQ.asm:22
irq_keyb_off     = $0733 =  1843  _TEXT   IRQ.asm:81 (unused)
irq_keyb_on      = $0728 =  1832  _TEXT   IRQ.asm:70
irq_mask_state   = $10F3 =  4339  _BSS    IRQ.asm:182
irq_restore      = $077D =  1917  _TEXT   IRQ.asm:157
irq_status       = $076A =  1898  _TEXT   IRQ.asm:136
irq_vdp_off      = $071D =  1821  _TEXT   IRQ.asm:59
irq_vdp_on       = $0712 =  1810  _TEXT   IRQ.asm:48
kri_stack        = $7000 = 28672  _TEXT   KRISYS.asm:93
kri_start        = $0902 =  2306  _TEXT   KRISYS.asm:115
mem_alloc        = $019D =   413  _TEXT   MEMORY.asm:168
mem_empty        = $01DB =   475  _TEXT   MEMORY.asm:242
mem_free         = $01BE =   446  _TEXT   MEMORY.asm:200
mem_free_all     = $01D0 =   464  _TEXT   MEMORY.asm:226 (unused)
mem_fvbyte       = $0165 =   357  _TEXT   MEMORY.asm:101
mem_getbank      = $0178 =   376  _TEXT   MEMORY.asm:128
mem_map_init     = $0103 =   259  _TEXT   MEMORY.asm:30
nabu_ay_data     = $0040 =    64  _TEXT   KRISYS.asm:85
nabu_ay_latch    = $0041 =    65  _TEXT   KRISYS.asm:86
nabu_key_data    = $0090 =   144  _TEXT   KRISYS.asm:87
nabu_key_stat    = $0091 =   145  _TEXT   KRISYS.asm:88 (unused)
nabu_nctl        = $0000 =     0  _TEXT   KRISYS.asm:84 (unused)
nabu_vdp_addr    = $00A1 =   161  _TEXT   KRISYS.asm:90
nabu_vdp_data    = $00A0 =   160  _TEXT   KRISYS.asm:89
nmi_address      = $0066 =   102  _TEXT   KRISYS.asm:80
nmi_vector       = $0067 =   103  _TEXT   KRISYS.asm:81
out_handle       = $0B8F =  2959  _TEXT   KSG1000.asm:367
res_argument     = $1033 =  4147  _BSS    RESOURCE.asm:480
res_bankmap      = $10C9 =  4297  _BSS    RESOURCE.asm:500
res_buffer       = $1046 =  4166  _BSS    RESOURCE.asm:488
res_current      = $1044 =  4164  _BSS    RESOURCE.asm:484
res_do_read      = $10C8 =  4296  _BSS    RESOURCE.asm:496
res_fcb          = $10CD =  4301  _BSS    RESOURCE.asm:508
res_fcb_cr       = $10ED =  4333  _BSS    RESOURCE.asm:518 (unused)
res_fcb_data     = $10DD =  4317  _BSS    RESOURCE.asm:517 (unused)
res_fcb_drive    = $10CD =  4301  _BSS    RESOURCE.asm:510
res_fcb_ex       = $10D9 =  4313  _BSS    RESOURCE.asm:513 (unused)
res_fcb_name     = $10CE =  4302  _BSS    RESOURCE.asm:511
res_fcb_r0       = $10EE =  4334  _BSS    RESOURCE.asm:519 (unused)
res_fcb_r1       = $10EF =  4335  _BSS    RESOURCE.asm:520 (unused)
res_fcb_r2       = $10F0 =  4336  _BSS    RESOURCE.asm:521 (unused)
res_fcb_rc       = $10DC =  4316  _BSS    RESOURCE.asm:516 (unused)
res_fcb_s1       = $10DA =  4314  _BSS    RESOURCE.asm:514 (unused)
res_fcb_s2       = $10DB =  4315  _BSS    RESOURCE.asm:515 (unused)
res_fcb_type     = $10D6 =  4310  _BSS    RESOURCE.asm:512
res_init         = $02EE =   750  _TEXT   RESOURCE.asm:29
res_load         = $02F8 =   760  _TEXT   RESOURCE.asm:47
res_locate       = $0490 =  1168  _TEXT   RESOURCE.asm:360
res_missing      = $0381 =   897  _TEXT   RESOURCE.asm:153
res_open         = $039E =   926  _TEXT   RESOURCE.asm:179
res_pointer      = $10CB =  4299  _BSS    RESOURCE.asm:504
res_printzt      = $0481 =  1153  _TEXT   RESOURCE.asm:340
res_sectors      = $10C6 =  4294  _BSS    RESOURCE.asm:492
sg_ctrl_1        = $1123 =  4387  _BSS    KSG1000.asm:486
sg_ctrl_2        = $1124 =  4388  _BSS    KSG1000.asm:488
sg_ctrl_sel      = $1122 =  4386  _BSS    KSG1000.asm:482
sg_exit          = $0AD5 =  2773  _TEXT   KSG1000.asm:186
sg_joystick      = $0ADE =  2782  _TEXT   KSG1000.asm:199
sg_last_stroke   = $1121 =  4385  _BSS    KSG1000.asm:476
sg_vdpr_trap     = $0AC3 =  2755  _TEXT   KSG1000.asm:107
sg_vdpr_untrap   = $0ACC =  2764  _TEXT   KSG1000.asm:148
snpsg_atten      = $1118 =  4376  _BSS    SN76489.asm:182
snpsg_freq       = $1112 =  4370  _BSS    SN76489.asm:177
snpsg_lastf      = $111D =  4381  _BSS    SN76489.asm:190
snpsg_n_ctrl     = $111C =  4380  _BSS    SN76489.asm:186
snpsg_reset      = $0980 =  2432  _TEXT   SN76489.asm:25
snpsg_send       = $09A7 =  2471  _TEXT   SN76489.asm:57
stack_size       = $0020 =    32          KRISYS.asm:31
str_arg_empty    = $0C04 =  3076  _DATA   RESOURCE.asm:464
str_arg_fail     = $0C1B =  3099  _DATA   RESOURCE.asm:467
str_crlf         = $0D61 =  3425  _DATA   KRISYS.asm:256
str_debug        = $0DA4 =  3492  _DATA   KSG1000.asm:408 (unused)
str_debug_val    = $0DA8 =  3496  _DATA   KSG1000.asm:410 (unused)
str_load_a       = $0BF4 =  3060  _DATA   RESOURCE.asm:457
str_load_b       = $0BFD =  3069  _DATA   RESOURCE.asm:460
str_mem_empty    = $0BCC =  3020  _DATA   MEMORY.asm:260
str_mem_init     = $0BA1 =  2977  _DATA   MEMORY.asm:254
str_mem_init_cnt = $0BC6 =  3014  _DATA   MEMORY.asm:257
str_missing      = $0C31 =  3121  _DATA   RESOURCE.asm:470
str_prgm         = $0D68 =  3432  _DATA   KSG1000.asm:396
str_prompt       = $0CED =  3309  _DATA   DEBUG.asm:347 (unused)
str_ram_alloc    = $0D81 =  3457  _DATA   KSG1000.asm:400
str_rdump        = $0C44 =  3140  _DATA   DEBUG.asm:302
str_rdump_aaf    = $0CB5 =  3253  _DATA   DEBUG.asm:331
str_rdump_abc    = $0CBE =  3262  _DATA   DEBUG.asm:333
str_rdump_ade    = $0CC7 =  3271  _DATA   DEBUG.asm:335
str_rdump_af     = $0C8D =  3213  _DATA   DEBUG.asm:321
str_rdump_ahl    = $0CD0 =  3280  _DATA   DEBUG.asm:337
str_rdump_bc     = $0C96 =  3222  _DATA   DEBUG.asm:323
str_rdump_de     = $0C9F =  3231  _DATA   DEBUG.asm:325
str_rdump_ei     = $0C7C =  3196  _DATA   DEBUG.asm:315 (unused)
str_rdump_flag   = $0C6F =  3183  _DATA   DEBUG.asm:313 (unused)
str_rdump_hl     = $0CA8 =  3240  _DATA   DEBUG.asm:327
str_rdump_io     = $0C83 =  3203  _DATA   DEBUG.asm:317 (unused)
str_rdump_isr    = $0C5E =  3166  _DATA   DEBUG.asm:309
str_rdump_ix     = $0CDD =  3293  _DATA   DEBUG.asm:341
str_rdump_iy     = $0CE6 =  3302  _DATA   DEBUG.asm:343
str_rdump_pc     = $0C4A =  3146  _DATA   DEBUG.asm:305
str_rdump_sp     = $0C53 =  3155  _DATA   DEBUG.asm:307
str_rom          = $0D64 =  3428  _DATA   KSG1000.asm:392
str_splash       = $0D1B =  3355  _DATA   KRISYS.asm:251
str_vm_start     = $0D92 =  3474  _DATA   KSG1000.asm:404
str_zmm_init     = $0BE2 =  3042  _DATA   ZMM.asm:308
tohex            = $0969 =  2409  _TEXT   KRISYS.asm:226
trap_a_value     = $6FFF = 28671  _TEXT   KRISYS.asm:94
trap_continue    = $06E2 =  1762  _TEXT   TRAP.asm:476
trap_entry       = $04F9 =  1273  _TEXT   TRAP.asm:19
trap_f_value     = $6FFE = 28670  _TEXT   KRISYS.asm:95
trap_init        = $06EF =  1775  _TEXT   TRAP.asm:508
trap_io          = $050A =  1290  _TEXT   TRAP.asm:39 (unused)
trap_io_ex_out   = $059C =  1436  _TEXT   TRAP.asm:166
trap_io_ext      = $0526 =  1318  _TEXT   TRAP.asm:59
trap_io_ind      = $0633 =  1587  _TEXT   TRAP.asm:305
trap_io_inx      = $05F6 =  1526  _TEXT   TRAP.asm:246
trap_io_outd     = $06A9 =  1705  _TEXT   TRAP.asm:421
trap_io_outx     = $066C =  1644  _TEXT   TRAP.asm:360
trap_res_flag    = $06E3 =  1763  _TEXT   TRAP.asm:485
trap_restore     = $06E3 =  1763  _TEXT   TRAP.asm:482
trap_sp_value    = $10F1 =  4337  _BSS    TRAP.asm:526
zmm_addr_hi      = $0032 =    50  _TEXT   KRISYS.asm:68 (unused)
zmm_addr_lo      = $0033 =    51  _TEXT   KRISYS.asm:69
zmm_bnk0         = $0030 =    48  _TEXT   KRISYS.asm:62
zmm_bnk0_set     = $0296 =   662  _TEXT   ZMM.asm:193
zmm_bnk0_state   = $102F =  4143  _BSS    ZMM.asm:322
zmm_bnk0_we      = $02B6 =   694  _TEXT   ZMM.asm:242 (unused)
zmm_bnk0_wp      = $02AE =   686  _TEXT   ZMM.asm:233
zmm_bnk1         = $0031 =    49  _TEXT   KRISYS.asm:63
zmm_bnk1_set     = $029C =   668  _TEXT   ZMM.asm:203
zmm_bnk1_state   = $1030 =  4144  _BSS    ZMM.asm:326
zmm_bnk1_we      = $02C6 =   710  _TEXT   ZMM.asm:260 (unused)
zmm_bnk1_wp      = $02BE =   702  _TEXT   ZMM.asm:251
zmm_bnk2         = $0032 =    50  _TEXT   KRISYS.asm:64
zmm_bnk2_set     = $02A2 =   674  _TEXT   ZMM.asm:213
zmm_bnk2_state   = $1031 =  4145  _BSS    ZMM.asm:330
zmm_bnk2_we      = $02D6 =   726  _TEXT   ZMM.asm:278 (unused)
zmm_bnk2_wp      = $02CE =   718  _TEXT   ZMM.asm:269 (unused)
zmm_bnk3         = $0033 =    51  _TEXT   KRISYS.asm:65
zmm_bnk3_set     = $02A8 =   680  _TEXT   ZMM.asm:223
zmm_bnk3_state   = $1032 =  4146  _BSS    ZMM.asm:334
zmm_bnk3_we      = $02E6 =   742  _TEXT   ZMM.asm:296 (unused)
zmm_bnk3_wp      = $02DE =   734  _TEXT   ZMM.asm:287 (unused)
zmm_capt_res     = $007F =   127  _TEXT   KRISYS.asm:77
zmm_capt_set     = $0070 =   112  _TEXT   KRISYS.asm:76
zmm_capture      = $7000 = 28672  _TEXT   KRISYS.asm:72
zmm_ctrl         = $0034 =    52  _TEXT   KRISYS.asm:66
zmm_ctrl_set     = $0238 =   568  _TEXT   ZMM.asm:95
zmm_ctrl_state   = $102E =  4142  _BSS    ZMM.asm:318
zmm_init         = $01E4 =   484  _TEXT   ZMM.asm:22
zmm_irq_inter    = $026A =   618  _TEXT   ZMM.asm:148
zmm_irq_normal   = $0275 =   629  _TEXT   ZMM.asm:159 (unused)
zmm_irq_off      = $028B =   651  _TEXT   ZMM.asm:181
zmm_irq_on       = $0280 =   640  _TEXT   ZMM.asm:170
zmm_isr          = $0030 =    48  _TEXT   KRISYS.asm:67
zmm_map          = $8000 = 32768  _TEXT   KRISYS.asm:73
zmm_prgm_in      = $0254 =   596  _TEXT   ZMM.asm:126
zmm_prgm_out     = $025F =   607  _TEXT   ZMM.asm:137
zmm_set_real     = $0249 =   585  _TEXT   ZMM.asm:115
zmm_set_virt     = $023E =   574  _TEXT   ZMM.asm:104
zmm_top          = $C000 = 49152  _TEXT   KRISYS.asm:74
zmm_trap         = $0037 =    55  _TEXT   KRISYS.asm:70
zmm_vm_start     = $0201 =   513  _TEXT   ZMM.asm:44


total time: 0.0365 sec.
no errors
