              	; --------------------------------------
              	; zasm: assemble "KSG1000.asm"
              	; date: 2024-08-26 22:29:03
              	; --------------------------------------


              	;
              	;********************************************************************
              	;*
              	;*        K R I S Y S   S G 1 0 0 0   C O R E
              	;*
              	;********************************************************************
              	
              	#include "KRISYS.asm"
              	;
              	;********************************************************************
              	;*
              	;*              I D E N T I T Y   K R I S Y S
              	;*
              	;*      The [K]lunkly [R]emapper / [I]nterpreter [SYS]tem
              	;*
              	;*             Written by Gavin Tersteeg, 2024
              	;*              Copyleft, All Wrongs Reserved
              	;*
              	;*
              	;*   This piece of software allows different classic Z80 systems
              	;*   to run as "virtual machines" on top of existing hardware by
              	;*   use of a ZMM (Z80 MEGAMAPPER). It does this by remapping RAM
              	;*   and I/O address space ot match that of it's target system.
              	;*   Anything that can't be emulated by simple remapping is instead
              	;*   interpreted using I/O traps. 
              	;*
              	;*   This allows virtualized machines to run with an acceptable
              	;*   degree of speed and accuracy. While the ZMM is still quite
              	;*   limited in what sort of hardware can be efficiently virtualized,
              	;*   anything that avoids MMIO or graphics hardware that isn't a VDP
              	;*   generally can be made to work.
              	;* 
              	;********************************************************************
              		
              	; ----------------------------
              	; ******** ZASM Setup ********
              	; ----------------------------
              	
0020:         	stack_size = 0x20
              	
              	#target BIN
0100:         	#code	_TEXT,0x0100	; Setup to run as a CP/M executable
0997:         	#code	_DATA,_TEXT_end
0D95:         	#data	_BSS,_DATA_end
              	
              	; Make sure w don't overrun available memory
              	#assert	_BSS_end < (zmm_capture-stack_size)
              	
              	.area	_TEXT
0100: C38008  		jp	kri_start
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
              	; CP/M Stuff
0005:         	bdos		equ	0x0005
0000:         	bdos_exit	equ	0x00
0001:         	bdos_con_in	equ	0x01
0002:         	bdos_con_out	equ	0x02
0009:         	bdos_print	equ	0x09
000A:         	bdos_input	equ	0x0A
000F:         	bdos_open	equ	0x0F
0014:         	bdos_read	equ	0x14
001A:         	bios_set_dma	equ	0x1A
              	
0080:         	cpm_command	equ	0x0080
              	
              	; Z80 MEGAMAPPER Stuff
0030:         	zmm_bnk0	equ	0x30	; 16K Bank 0 (0x0000 - 0x3FFF)
0031:         	zmm_bnk1	equ	0x31	; 16K Bank 1 (0x4000 - 0x7FFF)
0032:         	zmm_bnk2	equ	0x32	; 16K Bank 2 (0x8000 - 0xBFFF)
0033:         	zmm_bnk3	equ	0x33	; 16K Bank 3 (0xC000 - 0xFFFF)
0034:         	zmm_ctrl	equ	0x34	; ZMM Control Register
0030:         	zmm_isr		equ	0x30	; ZMM Trapped Instruction Register
0032:         	zmm_addr_hi	equ	0x32	; ZMM Trap Address High
0033:         	zmm_addr_lo	equ	0x33	; ZMM Trap Address Low
0037:         	zmm_trap	equ	0x37 	; ZMM Trap Vector
              	
7000:         	zmm_capture	equ	0x7000
8000:         	zmm_map		equ	0x8000
C000:         	zmm_top		equ	0xC000
              	
0070:         	zmm_capt_set	equ	0b01110000
007F:         	zmm_capt_res	equ	0b01111111
              	
              	; General Z80 Stuff
0066:         	nmi_address	equ	0x0066
0067:         	nmi_vector	equ	nmi_address+1
              	
              	; NABU Specific Stuff
0000:         	nabu_nctl	equ	0x00	; NABU Control Register
0040:         	nabu_ay_data	equ	0x40	; AY-3-8910 Data Port
0041:         	nabu_ay_latch	equ	0x41	; AY-3-8910 Latch Port
00A0:         	nabu_vdp_data	equ	0xA0	; VDP Data Port
00A1:         	nabu_vdp_addr	equ	0xA1	; VDP Address Port
              	
              	; Stack / Trap Management
7000:         	kri_stack	equ	zmm_capture
6FFF:         	trap_a_value	equ	kri_stack-1
6FFE:         	trap_f_value	equ	kri_stack-2
              	
              	; -------------------------------------
              	; ******** Additional Includes ********
              	; -------------------------------------
              	
              	#include "MEMORY.asm"
              	;
              	;********************************************************************
              	;*
              	;*                    Z M M   M E M O R Y
              	;* 
              	;*    The ZMM can be configured to have different amounts
              	;*    of memory installed. Instead of dicking around with 
              	;*    on-board jumpers, KRISYS will simply check what banks
              	;*    are available on startup. Memory will be dynamically
              	;*    allocated as needed by the client process.
              	;*
              	;*    Memory can be assigned to specific owners in the code.
              	;*    Valid owner IDs range from 1 to 254. Owner 0 is reserved
              	;*    for unallocatable banks.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              		
              	; Initalize the memory map
              	; Each bank of the ZMM will be probed, and writable
              	; banks will be recorded on the allocated bank map
              	;
              	; Returns nothing
              	; Uses: AF, BC, DE, HL
0103:         	mem_map_init:
              		; Go to virtual mode
0103: CD0802  		call	zmm_set_virt
              		
              		; Reset free bank counter
0106: 3E00    		ld	a,0
0108: 32950D  		ld	(banks_free),a
              		
              		; Write tags to all banks
010B: 0600    		ld	b,0
010D: 78      	0$:	ld	a,b
010E: CD7202  		call	zmm_bnk3_set
0111: 3200C0  		ld	(zmm_top),a
0114: ED44    		neg
0116: 3201C0  		ld	(zmm_top+1),a
0119: 04      		inc	b
011A: F20D01  		jp	p,0$
              		
              		; Mark any banks that record correctly
011D: 0600    		ld	b,0
011F: 21960D  		ld	hl,alloc_bank_map
0122: AF      	1$:	xor	a
0123: 77      		ld	(hl),a
0124: 78      		ld	a,b
0125: CD7202  		call	zmm_bnk3_set
0128: 3A00C0  		ld	a,(zmm_top)
012B: B8      		cp	b
012C: C24401  		jp	nz,2$
012F: 3A01C0  		ld	a,(zmm_top+1)
0132: 4F      		ld	c,a
0133: 78      		ld	a,b
0134: ED44    		neg
0136: B9      		cp	c
0137: C24401  		jp	nz,2$
              	
              		; Mark it
013A: 3EFF    		ld	a,0xFF
013C: 77      		ld	(hl),a
013D: 3A950D  		ld	a,(banks_free)
0140: 3C      		inc	a
0141: 32950D  		ld	(banks_free),a
              		
              		; Next
0144: 23      	2$:	inc	hl
0145: 04      		inc	b
0146: F22201  		jp	p,1$
              		
              		; Disable virtual mode
0149: CD1302  		call	zmm_set_real
              		
              		; Print out result
014C: 3A950D  		ld	a,(banks_free)
014F: CDD008  		call	tohex
0152: ED53BC09		ld	(str_mem_init_cnt),de
0156: 119709  		ld	de,str_mem_init
0159: CDA208  		call	cpm_print
              		
              		; Do we actually have an acceptable amount of memory?
015C: 3A950D  		ld	a,(banks_free)
015F: 3D      		dec	a
0160: 3D      		dec	a
0161: FAA301  		jp	m,mem_empty
              		
              		; We do, return
0164: C9      		ret
              		
              	; Allocates a bank of memory
              	; Will produce an error if no banks are available,
              	; check (banks_free) to avoid
              	; D = Owner ID (1-254)
              	;
              	; Returns A = Bank #
              	; Uses: AF, BC, HL
0165:         	mem_alloc:
              		; Check and decrement free memory
0165: 3A950D  		ld	a,(banks_free)
0168: 3D      		dec	a
0169: 32950D  		ld	(banks_free),a
016C: FAA301  		jp	m,mem_empty
              		
              		; Look for the first free bank
016F: 21960D  		ld	hl,alloc_bank_map
0172: 018000  		ld	bc,0x0080
0175: 3EFF    		ld	a,0xFF
0177: EDB1    		cpir
              		
              		; Make sure we found something
0179: C2A301  		jp	nz,mem_empty
              		
              		; Save and exit
017C: 2B      		dec	hl
017D: 72      		ld	(hl),d
017E: 01960D  		ld	bc,alloc_bank_map
0181: B7      		or	a
0182: ED42    		sbc	hl,bc
0184: 7D      		ld	a,l
0185: C9      		ret
              		
              	; Frees a bank of memory
              	; Safe to use on banks that are not free / not owned
              	; A = Bank #
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
0186:         	mem_free:
              		; Find location in memory
0186: 0600    		ld	b,0
0188: 4F      		ld	c,a
0189: 21960D  		ld	hl,alloc_bank_map
018C: 09      		add	hl,bc
              		
              		; Check owner
018D: 7E      		ld	a,(hl)
018E: BA      		cp	d
018F: C0      		ret	nz
              		
              		; Free bank
0190: 3EFF    		ld	a,0xFF
0192: 77      		ld	(hl),a
              		
              		; Increment banks free
0193: 21950D  		ld	hl,banks_free
0196: 34      		inc	(hl)
0197: C9      		ret
              		
              	; Free all banks by owner
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
0198:         	mem_free_all:
              		; Free a bank
0198: AF      		xor	a
0199: F5      	0$:	push	af
019A: CD8601  		call	mem_free
019D: F1      		pop	af
              		
              		; Next bank
019E: 3C      		inc	a
019F: F29901  		jp	p,0$
01A2: C9      		ret
              		
              	; Error out if empty
              	;
              	; Does not return
              	; Uses: N/A
01A3:         	mem_empty:
01A3: 11C209  		ld	de,str_mem_empty
01A6: CDA208  		call	cpm_print
01A9: C3C808  		jp	cpm_exit
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0997:         	str_mem_init:
0997: 494E4954		defb	'INITIALIZED MEMORY MAP',0x0A,0x0D
099B: 49414C49	
099F: 5A454420	
09A3: 4D454D4F	
09A7: 5259204D	
09AB: 41500A0D	
09AF: 42414E4B		defb	'BANK COUNT = '
09B3: 20434F55	
09B7: 4E54203D	
09BB: 20      	
09BC:         	str_mem_init_cnt:
09BC: 5858480A		defb	'XXH',0x0A,0x0D,'$'
09C0: 0D24    	
              		
09C2:         	str_mem_empty:
09C2: 494E5355		defb	'INSUFFICIENT MEMORY',0x0A,0x0D,'$'
09C6: 46464943	
09CA: 49454E54	
09CE: 204D454D	
09D2: 4F52590A	
09D6: 0D24    	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Free bank count
0D95:         	banks_free:
0D95: 00      		defs	1
              	
              	; Allocated bank map
              	; This 128 byte table keeps track of every single 16K bank
              	; that exists on the ZMM. Populated on startup
0D96:         	alloc_bank_map:
0D96: 00000000		defs	128
0D9A: 00...   	
              	#include "ZMM.asm"
              	;
              	;********************************************************************
              	;*
              	;*                  Z M M   M A N A G E M E N T
              	;* 
              	;*    These routines are used to manage the state of the ZMM.
              	;*    This includes the setting of the registers as well as setting
              	;*    up trap and interrupt stuff.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize ZMM and reset registers
              	;
              	; Returns nothing
              	; Uses: AF
01AC:         	zmm_init:
              		; Zero out control register
01AC: 3E00    		ld	a,0
01AE: 32160E  		ld	(zmm_ctrl_state),a
01B1: 32170E  		ld	(zmm_bnk0_state),a
01B4: 32180E  		ld	(zmm_bnk1_state),a
01B7: 32190E  		ld	(zmm_bnk2_state),a
01BA: 321A0E  		ld	(zmm_bnk3_state),a
              		
              		; See if we can swing in and out of virtual mode
01BD: CD0802  		call	zmm_set_virt
01C0: CD1302  		call	zmm_set_real
              		
              		; Tell the user that the ZMM is ready
01C3: 11D809  		ld	de,str_zmm_init
01C6: C3A208  		jp	cpm_print
              		
              	; Start execution of the virtual machine at a specific location
              	; HL = Address to start execution at
              	; 
              	; Does not return
              	; Uses: All registers zeroed
01C9:         	zmm_vm_start:
01C9: 310000  		ld	sp,0x0000
              		
              		; Completely empty out capture zone
01CC: E5      		push	hl
01CD: 210070  		ld	hl,zmm_capture
01D0: 110170  		ld	de,zmm_capture+1
01D3: 01FF0F  		ld	bc,0x1000-1
01D6: AF      		xor	a
01D7: 77      		ld	(hl),a
01D8: EDB0    		ldir
01DA: E1      		pop	hl
              		
01DB: 7D      		ld	a,l
01DC: 320070  		ld	(zmm_capture),a
01DF: 7C      		ld	a,h
01E0: 320170  		ld	(zmm_capture + 1),a
              		
              		; Reset I/O trap flag just in case
01E3: D337    		out	(zmm_trap),a
              		
              		; Zero everything
01E5: 3E01    		ld	a,1
01E7: 47      		ld	b,a
01E8: 4F      		ld	c,a
01E9: 57      		ld 	d,a
01EA: 5F      		ld	e,a
01EB: 67      		ld	h,a
01EC: 6F      		ld	l,a
01ED: D9      		exx
01EE: 08      		ex	af,af'
01EF: 3E01    		ld	a,1
01F1: 47      		ld	b,a
01F2: 4F      		ld	c,a
01F3: 57      		ld 	d,a
01F4: 5F      		ld	e,a
01F5: 67      		ld	h,a
01F6: 6F      		ld	l,a
              		
01F7: DD210000		ld	ix,0
01FB: FD210000		ld	iy,0
              		
              		; Enter virtual machine
01FF: 00      		nop
0200: ED45    		retn
              		
              	; Set the ZMM control register to the recorded state
              	; (zmm_ctrl_state) = New value of ZMM control register
              	;
              	; Returns nothing
              	; Uses: AF
0202:         	zmm_ctrl_set:
0202: 3A160E  		ld	a,(zmm_ctrl_state)
0205: D334    		out	(zmm_ctrl),a
0207: C9      		ret
              		
              	; Go to virtual mode
              	;
              	; Returns nothing
              	; Uses: AF
0208:         	zmm_set_virt:
0208: 3A160E  		ld	a,(zmm_ctrl_state)
020B: F601    		or	0b00000001
020D: 32160E  		ld	(zmm_ctrl_state),a
0210: D334    		out	(zmm_ctrl),a
0212: C9      		ret
              		
              	; Go to real mode
              	;
              	; Returns nothing
              	; Uses: AF
0213:         	zmm_set_real:
0213: 3A160E  		ld	a,(zmm_ctrl_state)
0216: E6FE    		and	0b11111110
0218: 32160E  		ld	(zmm_ctrl_state),a
021B: D334    		out	(zmm_ctrl),a
021D: C9      		ret
              		
              	; Set program direction to "IN"
              	;
              	; Returns nothing
              	; Uses: AF
021E:         	zmm_prgm_in:
021E: 3A160E  		ld	a,(zmm_ctrl_state)
0221: F602    		or	0b00000010
0223: 32160E  		ld	(zmm_ctrl_state),a
0226: D334    		out	(zmm_ctrl),a
0228: C9      		ret
              		
              	; Set program direction to "OUT"
              	;
              	; Returns nothing
              	; Uses: AF
0229:         	zmm_prgm_out:
0229: 3A160E  		ld	a,(zmm_ctrl_state)
022C: E6FD    		and	0b11111101
022E: 32160E  		ld	(zmm_ctrl_state),a
0231: D334    		out	(zmm_ctrl),a
0233: C9      		ret
              		
              	; Turn on irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
0234:         	zmm_irq_inter:
0234: 3A160E  		ld	a,(zmm_ctrl_state)
0237: F604    		or	0b00000100
0239: 32160E  		ld	(zmm_ctrl_state),a
023C: D334    		out	(zmm_ctrl),a
023E: C9      		ret
              		
              	; Turn off irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
023F:         	zmm_irq_normal:
023F: 3A160E  		ld	a,(zmm_ctrl_state)
0242: E6FB    		and	0b11111011
0244: 32160E  		ld	(zmm_ctrl_state),a
0247: D334    		out	(zmm_ctrl),a
0249: C9      		ret
              	
              	; Turn on force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
024A:         	zmm_irq_on:
024A: 3A160E  		ld	a,(zmm_ctrl_state)
024D: F608    		or	0b00001000
024F: 32160E  		ld	(zmm_ctrl_state),a
0252: D334    		out	(zmm_ctrl),a
0254: C9      		ret
              		
              	; Turn off force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
0255:         	zmm_irq_off:
0255: 3A160E  		ld	a,(zmm_ctrl_state)
0258: E6F7    		and	0b11110111
025A: 32160E  		ld	(zmm_ctrl_state),a
025D: D334    		out	(zmm_ctrl),a
025F: C9      		ret
              		
              	; Set bank 0
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses: AF, B
0260:         	zmm_bnk0_set:
0260: 32170E  		ld	(zmm_bnk0_state),a
0263: D330    		out	(zmm_bnk0),a
0265: C9      		ret
              		
              	; Set bank 1
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
0266:         	zmm_bnk1_set:
0266: 32180E  		ld	(zmm_bnk1_state),a
0269: D331    		out	(zmm_bnk1),a
026B: C9      		ret
              		
              	; Set bank 2
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
026C:         	zmm_bnk2_set:
026C: 32190E  		ld	(zmm_bnk2_state),a
026F: D332    		out	(zmm_bnk2),a
0271: C9      		ret
              		
              	; Set bank 3
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
0272:         	zmm_bnk3_set:
0272: 321A0E  		ld	(zmm_bnk3_state),a
0275: D333    		out	(zmm_bnk3),a
0277: C9      		ret
              		
              		
              	; Write protect bank 0
              	;
              	; Returns nothing
              	; Uses: AF
0278:         	zmm_bnk0_wp:
0278: 3A170E  		ld	a,(zmm_bnk0_state)
027B: F680    		or	0b10000000
027D: C36002  		jp 	zmm_bnk0_set
              		
              	; Write enable bank 0
              	;
              	; Returns nothing
              	; Uses: AF
0280:         	zmm_bnk0_we:
0280: 3A170E  		ld	a,(zmm_bnk0_state)
0283: E67F    		and	~0b10000000
0285: C36002  		jp 	zmm_bnk0_set
              		
              	; Write protect bank 1
              	;
              	; Returns nothing
              	; Uses: AF
0288:         	zmm_bnk1_wp:
0288: 3A180E  		ld	a,(zmm_bnk1_state)
028B: F680    		or	0b10000000
028D: C36602  		jp 	zmm_bnk1_set
              		
              	; Write enable bank 1
              	;
              	; Returns nothing
              	; Uses: AF
0290:         	zmm_bnk1_we:
0290: 3A180E  		ld	a,(zmm_bnk1_state)
0293: E67F    		and	~0b10000000
0295: C36602  		jp 	zmm_bnk1_set
              		
              	; Write protect bank 2
              	;
              	; Returns nothing
              	; Uses: AF
0298:         	zmm_bnk2_wp:
0298: 3A190E  		ld	a,(zmm_bnk2_state)
029B: F680    		or	0b10000000
029D: C36C02  		jp 	zmm_bnk2_set
              		
              	; Write enable bank 2
              	;
              	; Returns nothing
              	; Uses: AF
02A0:         	zmm_bnk2_we:
02A0: 3A190E  		ld	a,(zmm_bnk2_state)
02A3: E67F    		and	~0b10000000
02A5: C36C02  		jp 	zmm_bnk2_set
              		
              	; Write protect bank 3
              	;
              	; Returns nothing
              	; Uses: AF
02A8:         	zmm_bnk3_wp:
02A8: 3A1A0E  		ld	a,(zmm_bnk3_state)
02AB: F680    		or	0b10000000
02AD: C37202  		jp 	zmm_bnk3_set
              		
              	; Write enable bank 3
              	;
              	; Returns nothing
              	; Uses: AF
02B0:         	zmm_bnk3_we:
02B0: 3A1A0E  		ld	a,(zmm_bnk3_state)
02B3: E67F    		and	~0b10000000
02B5: C37202  		jp 	zmm_bnk3_set
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
09D8:         	str_zmm_init:
09D8: 494E4954		defb	'INITIALIZED ZMM',0x0A,0x0D,'$'
09DC: 49414C49	
09E0: 5A454420	
09E4: 5A4D4D0A	
09E8: 0D24    	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
0E16:         	zmm_ctrl_state:
0E16: 00      		defs	1
              		
              	; Bank 0 state
0E17:         	zmm_bnk0_state:
0E17: 00      		defs	1
              		
              	; Bank 1 state
0E18:         	zmm_bnk1_state:
0E18: 00      		defs	1
              		
              	; Bank 2 state
0E19:         	zmm_bnk2_state:
0E19: 00      		defs	1
              		
              	; Bank 3 state
0E1A:         	zmm_bnk3_state:
0E1A: 00      		defs	1
              		
              	#include "RESOURCE.asm"
              	;
              	;********************************************************************
              	;*
              	;*               R E S O U R C E   M A N A G E M E N T
              	;* 
              	;*    These routines handle obtaining use-supplied resources
              	;*    such as configurations, ROM images, and storage bindings.
              	;*    During startup, these resources will be loaded to build
              	;*    the virtual machine.
              	;*
              	;********************************************************************
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
0010:         	arg_size	equ 16
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize resources
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
02B8:         	res_init:
              		; Start by zero-terminating string
02B8: 218000  		ld	hl,cpm_command
02BB: 4E      		ld	c,(hl)
02BC: 0600    		ld	b,0
02BE: 09      		add	hl,bc
02BF: 23      		inc	hl
02C0: 70      		ld	(hl),b
              		
02C1: C9      		ret
              		
              	; Loads an open resource into a bankmap
              	; Bankmap will be zero-padded to fill requested number of records
              	; HL = Address of bankmap
              	; BC = Number of records (128 byte blocks) to load
              	;
              	; Returns nothing
              	; Uses: all
02C2:         	res_load:
              		; Set read flag
02C2: 3EFF    		ld	a,0xFF
02C4: 32B00E  		ld	(res_do_read),a
              	
              		; Save args
02C7: 22B10E  		ld	(res_bankmap),hl
02CA: ED43AE0E		ld	(res_sectors),bc
              	
              		; Virtual mode should be off while we do this
02CE: 3A160E  		ld	a,(zmm_ctrl_state)
02D1: F5      		push	af
02D2: CD1302  		call	zmm_set_real
              		
              		; Do function call
02D5: CDE402  		call	0$
              		
              		; Reset bank 3
02D8: 3A1A0E  		ld	a,(zmm_bnk3_state)
02DB: D333    		out	(zmm_bnk3),a
              		
              		; Restore register
02DD: F1      		pop	af
02DE: 32160E  		ld	(zmm_ctrl_state),a
02E1: C30202  		jp	zmm_ctrl_set
              		
              		; Allocate a new bank
02E4: 1601    	0$:	ld	d,1
02E6: CD6501  		call	mem_alloc
02E9: 2AB10E  		ld	hl,(res_bankmap)
02EC: 77      		ld	(hl),a
02ED: 23      		inc	hl
02EE: 22B10E  		ld	(res_bankmap),hl
              		
              		; Set the bank in slot 3
02F1: D333    		out	(zmm_bnk3),a
              		
              		; Set DMA address
02F3: 112E0E  		ld	de,res_buffer
02F6: 0E1A    		ld	c,bios_set_dma
02F8: CD0500  		call	bdos
              		
              		; Set pointer	
02FB: 2100C0  		ld	hl,zmm_top
02FE: 22B30E  		ld	(res_pointer),hl
              		
              		; We will be loading up to 128 records at a time here
0301: 0680    		ld	b,128
              		
              		; Do read operation
0303: C5      	1$:	push	bc
0304: 11B50E  		ld	de,res_fcb
0307: 0E14    		ld	c,bdos_read
0309: 3AB00E  		ld	a,(res_do_read)
030C: B7      		or	a
030D: C40500  		call	nz,bdos
              		
              		; Check file I/O result
0310: B7      		or	a
0311: C43A03  		call	nz,50$
              		
              		; Go to virtual mode
0314: CD0802  		call	zmm_set_virt
              		
              		; Copy record to bank
0317: 212E0E  		ld	hl,res_buffer
031A: ED5BB30E		ld	de,(res_pointer)
031E: 018000  		ld	bc,128
0321: EDB0    		ldir
0323: ED53B30E		ld	(res_pointer),de
              		
              		; Back to real mode
0327: CD1302  		call	zmm_set_real 
              		
              		; Get BC back to restore sector counter
032A: C1      		pop	bc
              		
              		; Decrement record count
032B: 2AAE0E  		ld	hl,(res_sectors)
032E: 2B      		dec	hl
032F: 22AE0E  		ld	(res_sectors),hl
0332: 7C      		ld	a,h
0333: B5      		or	l
0334: C8      		ret	z
              		
              		; Go get another sector
0335: 10CC    		djnz	1$
0337: C3E402  		jp	0$
              	
              		; Zero buffer and reset read flag
033A: AF      	50$:	xor	a
033B: 32B00E  		ld	(res_do_read),a
              		
033E: 212E0E  		ld	hl,res_buffer
0341: 112F0E  		ld	de,res_buffer+1
0344: 017F00  		ld	bc,128-1
0347: 77      		ld	(hl),a
0348: EDB0    		ldir
              	
034A: C9      		ret
              		
              	; Throws an error a missing resource
              	; Resource name will be last attempted to locate
              	;
              	; Does not return
              	; Uses: N/A
034B:         	res_missing:
034B: CD1302  		call	zmm_set_real
              		
              		; Print error message
034E: 0E09    		ld	c,bdos_print
0350: 11270A  		ld	de,str_missing
0353: CD0500  		call	bdos
              		
              		; Print resource name
0356: ED5B2C0E		ld	de,(res_current)
035A: CD4B04  		call	res_printzt
              		
              		; CRLF
035D: 0E09    		ld	c,bdos_print
035F: 11490B  		ld	de,str_crlf
0362: CD0500  		call	bdos
              		
              		; Exit
0365: C3C808  		jp	cpm_exit
              		
              	; Opens a file based on the resource argument
              	; If the file cannot be opened, an error will be thrown
              	; (res_argument) = File to open
              	;
              	; Returns nothing
              	; Uses: all
0368:         	res_open:
              		; Virtual mode should be off while we do this
0368: 3A160E  		ld	a,(zmm_ctrl_state)
036B: F5      		push	af
036C: CD1302  		call	zmm_set_real
              		
              		; Do function call
036F: CD7903  		call	0$
              		
              		; Restore register
0372: F1      		pop	af
0373: 32160E  		ld	(zmm_ctrl_state),a
0376: C30202  		jp	zmm_ctrl_set
              		
              		; Let the user know we are loading stuff
0379: 0E09    	0$:	ld	c,bdos_print
037B: 11EA09  		ld	de,str_load_a
037E: CD0500  		call	bdos
              		
              		; Print resource name
0381: ED5B2C0E		ld	de,(res_current)
0385: CD4B04  		call	res_printzt
              		
              		; Next string
0388: 0E09    		ld	c,bdos_print
038A: 11F309  		ld	de,str_load_b
038D: CD0500  		call	bdos
              		
              		; Print file name
0390: 111B0E  		ld	de,res_argument
0393: CD4B04  		call	res_printzt
              		
              		; CRLF
0396: 0E09    		ld	c,bdos_print
0398: 11490B  		ld	de,str_crlf
039B: CD0500  		call	bdos
              		
              		; Detect if there is an argument
039E: 3A1B0E  		ld	a,(res_argument)
03A1: B7      		or	a
03A2: C2B003  		jp	nz,1$
              		
              		; No argument, error!
03A5: 0E09    		ld	c,bdos_print
03A7: 11FA09  		ld	de,str_arg_empty
03AA: CD0500  		call	bdos
03AD: C3C808  		jp	cpm_exit
              	
              		; Reset fields
03B0: AF      	1$:	xor	a
03B1: 21B50E  		ld	hl,res_fcb
03B4: 11B60E  		ld	de,res_fcb+1
03B7: 012300  		ld	bc ,36-1
03BA: 77      		ld	(hl),a
03BB: EDB0    		ldir
              		
03BD: 3E20    		ld	a,0x20
03BF: 21B60E  		ld	hl,res_fcb_name
03C2: 11B70E  		ld	de,res_fcb_name+1
03C5: 010A00  		ld	bc ,11-1
03C8: 77      		ld	(hl),a
03C9: EDB0    		ldir
              	
              		; Is there a prefix?
03CB: 211B0E  		ld	hl,res_argument
03CE: 3A1C0E  		ld	a,(res_argument+1)
03D1: FE3A    		cp	':'
03D3: C2E503  		jp	nz,2$
              		
              		; Set prefix
03D6: 3A1B0E  		ld	a,(res_argument)
03D9: D640    		sub	'A'-1
03DB: FE11    		cp	17
03DD: D24004  		jp	nc,99$
03E0: 32B50E  		ld	(res_fcb_drive),a
03E3: 23      		inc	hl
03E4: 23      		inc	hl
              	
              		; HL = Proper filename start
03E5: 0608    	2$:	ld	b,8
03E7: 11B60E  		ld	de,res_fcb_name
              		
              		; Copy it over
03EA: 7E      	3$:	ld	a,(hl)
03EB: B7      		or	a
03EC: CA4004  		jp	z,99$
03EF: FE2A    		cp	'*'
03F1: CA0104  		jp	z,4$
03F4: FE2E    		cp	'.'
03F6: CA0804  		jp	z,5$
03F9: 12      		ld	(de),a
03FA: 13      		inc	de
03FB: 23      		inc	hl
03FC: 10EC    		djnz	3$
03FE: C30804  		jp	5$
              	
              		; Fill remains of FCB file name
0401: 3E3F    	4$:	ld	a,'?'
0403: 12      		ld	(de),a
0404: 13      		inc	de
0405: 10FA    		djnz	4$
0407: 23      		inc	hl
              	
              		; We should either see a '.' or a null character
0408: 7E      	5$:	ld	a,(hl)
0409: B7      		or	a
040A: CA3104  		jp	z,8$
040D: FE2E    		cp	'.'
040F: C24004  		jp	nz,99$
0412: 23      		inc	hl
              		
              		; Fill in extension
0413: 0603    		ld	b,3
0415: 11BE0E  		ld	de,res_fcb_type
              		
              		; Copy it over
0418: 7E      	6$:	ld	a,(hl)
0419: B7      		or	a
041A: CA3104  		jp	z,8$
041D: FE2A    		cp	'*'
041F: CA2A04  		jp	z,7$
0422: 12      		ld	(de),a
0423: 13      		inc	de
0424: 23      		inc	hl
0425: 10F1    		djnz	6$
0427: C33104  		jp	8$
              		
              		; Fill remains of FCB file extension
042A: 3E3F    	7$:	ld	a,'?'
042C: 12      		ld	(de),a
042D: 13      		inc	de
042E: 10D1    		djnz	4$
0430: 23      		inc	hl
              	
              		; We should get a zero
0431: 7E      	8$:	ld 	a,(hl)
0432: B7      		or	a
0433: C24004  		jp	nz,99$
              		
              		; It is filled in, attempt to open
0436: 0E0F    		ld	c,bdos_open
0438: 11B50E  		ld	de,res_fcb
043B: CD0500  		call	bdos
              		
              		; Check error
043E: 3C      		inc	a
043F: C0      		ret	nz
              		
              		; Error!
0440: 0E09    	99$:	ld	c,bdos_print
0442: 11110A  		ld	de,str_arg_fail
0445: CD0500  		call	bdos
0448: C3C808  		jp	cpm_exit
              		
              		
              	; Print a zero terminated string
              	; We should be in real mode for this
              	; DE = String
              	;
              	; Returns nothing
              	; Uses: All
044B:         	res_printzt:
044B: 1A      	0$:	ld	a,(de)
044C: B7      		or	a
044D: C8      		ret	z
              		
              		; Print character
044E: D5      		push	de
044F: 5F      		ld	e,a
0450: 0E02    		ld	c,bdos_con_out
0452: CD0500  		call	bdos
0455: D1      		pop	de
0456: 13      		inc	de
0457: C34B04  		jp	0$
              	
              	; Find a resource from the command line
              	; If the resource is found, the contents will be cached in memory
              	; DE = Name of resource (upper case only) 
              	;
              	; Returns A = 0xFF if no resource is found
              	; Uses: AF, BC, DE, HL
045A:         	res_locate:
              		; Save resource
045A: ED532C0E		ld	(res_current),de
              	
              		; Travel to the start of arguments
045E: 218100  		ld	hl,cpm_command+1
0461: 7E      	0$:	ld	a,(hl)
0462: B7      		or	a
0463: CAC004  		jp	z,99$
0466: FE21    		cp	0x21
0468: D26F04  		jp	nc,1$
046B: 23      		inc	hl
046C: C36104  		jp	0$
              		
              		; Found an argument
              		; Check it against the contents of (DE)
              		; Also must start with '-'
046F: FE2D    	1$:	cp	'-'
0471: C28204  		jp	nz,3$
0474: 23      		inc	hl
0475: D5      		push	de
0476: 1A      	2$:	ld	a,(de)
              		
              		; Check if at end of string
0477: B7      		or	a
0478: CA9004  		jp	z,4$
              		
              		; No? Well lets see if (de) = (hl)
047B: BE      		cp	(hl)
047C: 23      		inc	hl
047D: 13      		inc	de
047E: CA7604  		jp	z,2$
              		
              		; Strings are different!
              		; Escape from the current argument and continue
0481: D1      		pop	de
0482: 7E      	3$:	ld	a,(hl)
0483: B7      		or	a
0484: CAC004  		jp	z,99$
0487: FE21    		cp	0x21
0489: DA6104  		jp	c,0$
048C: 23      		inc	hl
048D: C38204  		jp	3$
              	
              		; Make sure we are at the end of the argument as well
0490: D1      	4$: 	pop	de
0491: 7E      		ld	a,(hl)
0492: FE21    		cp	0x21
0494: D28204  		jp	nc,3$
              		
              		; Ok, lets copy the argument into memory if it exists
0497: 111B0E  		ld	de,res_argument
049A: AF      		xor	a
049B: 12      		ld	(de),a
              		
              		; Travel to the start of the argument
049C: 7E      	5$:	ld	a,(hl)
049D: B7      		or	a
049E: CABE04  		jp	z,89$
04A1: FE21    		cp	0x21
04A3: D2AA04  		jp	nc,6$
04A6: 23      		inc	hl
04A7: C39C04  		jp	5$
              	
              		; Make sure it doesn't start with '-'
04AA: FE2D    	6$:	cp	'-'
04AC: CABE04  		jp	z,89$
              		
              		; Ok, lets copy up 16 bytes of this
04AF: 0610    		ld	b,arg_size
04B1: 7E      	7$:	ld	a,(hl)
04B2: FE21    		cp	0x21
04B4: DABC04  		jp	c,8$
04B7: 12      		ld	(de),a
04B8: 23      		inc	hl
04B9: 13      		inc	de
04BA: 10F5    		djnz	7$
              	
              		; Zero terminate
04BC: AF      	8$:	xor	a
04BD: 12      		ld	(de),a
              		
              		; Good ending
04BE: AF      	89$:	xor	a
04BF: C9      		ret
              	
              		; Bad ending
04C0: 3EFF    	99$:	ld	a,0xFF
04C2: C9      		ret
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Loading string components
09EA:         	str_load_a:
09EA: 4C4F4144		defb	'LOADING $'
09EE: 494E4720	
09F2: 24      	
              		
09F3:         	str_load_b:
09F3: 2046524F		defb	' FROM $'
09F7: 4D2024  	
              		
              	; Error messages
09FA:         	str_arg_empty:
09FA: 4E4F2041		defb	'NO ARGUMENT PROVIDED',0x0A,0x0D,'$'
09FE: 5247554D	
0A02: 454E5420	
0A06: 50524F56	
0A0A: 49444544	
0A0E: 0A0D24  	
              		
0A11:         	str_arg_fail:
0A11: 4641494C		defb	'FAILED TO OPEN FILE',0x0A,0x0D,'$'
0A15: 45442054	
0A19: 4F204F50	
0A1D: 454E2046	
0A21: 494C450A	
0A25: 0D24    	
              		
0A27:         	str_missing:
0A27: 4D495353		defb	'MISSING RESOURCE: $'
0A2B: 494E4720	
0A2F: 5245534F	
0A33: 55524345	
0A37: 3A2024  	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Stores a zero-terminated string for the resource argument
0E1B:         	res_argument:
0E1B: 00000000		defs	arg_size+1
0E1F: 00...   	
              		
              	; Current resource being accessed
0E2C:         	res_current:
0E2C: 0000    		defs	2
              		
              	; Resource buffer
0E2E:         	res_buffer:
0E2E: 00000000		defs	128
0E32: 00...   	
              		
              	; Sector counter
0EAE:         	res_sectors:
0EAE: 0000    		defs	2
              		
              	; Do we need to read?
0EB0:         	res_do_read:
0EB0: 00      		defs	1
              		
              	; Resource bankmap
0EB1:         	res_bankmap:
0EB1: 0000    		defs	2
              		
              	; Loading pointer
0EB3:         	res_pointer:
0EB3: 0000    		defs	2
              		
              	; File control block for use in loading resources
0EB5:         	res_fcb:
0EB5: 00000000		defs	36
0EB9: 00...   	
0EB5:         	res_fcb_drive	equ	res_fcb
0EB6:         	res_fcb_name	equ	res_fcb+1
0EBE:         	res_fcb_type	equ	res_fcb+9
0EC1:         	res_fcb_ex	equ	res_fcb+12
0EC2:         	res_fcb_s1	equ	res_fcb+13
0EC3:         	res_fcb_s2	equ	res_fcb+14
0EC4:         	res_fcb_rc	equ	res_fcb+15
0EC5:         	res_fcb_data	equ	res_fcb+16
0ED5:         	res_fcb_cr	equ	res_fcb+32
0ED6:         	res_fcb_r0	equ	res_fcb+33
0ED7:         	res_fcb_r1	equ	res_fcb+34
0ED8:         	res_fcb_r2	equ	res_fcb+35
              	#include "TRAP.asm"
              	;
              	;********************************************************************
              	;*
              	;*                     T R A P   H A N D L E R
              	;* 
              	;*    Responsible for handling various traps from the ZMM. Both
              	;*    interrupt and I/O traps will be pre-processed before being
              	;*    sent to the virtualization core for device-specific handling
              	;*
              	;********************************************************************
              	
              	; -------------------------------
              	; ********  Trap Handler ********
              	; -------------------------------
              	
              	.area	_TEXT
              	
              	; Entry point for traps
04C3:         	trap_entry:
              		; Save value of SP
04C3: ED73D90E		ld	(trap_sp_value),sp
04C7: 310070  		ld	sp,kri_stack
              		
              		; Save value of AF
04CA: F5      		push	af
              		
              		; Check in on device interrupts
04CB: CD9209  		call	irq_handle
              		
              		; Grab the value of the ISR register
04CE: DB30    		in	a,(zmm_isr)
              		
              		; Do we actually need to handle an I/O trap?
04D0: B7      		or	a
04D1: F2AC06  		jp	p,trap_continue
              		
              		; OK, a trap did occur.
              		; Are we doing "classic" I/O or extended I/O?
04D4:         	trap_io:	
04D4: FEE8    		cp	0b11101000
04D6: DAF004  		jp	c,trap_io_ext
              		
              		; In or out?
04D9: FEEC    		cp	0b11101100
04DB: DAE704  		jp	c,0$
              		
              		; In it is
04DE: CD9309  		call	in_handle
04E1: 32FF6F  		ld	(trap_a_value),a
04E4: C3AC06  		jp	trap_continue
              		
              		; Out it is
04E7: 3AFF6F  	0$:	ld	a,(trap_a_value)
04EA: CD9609  		call	out_handle
04ED: C3AC06  		jp	trap_continue
              	
              	
              	; It's an extended I/O instruction
04F0:         	trap_io_ext:
              	
              		; Input or output?
04F0: 0F      		rrca
04F1: DA6605  		jp	c,trap_io_ex_out
              		
              		; Extended input instruction
              		; INI-class?
04F4: 0F      		rrca
04F5: DAC005  		jp	c,trap_io_inx
              		
              		; Left or right column
04F8: 0F      		rrca
04F9: DA2305  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
04FC: 0F      		rrca
04FD: DA1205  		jp	c,1$
              		
              		; B or H?
0500: 0F      		rrca
0501: DA0B05  		jp	c,2$
              		
              		; It's B
0504: CD9309  		call	in_handle
0507: 47      		ld	b,a
0508: C34D05  		jp	90$
              		
              		; It's H	
050B: CD9309  	2$:	call	in_handle
050E: 67      		ld	h,a
050F: C34D05  		jp	90$
              	
              		; D or 0?
0512: 0F      	1$:	rrca
0513: DA1D05  		jp	c,3$
              	
              		; It's D
0516: CD9309  		call	in_handle
0519: 57      		ld	d,a
051A: C34D05  		jp	90$
              		
              		; It's 0
051D: CD9309  	3$:	call	in_handle
0520: C34D05  		jp	90$
              		
              		
              		; Right column
              		; C, E, L, or A?
0523: 0F      	0$:	rrca
0524: DA3905  		jp	c,4$
              		
              		; C or L?
0527: 0F      		rrca
0528: DA3205  		jp	c,5$
              		
              		; It's C
052B: CD9309  		call	in_handle
052E: 4F      		ld	c,a
052F: C34D05  		jp	90$
              	
              		; It's L
0532: CD9309  	5$:	call	in_handle
0535: 6F      		ld	l,a
0536: C34D05  		jp	90$
              		
              		; E or A?
0539: 0F      	4$:	rrca
053A: DA4405  		jp	c,6$
              		
              		; It's E
053D: CD9309  		call	in_handle
0540: 5F      		ld	e,a
0541: C34D05  		jp	90$
              	
              		; It's A
0544: CD9309  	6$:	call	in_handle
0547: 32FF6F  		ld	(trap_a_value),a
054A: C34D05  		jp	90$
              		
              		; Extended IN instructions require special flag states
              		; lets set them and return
054D: E5      	90$:	push	hl
054E: 21FE6F  		ld	hl,trap_f_value
0551: CB46    		bit	0,(hl)
0553: E1      		pop	hl
              		
              		; If it's zero, we don't need the carry flag
0554: CA5F05  		jp	z,91$ 
              		
              		; Update flags and persist carry flag
0557: B7      		or	a
0558: 37      		scf
0559: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Do trap restore
055C: C3AD06  		jp	trap_restore
              		
              		; Update flags and reset carry flag
055F: B7      	91$:	or	a
0560: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Do trap restore
0563: C3AD06  		jp	trap_restore
              		
              	; Extended output instruction
0566:         	trap_io_ex_out:
              	
              		; OUTI-class?
0566: 0F      		rrca
0567: DA3606  		jp	c,trap_io_outx
              		
              		; Left or right column?
056A: 0F      		rrca
056B: DA9605  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
056E: 0F      		rrca
056F: DA8405  		jp	c,1$
              		
              		; B or H?
0572: 0F      		rrca
0573: DA7D05  		jp	c,2$
              		
              		; It's B
0576: 78      		ld	a,b
0577: CD9609  		call	out_handle
057A: C3AC06  		jp	trap_continue
              		
              		; It's H	
057D: 7C      	2$:	ld	a,h
057E: CD9609  		call	out_handle
0581: C3AC06  		jp	trap_continue
              	
              		; D or 0?
0584: 0F      	1$:	rrca
0585: DA8F05  		jp	c,3$
              	
              		; It's D
0588: 7A      		ld	a,d
0589: CD9609  		call	out_handle
058C: C3AC06  		jp	trap_continue
              		
              		; It's 0
058F: AF      	3$:	xor	a
0590: CD9609  		call	out_handle
0593: C3AC06  		jp	trap_continue
              		
              		
              		; Right column
              		; C, E, L, or A?
0596: 0F      	0$:	rrca
0597: DAAC05  		jp	c,4$
              		
              		; C or L?
059A: 0F      		rrca
059B: DAA505  		jp	c,5$
              		
              		; It's C
059E: 79      		ld	a,c
059F: CD9609  		call	out_handle
05A2: C3AC06  		jp	trap_continue
              	
              		; It's L
05A5: 7D      	5$:	ld	a,l
05A6: CD9609  		call	out_handle
05A9: C3AC06  		jp	trap_continue
              		
              		; E or A?
05AC: 0F      	4$:	rrca
05AD: DAB705  		jp	c,6$
              		
              		; It's E
05B0: 7B      		ld	a,e
05B1: CD9609  		call	out_handle
05B4: C3AC06  		jp	trap_continue
              	
              		; It's A
05B7: 3AFF6F  	6$:	ld	a,(trap_a_value)
05BA: CD9609  		call	out_handle
05BD: C3AC06  		jp	trap_continue
              	
              	
              		; INX class instructions
              		; The CPU should handle the differences between INX and INXR
05C0:         	trap_io_inx:
              		; Left or right column?
05C0: 0F      		rrca
05C1: DAFD05  		jp	c,trap_io_ind
              		
              		; Left column, it's 'I' class
05C4: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
05C5: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
05C6: 7C      		ld	a,h
05C7: 07      		rlca
05C8: DADB05  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
05CB: 07      		rlca
05CC: DAD505  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
05CF: 3A170E  		ld	a,(zmm_bnk0_state)
05D2: C3E805  		jp	3$
              		
              		; 0x4000 - 0x7FFF
05D5: 3A180E  	1$:	ld	a,(zmm_bnk1_state)
05D8: C3E805  		jp	3$
              			
              		; 0x8000 - 0xFFFF
05DB: 07      	0$:	rlca
05DC: DAE505  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
05DF: 3A190E  		ld	a,(zmm_bnk2_state)
05E2: C3E805  		jp	3$
              	
              		; 0xC000 - 0xFFFF
05E5: 3A1A0E  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
05E8: E67F    	3$:	and	0b01111111
05EA: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
05EC: 3EC0    		ld	a,0b11000000
05EE: B4      		or	h
05EF: 67      		ld	h,a
              		
              		; Do the input
05F0: CD9309  		call	in_handle
05F3: 77      		ld	(hl),a
              		
              		; Fix banks
05F4: 3A1A0E  		ld	a,(zmm_bnk3_state)
05F7: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
05F9: E1      		pop	hl
05FA: C3AC06  		jp	trap_continue
              		
              		; Right column, it's 'D' class
05FD:         	trap_io_ind:
05FD: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
05FE: 23      		inc	hl	; Increment to reverse 'D' class instruction
05FF: 7C      		ld	a,h
0600: 07      		rlca
0601: DA1406  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0604: 07      		rlca
0605: DA0E06  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0608: 3A170E  		ld	a,(zmm_bnk0_state)
060B: C32106  		jp	3$
              		
              		; 0x4000 - 0x7FFF
060E: 3A180E  	1$:	ld	a,(zmm_bnk1_state)
0611: C32106  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0614: 07      	0$:	rlca
0615: DA1E06  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
0618: 3A190E  		ld	a,(zmm_bnk2_state)
061B: C32106  		jp	3$
              	
              		; 0xC000 - 0xFFFF
061E: 3A1A0E  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0621: E67F    	3$:	and	0b01111111
0623: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0625: 3EC0    		ld	a,0b11000000
0627: B4      		or	h
0628: 67      		ld	h,a
              		
              		; Do the input
0629: CD9309  		call	in_handle
062C: 77      		ld	(hl),a
              		
              		; Fix banks
062D: 3A1A0E  		ld	a,(zmm_bnk3_state)
0630: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0632: E1      		pop	hl
0633: C3AC06  		jp	trap_continue
              	
              		; OUTX-class instructions
              		; The CPU should handle the differences between OUTX and OTXR
0636:         	trap_io_outx:
              	
              		; Left or right column?
0636: 0F      		rrca
0637: DA7306  		jp	c,trap_io_outd
              		
              		; Left column, it's 'I' class
063A: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
063B: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
063C: 7C      		ld	a,h
063D: 07      		rlca
063E: DA5106  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0641: 07      		rlca
0642: DA4B06  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0645: 3A170E  		ld	a,(zmm_bnk0_state)
0648: C35E06  		jp	3$
              		
              		; 0x4000 - 0x7FFF
064B: 3A180E  	1$:	ld	a,(zmm_bnk1_state)
064E: C35E06  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0651: 07      	0$:	rlca
0652: DA5B06  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
0655: 3A190E  		ld	a,(zmm_bnk2_state)
0658: C35E06  		jp	3$
              	
              		; 0xC000 - 0xFFFF
065B: 3A1A0E  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
065E: E67F    	3$:	and	0b01111111
0660: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0662: 3EC0    		ld	a,0b11000000
0664: B4      		or	h
0665: 67      		ld	h,a
              		
              		; Do the output
0666: 7E      		ld	a,(hl)
0667: CD9609  		call	out_handle
              		
              		; Fix banks
066A: 3A1A0E  		ld	a,(zmm_bnk3_state)
066D: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
066F: E1      		pop	hl
              		
0670: C3AC06  		jp	trap_continue
              		
              		; Right column, it's 'D' class
0673:         	trap_io_outd:
0673: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0674: 23      		inc	hl	; Increment to reverse 'D' class instruction
0675: 7C      		ld	a,h
0676: 07      		rlca
0677: DA8A06  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
067A: 07      		rlca
067B: DA8406  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
067E: 3A170E  		ld	a,(zmm_bnk0_state)
0681: C39706  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0684: 3A180E  	1$:	ld	a,(zmm_bnk1_state)
0687: C39706  		jp	3$
              			
              		; 0x8000 - 0xFFFF
068A: 07      	0$:	rlca
068B: DA9406  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
068E: 3A190E  		ld	a,(zmm_bnk2_state)
0691: C39706  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0694: 3A1A0E  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0697: E67F    	3$:	and	0b01111111
0699: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
069B: 3EC0    		ld	a,0b11000000
069D: B4      		or	h
069E: 67      		ld	h,a
              		
              		; Do the output
069F: 7E      		ld	a,(hl)
06A0: CD9609  		call	out_handle
              		
              		; Fix banks
06A3: 3A1A0E  		ld	a,(zmm_bnk3_state)
06A6: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
06A8: E1      		pop	hl
06A9: C3AC06  		jp	trap_continue
              	
              		
              	; Continue execution
06AC:         	trap_continue:
              		; Restore AF
06AC: F1      		pop	af
              		
              		; Restore stack and return
              		; Maybe invoke the debugger as well
06AD:         	trap_restore:
              		
              		; Reset trap state
06AD:         	trap_res_flag:
06AD: 00      		nop
06AE: 00      		nop
06AF: 00      		nop
06B0: D337    		out	(zmm_trap),a
              		
              		; Restore old SP
06B2: ED7BD90E		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
06B6: 00      		nop
06B7: ED45    		retn
              		
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize trap handling stuff
              	;
              	; Returns nothing
              	; Uses: AF, HL
06B9:         	trap_init:
              		; Install trap vector
06B9: 3EC3    		ld	a,0xC3
06BB: 326600  		ld	(nmi_address),a
06BE: 21C304  		ld	hl,trap_entry
06C1: 226700  		ld	(nmi_vector),hl
              		
06C4: C9      		ret
              		
              		
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value of untrapped SP value
0ED9:         	trap_sp_value:
0ED9: 0000    		defs	2
              	#include "IRQ.asm"
              	;
              	;********************************************************************
              	;*
              	;*             I N T E R R U P T   M A N A G E M E N T
              	;* 
              	;*    Manages "real" system interrupts on the host hardware.
              	;*    Also deals with mocking interrupts to the virtual machine
              	;*    if it is needed.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize interrupt stuff
              	;
              	; Returns nothing
              	; Uses: AF
06C5:         	irq_init:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06C5: 3E07    		ld	a,7		; AY register = 7
06C7: D341    		out	(nabu_ay_latch),a
06C9: DB40    		in	a,(nabu_ay_data)
06CB: E63F    		and	0x3F
06CD: F640    		or	0x40
06CF: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off all interrupts
06D1: 3E0E    		ld	a,14		; AY register = 14	
06D3: D341    		out	(nabu_ay_latch),a
06D5: AF      		xor	a
06D6: D340    		out	(nabu_ay_data),a
              		
              		; Return
06D8: C9      		ret
              		
              		
              	; Turns on the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
06D9:         	irq_vdp_on:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06D9: 3E07    		ld	a,7		; AY register = 7
06DB: D341    		out	(nabu_ay_latch),a
06DD: DB40    		in	a,(nabu_ay_data)
06DF: E63F    		and	0x3F
06E1: F640    		or	0x40
06E3: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask on interrupt
06E5: 3E0E    		ld	a,14		; AY register = 14	
06E7: D341    		out	(nabu_ay_latch),a
06E9: DB40    		in	a,(nabu_ay_data)
06EB: F610    		or	0b00010000
06ED: D340    		out	(nabu_ay_data),a
              		
06EF: C9      		ret
              		
              	; Turns off the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
06F0:         	irq_vdp_off:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06F0: 3E07    		ld	a,7		; AY register = 7
06F2: D341    		out	(nabu_ay_latch),a
06F4: DB40    		in	a,(nabu_ay_data)
06F6: E63F    		and	0x3F
06F8: F640    		or	0x40
06FA: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
06FC: 3E0E    		ld	a,14		; AY register = 14	
06FE: D341    		out	(nabu_ay_latch),a
0700: DB40    		in	a,(nabu_ay_data)
0702: E6EF    		and	~0b00010000
0704: D340    		out	(nabu_ay_data),a
              		
0706: C9      		ret
              		
              	; Turns on the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
0707:         	irq_keyb_on:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
0707: 3E07    		ld	a,7		; AY register = 7
0709: D341    		out	(nabu_ay_latch),a
070B: DB40    		in	a,(nabu_ay_data)
070D: E63F    		and	0x3F
070F: F640    		or	0x40
0711: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask on interrupt
0713: 3E0E    		ld	a,14		; AY register = 14	
0715: D341    		out	(nabu_ay_latch),a
0717: DB40    		in	a,(nabu_ay_data)
0719: F620    		or	0b00100000
071B: D340    		out	(nabu_ay_data),a
              		
071D: C9      		ret
              		
              	; Turns off the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
071E:         	irq_keyb_off:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
071E: 3E07    		ld	a,7		; AY register = 7
0720: D341    		out	(nabu_ay_latch),a
0722: DB40    		in	a,(nabu_ay_data)
0724: E63F    		and	0x3F
0726: F640    		or	0x40
0728: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
072A: 3E0E    		ld	a,14		; AY register = 14	
072C: D341    		out	(nabu_ay_latch),a
072E: DB40    		in	a,(nabu_ay_data)
0730: E6DF    		and	~0b00100000
0732: D340    		out	(nabu_ay_data),a
              		
0734: C9      		ret
              		
              	; Turns on the HCCA output
              	;
              	; Returns nothing
              	; Uses: AF
0735:         	irq_hcca_o_on:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
0735: 3E07    		ld	a,7		; AY register = 7
0737: D341    		out	(nabu_ay_latch),a
0739: DB40    		in	a,(nabu_ay_data)
073B: E63F    		and	0x3F
073D: F640    		or	0x40
073F: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask on interrupt
0741: 3E0E    		ld	a,14		; AY register = 14	
0743: D341    		out	(nabu_ay_latch),a
0745: DB40    		in	a,(nabu_ay_data)
0747: F640    		or	0b01000000
0749: D340    		out	(nabu_ay_data),a
              		
074B: C9      		ret
              		
              	; Turns off the HCCA input
              	;
              	; Returns nothing
              	; Uses: AF
074C:         	irq_hcca_o_off:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
074C: 3E07    		ld	a,7		; AY register = 7
074E: D341    		out	(nabu_ay_latch),a
0750: DB40    		in	a,(nabu_ay_data)
0752: E63F    		and	0x3F
0754: F640    		or	0x40
0756: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
0758: 3E0E    		ld	a,14		; AY register = 14	
075A: D341    		out	(nabu_ay_latch),a
075C: DB40    		in	a,(nabu_ay_data)
075E: E6BF    		and	~0b01000000
0760: D340    		out	(nabu_ay_data),a
              		
0762: C9      		ret
              		
              	; Save the current interrupt state
              	;
              	; Returns nothing
              	; Uses: AF
0763:         	irq_save:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
0763: 3E07    		ld	a,7		; AY register = 7
0765: D341    		out	(nabu_ay_latch),a
0767: DB40    		in	a,(nabu_ay_data)
0769: E63F    		and	0x3F
076B: F640    		or	0x40
076D: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
076F: 3E0E    		ld	a,14		; AY register = 14	
0771: D341    		out	(nabu_ay_latch),a
0773: DB40    		in	a,(nabu_ay_data)
0775: 32DB0E  		ld	(irq_mask_state),a
0778: C9      		ret
              		
              	; Save the previous interrupt state
              	;
              	; Returns nothing
              	; Uses: AF
0779:         	irq_restore:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
0779: 3E07    		ld	a,7		; AY register = 7
077B: D341    		out	(nabu_ay_latch),a
077D: DB40    		in	a,(nabu_ay_data)
077F: E63F    		and	0x3F
0781: F640    		or	0x40
0783: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
0785: 3E0E    		ld	a,14		; AY register = 14	
0787: D341    		out	(nabu_ay_latch),a
0789: 3ADB0E  		ld	a,(irq_mask_state)
078C: D340    		out	(nabu_ay_data),a
078E: C9      		ret
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value of untrapped SP value
0EDB:         	irq_mask_state:
0EDB: 00      		defs	1
              	#include "DEBUG.asm"
              	;
              	;**************************************************************
              	;*
              	;*        V I R T U A L   M A C H I N E   D E B U G G E R
              	;*
              	;*    Proves a machine-language monitor for debugging the
              	;*    virtual machine. Does standard monitor stuff.
              	;* 
              	;**************************************************************
              	
              	; ---------------------------
              	; ********  Debugger ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Handle for the debugger
078F:         	debug_handle:
              	
              		; Save machine context
078F: ED73DF0E		ld	(debug_temp),sp
0793: 31F50E  		ld	sp,debug_state
              		
              		; Dump registers
0796: F5      		push	af
0797: C5      		push	bc
0798: D5      		push	de
0799: E5      		push	hl
079A: D9      		exx
079B: 08      		ex	af,af'
079C: F5      		push	af
079D: C5      		push	bc
079E: D5      		push	de
079F: E5      		push	hl
07A0: DDE5    		push	ix
07A2: FDE5    		push	iy
              		
07A4: ED7BDF0E		ld	sp,(debug_temp)
              		
              		; Save IRQ state
07A8: CD6307  		call	irq_save
              		
              		; Debugger stuff starts here
              		; Populate register dump string
07AB: 01F50E  		ld	bc,debug_state
07AE: 21750A  		ld	hl,str_rdump_af
07B1: CD4508  		call	debug_rtohex
07B4: 217E0A  		ld	hl,str_rdump_bc
07B7: CD4508  		call	debug_rtohex
07BA: 21870A  		ld	hl,str_rdump_de
07BD: CD4508  		call	debug_rtohex
07C0: 21900A  		ld	hl,str_rdump_hl
07C3: CD4508  		call	debug_rtohex
07C6: 219D0A  		ld	hl,str_rdump_aaf
07C9: CD4508  		call	debug_rtohex
07CC: 21A60A  		ld	hl,str_rdump_abc
07CF: CD4508  		call	debug_rtohex
07D2: 21AF0A  		ld	hl,str_rdump_ade
07D5: CD4508  		call	debug_rtohex
07D8: 21B80A  		ld	hl,str_rdump_ahl
07DB: CD4508  		call	debug_rtohex
07DE: 21C50A  		ld	hl,str_rdump_ix
07E1: CD4508  		call	debug_rtohex
07E4: 21CE0A  		ld	hl,str_rdump_iy
07E7: CD4508  		call	debug_rtohex
07EA: 01DB0E  		ld	bc,trap_sp_value+2
07ED: 214A0A  		ld	hl,str_rdump_sp
07F0: CD4508  		call	debug_rtohex
              		
              			
              		; Extract PC from capture area
07F3: 2AD90E  		ld	hl,(trap_sp_value)
07F6: 7C      		ld	a,h
07F7: E67F    		and	zmm_capt_res
07F9: F670    		or	zmm_capt_set
07FB: 67      		ld	h,a
07FC: 7E      		ld	a,(hl)
07FD: CDD008  		call	tohex
0800: ED53420A		ld	(str_rdump_pc+2),de
0804: 23      		inc	hl
0805: 7C      		ld	a,h
0806: E67F    		and	zmm_capt_res
0808: F670    		or	zmm_capt_set
080A: 67      		ld	h,a
080B: 7E      		ld	a,(hl)
080C: CDD008  		call	tohex
080F: ED53400A		ld	(str_rdump_pc),de
              		
              		; Print
0813: 113A0A  		ld	de,str_rdump
0816: CDA208  		call	cpm_print
              		
              		; Prompt the user for commands
0819:         	debug_prompt:
0819: 11D50A  		ld	de,str_prompt
081C: CDA208  		call	cpm_print
081F: 11D90A  		ld	de,input_buff
0822: CDB508  		call	cpm_input
              		
              		
              	; Go back to the virutal machine
0825:         	debug_continue:
              		
              		; Restore IRQ state
0825: CD7907  		call	irq_restore
0828: CD3507  		call	irq_hcca_o_on
              		
              		; Restore machine context
082B: ED73DF0E		ld	(debug_temp),sp
082F: 31E10E  		ld	sp,debug_state-20
              		
              		; Restore registers
0832: FDE1    		pop	iy
0834: DDE1    		pop	ix
0836: E1      		pop	hl
0837: D1      		pop	de
0838: C1      		pop	bc
0839: F1      		pop	af
083A: D9      		exx
083B: 08      		ex	af,af'
083C: E1      		pop	hl
083D: D1      		pop	de
083E: C1      		pop	bc
083F: F1      		pop	af
              		
              		; Go back to trap handler
0840: ED7BDF0E		ld	sp,(debug_temp)
0844: C9      		ret
              	
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Converts a register to hexadecimal
              	; BC = Address of register value
              	; HL = Address of hex string
              	;
              	; Returns BC=BC=2
              	; Uses: AF, BC, DE, HL
0845:         	debug_rtohex:
0845: 0B      		dec	bc
0846: 0A      		ld	a,(bc)
0847: C5      		push	bc
0848: CDD008  		call	tohex
084B: C1      		pop	bc
084C: 73      		ld	(hl),e
084D: 23      		inc	hl
084E: 72      		ld	(hl),d
084F: 23      		inc	hl
0850: 0B      		dec	bc
0851: 0A      		ld	a,(bc)
0852: C5      		push	bc
0853: CDD008  		call 	tohex
0856: C1      		pop	bc
0857: 73      		ld	(hl),e
0858: 23      		inc	hl
0859: 72      		ld	(hl),d
085A: C9      		ret
              	
              	; Bind the debugger to the trap handler
              	; Any trap can now be used to invoke the machine language monitor
              	;
              	; Returns nothing
              	; Uses: A, HL
085B:         	debug_bind:
              	
              		; Save previous binding
085B: 3AAD06  		ld	a,(trap_res_flag)
085E: 2AAE06  		ld	hl,(trap_res_flag+1)
0861: 32DC0E  		ld	(debug_pbind),a
0864: 22DD0E  		ld	(debug_pbind+1),hl
              		
              		; Bind debugger handle
0867: 3ECD    		ld	a,0xCD
0869: 218F07  		ld	hl,debug_handle
086C: 32AD06  		ld	(trap_res_flag),a
086F: 22AE06  		ld	(trap_res_flag+1),hl
              		
0872: C9      		ret
              		
              	; Unbind the debugger and allow traps to process normally
              	;
              	; Returns nothjing
              	; Uses: A, HL
0873:         	debug_unbind:
              		
              		; Restore previous binding
0873: 3ADC0E  		ld	a,(debug_pbind)
0876: 2ADD0E  		ld	hl,(debug_pbind+1)
0879: 32AD06  		ld	(trap_res_flag),a
087C: 22AE06  		ld	(trap_res_flag+1),hl
              		
087F: C9      		ret
              		
              		
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Register dump string
0A3A:         	str_rdump:
0A3A: 1E17    		defb	0x1E,0x17
0A3C: 50433A20		defb	'PC: '
0A40:         	str_rdump_pc:
0A40: 58585858		defb	'XXXX, SP: '
0A44: 2C205350	
0A48: 3A20    	
0A4A:         	str_rdump_sp:
0A4A: 58585858		defb	'XXXX',0x0A,0x0D
0A4E: 0A0D    	
0A50: 464C4147		defb	'FLAGS: '
0A54: 533A20  	
0A57:         	str_rdump_flag:
0A57: 2D2D2D2D		defb	'-------- EI: '
0A5B: 2D2D2D2D	
0A5F: 2045493A	
0A63: 20      	
0A64:         	str_rdump_ei:
0A64: 2D20492F		defb	'- I/O: '
0A68: 4F3A20  	
0A6B:         	str_rdump_io:
0A6B: 2D0A0D  		defb	'-',0x0A,0x0D
              		
0A6E: 523D2041		defb	'R= AF: '
0A72: 463A20  	
0A75:         	str_rdump_af:
0A75: 58585858		defb	'XXXX BC: '
0A79: 2042433A	
0A7D: 20      	
0A7E:         	str_rdump_bc:
0A7E: 58585858		defb	'XXXX DE: '
0A82: 2044453A	
0A86: 20      	
0A87:         	str_rdump_de:
0A87: 58585858		defb	'XXXX HL: '
0A8B: 20484C3A	
0A8F: 20      	
0A90:         	str_rdump_hl:
0A90: 58585858		defb	'XXXX',0x0A,0x0D
0A94: 0A0D    	
              		
0A96: 583D2041		defb	'X= AF: '
0A9A: 463A20  	
0A9D:         	str_rdump_aaf:
0A9D: 58585858		defb	'XXXX BC: '
0AA1: 2042433A	
0AA5: 20      	
0AA6:         	str_rdump_abc:
0AA6: 58585858		defb	'XXXX DE: '
0AAA: 2044453A	
0AAE: 20      	
0AAF:         	str_rdump_ade:
0AAF: 58585858		defb	'XXXX HL: '
0AB3: 20484C3A	
0AB7: 20      	
0AB8:         	str_rdump_ahl:
0AB8: 58585858		defb	'XXXX',0x0A,0x0D
0ABC: 0A0D    	
              		
0ABE: 453D2049		defb	'E= IX: '
0AC2: 583A20  	
0AC5:         	str_rdump_ix:
0AC5: 58585858		defb	'XXXX IY: '
0AC9: 2049593A	
0ACD: 20      	
0ACE:         	str_rdump_iy:
0ACE: 58585858		defb	'XXXX',0x0A,0x0D,'$'
0AD2: 0A0D24  	
              		
              	; Debug prompt
0AD5:         	str_prompt
0AD5: 0A0D2A24		defb	0x0A,0x0D,'*','$'
              		
              	; Input buffer
0AD9:         	input_buff:
0AD9: 28      		defb	40
0ADA: 00000000		defs	41
0ADE: 00...   	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Previous trap bind
0EDC:         	debug_pbind:
0EDC: 000000  		defs	3
              		
              	; General purpose memory register
              	; Usually used in context swaps
0EDF:         	debug_temp:
0EDF: 0000    		defs	2
              		
              	; Machine state
              	; IY	-20
              	; IX	-18
              	; 'HL	-16
              	; 'DE	-14
              	; 'BC	-12
              	; 'AF 	-10
              	; HL	-8
              	; DE	-6
              	; BC	-4
              	; AF	-2
              	; --- TOP ---
0EE1: 00000000		defs	20
0EE5: 00...   	
0EF5:         	debug_state:
              	
              	; --------------------------------
              	; ******** KRISYS Startup ********
              	; --------------------------------
              	
              	.area	_TEXT
              		
              		; KRISYS entry point
0880:         	kri_start:	
              		; Set up stack
0880: F3      		di
0881: 310070  		ld	sp,kri_stack
0884: 21C808  		ld	hl,cpm_exit
0887: E5      		push	hl
              		
              		; Print "hello" splash
0888: 0E09    		ld	c,bdos_print
088A: 11030B  		ld	de,str_splash
088D: CD0500  		call	bdos
              		
              		; Initalize subcomponents
0890: CDC506  		call	irq_init
0893: CDAC01  		call	zmm_init
0896: CDB906  		call	trap_init
0899: CD0301  		call	mem_map_init
089C: CDB802  		call	res_init
              		
              		
              		; Start the core
089F: C3E708  		jp	core_start
              		
              	; ------------------------------
              	; ******** CP/M Service ********
              	; ------------------------------
              		
              	; Print something to the CP/M console
              	; DE = Address of string to print
              	;
              	; Returns nothing
              	; Uses: All
08A2:         	cpm_print:
              		; Save control register state
08A2: 3A160E  		ld	a,(zmm_ctrl_state)
08A5: F5      		push	af
              		
              		; Go to real mode
08A6: CD1302  		call zmm_set_real
              		
              		; Do BDOS call
08A9: 0E09    		ld	c,bdos_print
08AB: CD0500  		call	bdos
              		
              		; Restore register
08AE: F1      		pop	af
08AF: 32160E  		ld	(zmm_ctrl_state),a
08B2: C30202  		jp	zmm_ctrl_set
              		
              	; Gets a line of input from the console
              	; DE = Address of result
              	;
              	; Returns nothing
              	; Uses: All
08B5:         	cpm_input:
              		; Save control register state
08B5: 3A160E  		ld	a,(zmm_ctrl_state)
08B8: F5      		push	af
              		
              		; Go to real mode
08B9: CD1302  		call zmm_set_real
              		
              		; Do BDOS call
08BC: 0E0A    		ld	c,bdos_input
08BE: CD0500  		call	bdos
              		
              		; Restore register
08C1: F1      		pop	af
08C2: 32160E  		ld	(zmm_ctrl_state),a
08C5: C30202  		jp	zmm_ctrl_set
              		
              	; Go back to CP/M
              	;
              	; Does not return
              	; Uses: N/A
08C8:         	cpm_exit:
08C8: CD1302  		call	zmm_set_real
08CB: 0E00    		ld	c,bdos_exit
08CD: CD0500  		call	bdos	
              		
              	; ----------------------
              	; ******** Misc ********
              	; ----------------------
              		
              	; Converts the value into an 8 bit hex number
              	; A = Number to convert
              	;
              	; Returns DE = result
              	; Uses: AF, DE
08D0: 57      	tohex:	ld	d,a
08D1: CDDB08  		call	0$
08D4: 5F      		ld	e,a
08D5: 7A      		ld	a,d
08D6: CDDF08  		call	1$
08D9: 57      		ld	d,a
08DA: C9      		ret
              		
08DB: 1F      	0$:	rra
08DC: 1F      		rra
08DD: 1F      		rra
08DE: 1F      		rra
08DF: F6F0    	1$:	or	0xF0
08E1: 27      		daa
08E2: C6A0    		add	a,0xA0
08E4: CE40    		adc	a,0x40
08E6: C9      		ret
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
0B03:         	str_splash:
0B03: 4944454E		defb	'IDENTITY KRISYS HYPERVISOR, CP/M EDT.',0x0A,0x0D
0B07: 54495459	
0B0B: 204B5249	
0B0F: 53595320	
0B13: 48595045	
0B17: 52564953	
0B1B: 4F522C20	
0B1F: 43502F4D	
0B23: 20454454	
0B27: 2E0A0D  	
0B2A: 5645522E		defb	'VER. 0.0.1, GAVIN TERSTEEG 2024'
0B2E: 20302E30	
0B32: 2E312C20	
0B36: 47415649	
0B3A: 4E205445	
0B3E: 52535445	
0B42: 45472032	
0B46: 303234  	
              		
              	; Carriage return, line break
0B49:         	str_crlf:
0B49: 0A0D24  		defb	0x0A,0x0D,'$' 
              		
              	
              	; ---------------------------
              	; ******** Core Init ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Start of SG-1000 core
08E7:         	core_start:
              	
              		; Try to find rom resource
08E7: 114C0B  		ld	de,str_rom
08EA: CD5A04  		call	res_locate
08ED: B7      		or	a
08EE: C24B03  		jp	nz,res_missing
              		
              		; Open the resource
08F1: CD6803  		call	res_open
              		
              		; Load resources into bankmap
08F4: 21F50E  		ld	hl,bm_rom
08F7: 010001  		ld	bc,256
08FA: CDC202  		call	res_load
              		
              		; Program the I/O map
08FD: 11500B  		ld	de,str_prgm
0900: CDA208  		call	cpm_print
              		
              		; Do input map
0903: CD0802  		call	zmm_set_virt
0906: CD1E02  		call	zmm_prgm_in
0909: 21950B  		ld	hl,io_map_input
090C: 110080  		ld	de,zmm_map
090F: 010001  		ld	bc,256
0912: EDB0    		ldir
              		
              		; Do output map
0914: CD2902  		call	zmm_prgm_out
0917: 21950C  		ld	hl,io_map_output
091A: 110080  		ld	de,zmm_map
091D: 010001  		ld	bc,256
0920: EDB0    		ldir
              		
              		; Allocate free ram
0922: 11690B  		ld	de,str_ram_alloc
0925: CDA208  		call	cpm_print
              		
              		; Lower RAM
0928: 1601    		ld	d,1
092A: CD6501  		call	mem_alloc
092D: CD6C02  		call	zmm_bnk2_set
              		
              		; Upper RAM
0930: 1601    		ld	d,1
0932: CD6501  		call	mem_alloc
0935: CD7202  		call	zmm_bnk3_set
              		
              		; TODO: remove me
0938: CD3507  		call 	irq_hcca_o_on
093B: CD3402  		call	zmm_irq_inter
              		
              		; Mount ROM
093E: 3AF50E  		ld	a,(bm_rom)
0941: CD6002  		call	zmm_bnk0_set
0944: CD7802  		call	zmm_bnk0_wp
0947: 3AF60E  		ld	a,(bm_rom+1)
094A: CD6602  		call	zmm_bnk1_set
094D: CD8802  		call	zmm_bnk1_wp
              		
              		; Enable VDP interrupt
0950: CDD906  		call	irq_vdp_on
              		
              		; Bind debugger
0953: CD5B08  		call	debug_bind
              		
              		; Start up VM
0956: 117A0B  		ld	de,str_vm_start
0959: CDA208  		call	cpm_print
              	
095C: CD0802  		call	zmm_set_virt
095F: 210000  		ld	hl,0x0000
0962: C3C901  		jp	zmm_vm_start
              		
              		
0965: 3A180E  		ld	a,(zmm_bnk1_state)
0968: D333    		out	(zmm_bnk3),a
096A: 3A00C0  		ld	a,(zmm_top+0)
096D: CD8509  		call	debug_point
0970: 3A01C0  		ld	a,(zmm_top+1)
0973: CD8509  		call	debug_point
0976: 3A02C0  		ld	a,(zmm_top+2)
0979: CD8509  		call	debug_point
097C: 3A03C0  		ld	a,(zmm_top+3)
097F: CD8509  		call	debug_point
              		
0982: C3C808  		jp	cpm_exit
              		
              		
              	; A = Value to print
0985:         	debug_point:
0985: CDD008  		call	tohex
0988: ED53900B		ld	(str_debug_val),de
098C: 118C0B  		ld	de,str_debug
098F: C3A208  		jp	cpm_print
              		
              		
              	; -----------------------------------
              	; ******** Interrupt Handler ********
              	; -----------------------------------
              		
              	.area	_TEXT
              		
              	; Handle "real" interrupts from devices (if needed)
              	; All registers except AF must remain unchanged!
0992:         	irq_handle:
0992: C9      		ret
              		
              		
              	; -----------------------------
              	; ******** I/O Handler ********
              	; -----------------------------
              		
              	.area	_TEXT
              	
              	; Handle an IN instruction
              	; Inputted value should be returned in register A
              	; All registers except AF must remain unchanged!
0993:         	in_handle:
0993: 3EFF    		ld	a,0xFF
0995: C9      		ret
              	
              	; Handle an OUT instruction
              	; A = Value outputted by virtual machine
              	; All registers except AF must remain unchanged!
0996:         	out_handle:
0996: C9      		ret
              		
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Resource strings
0B4C:         	str_rom:
0B4C: 524F4D00		defb	'ROM',0
              		
              	; Bootup strings
0B50:         	str_prgm:
0B50: 50524F47		defb	'PROGRAMMING VM I/O MAP',0x0A,0x0D,'$'
0B54: 52414D4D	
0B58: 494E4720	
0B5C: 564D2049	
0B60: 2F4F204D	
0B64: 41500A0D	
0B68: 24      	
              		
              	; Bootup strings
0B69:         	str_ram_alloc:
0B69: 414C4C4F		defb	'ALLOCATING RAM',0x0A,0x0D,'$'
0B6D: 43415449	
0B71: 4E472052	
0B75: 414D0A0D	
0B79: 24      	
              		
              	; Bootup strings
0B7A:         	str_vm_start:
0B7A: 53544152		defb	'STARTING VM NOW',0x0A,0x0D,'$'
0B7E: 54494E47	
0B82: 20564D20	
0B86: 4E4F570A	
0B8A: 0D24    	
              		
              	; Debug string
0B8C:         	str_debug:
0B8C: 41203D20		defb 	'A = '
0B90:         	str_debug_val:
0B90: 58580A0D		defb	'XX',0x0A,0x0D,'$'
0B94: 24      	
              	
              	
              	; ----------------------
              	; ******** Data ********
              	; ----------------------
              		
              	.area	_DATA
              	
0037:         	TRAP	equ	zmm_trap	; Trap Vector
00A0:         	_VDD	equ	nabu_vdp_data	; VDP Data
00A1:         	_VDA	equ	nabu_vdp_addr	; VDP Address
              	
              	; Virtual machine I/O maps
              	; Input map
0B95:         	io_map_input:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
0B95: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
0B99: 37...   	
0BA5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
0BA9: 37...   	
0BB5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
0BB9: 37...   	
0BC5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
0BC9: 37...   	
0BD5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
0BD9: 37...   	
0BE5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
0BE9: 37...   	
0BF5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
0BF9: 37...   	
0C05: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
0C09: 37...   	
0C15: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x8*
0C19: A0A1A0A1	
0C1D: A0A1A0A1	
0C21: A0A1A0A1	
0C25: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x9*
0C29: A0A1A0A1	
0C2D: A0A1A0A1	
0C31: A0A1A0A1	
0C35: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xA*
0C39: A0A1A0A1	
0C3D: A0A1A0A1	
0C41: A0A1A0A1	
0C45: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xB*
0C49: A0A1A0A1	
0C4D: A0A1A0A1	
0C51: A0A1A0A1	
0C55: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
0C59: 37...   	
0C65: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
0C69: 37...   	
0C75: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
0C79: 37...   	
0C85: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
0C89: 37...   	
              	
              	; Output map
0C95:         	io_map_output:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
0C95: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
0C99: 37...   	
0CA5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
0CA9: 37...   	
0CB5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
0CB9: 37...   	
0CC5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
0CC9: 37...   	
0CD5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
0CD9: 37...   	
0CE5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
0CE9: 37...   	
0CF5: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
0CF9: 37...   	
0D05: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
0D09: 37...   	
0D15: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x8*
0D19: A0A1A0A1	
0D1D: A0A1A0A1	
0D21: A0A1A0A1	
0D25: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x9*
0D29: A0A1A0A1	
0D2D: A0A1A0A1	
0D31: A0A1A0A1	
0D35: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xA*
0D39: A0A1A0A1	
0D3D: A0A1A0A1	
0D41: A0A1A0A1	
0D45: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xB*
0D49: A0A1A0A1	
0D4D: A0A1A0A1	
0D51: A0A1A0A1	
0D55: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
0D59: 37...   	
0D65: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
0D69: 37...   	
0D75: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
0D79: 37...   	
0D85: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
0D89: 37...   	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
0EF5:         	bm_rom:
0EF5: 0000    		defs	2


; +++ segments +++

#CODE _TEXT    = $0100 =   256,  size = $0897 =  2199
#CODE _DATA    = $0997 =  2455,  size = $03FE =  1022
#DATA _BSS     = $0D95 =  3477,  size = $0162 =   354

; +++ global symbols +++

TRAP             = $0037 =    55  _DATA   KSG1000.asm:182
_BSS             = $0D95 =  3477  _BSS    KRISYS.asm:28 (unused)
_BSS_end         = $0EF7 =  3831  _BSS    KRISYS.asm:28
_BSS_size        = $0162 =   354  _BSS    KRISYS.asm:28 (unused)
_DATA            = $0997 =  2455  _DATA   KRISYS.asm:27 (unused)
_DATA_end        = $0D95 =  3477  _DATA   KRISYS.asm:27
_DATA_size       = $03FE =  1022  _DATA   KRISYS.asm:27 (unused)
_TEXT            = $0100 =   256  _TEXT   KRISYS.asm:26 (unused)
_TEXT_end        = $0997 =  2455  _TEXT   KRISYS.asm:26
_TEXT_size       = $0897 =  2199  _TEXT   KRISYS.asm:26 (unused)
_VDA             = $00A1 =   161  _DATA   KSG1000.asm:184
_VDD             = $00A0 =   160  _DATA   KSG1000.asm:183
alloc_bank_map   = $0D96 =  3478  _BSS    MEMORY.asm:211
arg_size         = $0010 =    16  _BSS    RESOURCE.asm:17
banks_free       = $0D95 =  3477  _BSS    MEMORY.asm:205
bdos             = $0005 =     5  _TEXT   KRISYS.asm:49
bdos_con_in      = $0001 =     1  _TEXT   KRISYS.asm:51 (unused)
bdos_con_out     = $0002 =     2  _TEXT   KRISYS.asm:52
bdos_exit        = $0000 =     0  _TEXT   KRISYS.asm:50
bdos_input       = $000A =    10  _TEXT   KRISYS.asm:54
bdos_open        = $000F =    15  _TEXT   KRISYS.asm:55
bdos_print       = $0009 =     9  _TEXT   KRISYS.asm:53
bdos_read        = $0014 =    20  _TEXT   KRISYS.asm:56
bios_set_dma     = $001A =    26  _TEXT   KRISYS.asm:57
bm_rom           = $0EF5 =  3829  _BSS    KSG1000.asm:234
core_start       = $08E7 =  2279  _TEXT   KSG1000.asm:17
cpm_command      = $0080 =   128  _TEXT   KRISYS.asm:59
cpm_exit         = $08C8 =  2248  _TEXT   KRISYS.asm:188
cpm_input        = $08B5 =  2229  _TEXT   KRISYS.asm:167
cpm_print        = $08A2 =  2210  _TEXT   KRISYS.asm:145
debug_bind       = $085B =  2139  _TEXT   DEBUG.asm:168
debug_continue   = $0825 =  2085  _TEXT   DEBUG.asm:102 (unused)
debug_handle     = $078F =  1935  _TEXT   DEBUG.asm:18
debug_pbind      = $0EDC =  3804  _BSS    DEBUG.asm:264
debug_point      = $0985 =  2437  _TEXT   KSG1000.asm:108
debug_prompt     = $0819 =  2073  _TEXT   DEBUG.asm:94 (unused)
debug_rtohex     = $0845 =  2117  _TEXT   DEBUG.asm:143
debug_state      = $0EF5 =  3829  _BSS    DEBUG.asm:285
debug_temp       = $0EDF =  3807  _BSS    DEBUG.asm:269
debug_unbind     = $0873 =  2163  _TEXT   DEBUG.asm:188 (unused)
in_handle        = $0993 =  2451  _TEXT   KSG1000.asm:136
input_buff       = $0AD9 =  2777  _DATA   DEBUG.asm:253
io_map_input     = $0B95 =  2965  _DATA   KSG1000.asm:188
io_map_output    = $0C95 =  3221  _DATA   KSG1000.asm:208
irq_handle       = $0992 =  2450  _TEXT   KSG1000.asm:123
irq_hcca_o_off   = $074C =  1868  _TEXT   IRQ.asm:167 (unused)
irq_hcca_o_on    = $0735 =  1845  _TEXT   IRQ.asm:143
irq_init         = $06C5 =  1733  _TEXT   IRQ.asm:22
irq_keyb_off     = $071E =  1822  _TEXT   IRQ.asm:119 (unused)
irq_keyb_on      = $0707 =  1799  _TEXT   IRQ.asm:95 (unused)
irq_mask_state   = $0EDB =  3803  _BSS    IRQ.asm:238
irq_restore      = $0779 =  1913  _TEXT   IRQ.asm:213
irq_save         = $0763 =  1891  _TEXT   IRQ.asm:191
irq_vdp_off      = $06F0 =  1776  _TEXT   IRQ.asm:71 (unused)
irq_vdp_on       = $06D9 =  1753  _TEXT   IRQ.asm:47
kri_stack        = $7000 = 28672  _TEXT   KRISYS.asm:91
kri_start        = $0880 =  2176  _TEXT   KRISYS.asm:113
mem_alloc        = $0165 =   357  _TEXT   MEMORY.asm:103
mem_empty        = $01A3 =   419  _TEXT   MEMORY.asm:177
mem_free         = $0186 =   390  _TEXT   MEMORY.asm:135
mem_free_all     = $0198 =   408  _TEXT   MEMORY.asm:161 (unused)
mem_map_init     = $0103 =   259  _TEXT   MEMORY.asm:30
nabu_ay_data     = $0040 =    64  _TEXT   KRISYS.asm:85
nabu_ay_latch    = $0041 =    65  _TEXT   KRISYS.asm:86
nabu_nctl        = $0000 =     0  _TEXT   KRISYS.asm:84 (unused)
nabu_vdp_addr    = $00A1 =   161  _TEXT   KRISYS.asm:88
nabu_vdp_data    = $00A0 =   160  _TEXT   KRISYS.asm:87
nmi_address      = $0066 =   102  _TEXT   KRISYS.asm:80
nmi_vector       = $0067 =   103  _TEXT   KRISYS.asm:81
out_handle       = $0996 =  2454  _TEXT   KSG1000.asm:143
res_argument     = $0E1B =  3611  _BSS    RESOURCE.asm:480
res_bankmap      = $0EB1 =  3761  _BSS    RESOURCE.asm:500
res_buffer       = $0E2E =  3630  _BSS    RESOURCE.asm:488
res_current      = $0E2C =  3628  _BSS    RESOURCE.asm:484
res_do_read      = $0EB0 =  3760  _BSS    RESOURCE.asm:496
res_fcb          = $0EB5 =  3765  _BSS    RESOURCE.asm:508
res_fcb_cr       = $0ED5 =  3797  _BSS    RESOURCE.asm:518 (unused)
res_fcb_data     = $0EC5 =  3781  _BSS    RESOURCE.asm:517 (unused)
res_fcb_drive    = $0EB5 =  3765  _BSS    RESOURCE.asm:510
res_fcb_ex       = $0EC1 =  3777  _BSS    RESOURCE.asm:513 (unused)
res_fcb_name     = $0EB6 =  3766  _BSS    RESOURCE.asm:511
res_fcb_r0       = $0ED6 =  3798  _BSS    RESOURCE.asm:519 (unused)
res_fcb_r1       = $0ED7 =  3799  _BSS    RESOURCE.asm:520 (unused)
res_fcb_r2       = $0ED8 =  3800  _BSS    RESOURCE.asm:521 (unused)
res_fcb_rc       = $0EC4 =  3780  _BSS    RESOURCE.asm:516 (unused)
res_fcb_s1       = $0EC2 =  3778  _BSS    RESOURCE.asm:514 (unused)
res_fcb_s2       = $0EC3 =  3779  _BSS    RESOURCE.asm:515 (unused)
res_fcb_type     = $0EBE =  3774  _BSS    RESOURCE.asm:512
res_init         = $02B8 =   696  _TEXT   RESOURCE.asm:29
res_load         = $02C2 =   706  _TEXT   RESOURCE.asm:47
res_locate       = $045A =  1114  _TEXT   RESOURCE.asm:360
res_missing      = $034B =   843  _TEXT   RESOURCE.asm:153
res_open         = $0368 =   872  _TEXT   RESOURCE.asm:179
res_pointer      = $0EB3 =  3763  _BSS    RESOURCE.asm:504
res_printzt      = $044B =  1099  _TEXT   RESOURCE.asm:340
res_sectors      = $0EAE =  3758  _BSS    RESOURCE.asm:492
stack_size       = $0020 =    32          KRISYS.asm:31
str_arg_empty    = $09FA =  2554  _DATA   RESOURCE.asm:464
str_arg_fail     = $0A11 =  2577  _DATA   RESOURCE.asm:467
str_crlf         = $0B49 =  2889  _DATA   KRISYS.asm:232
str_debug        = $0B8C =  2956  _DATA   KSG1000.asm:170
str_debug_val    = $0B90 =  2960  _DATA   KSG1000.asm:172
str_load_a       = $09EA =  2538  _DATA   RESOURCE.asm:457
str_load_b       = $09F3 =  2547  _DATA   RESOURCE.asm:460
str_mem_empty    = $09C2 =  2498  _DATA   MEMORY.asm:195
str_mem_init     = $0997 =  2455  _DATA   MEMORY.asm:189
str_mem_init_cnt = $09BC =  2492  _DATA   MEMORY.asm:192
str_missing      = $0A27 =  2599  _DATA   RESOURCE.asm:470
str_prgm         = $0B50 =  2896  _DATA   KSG1000.asm:158
str_prompt       = $0AD5 =  2773  _DATA   DEBUG.asm:249
str_ram_alloc    = $0B69 =  2921  _DATA   KSG1000.asm:162
str_rdump        = $0A3A =  2618  _DATA   DEBUG.asm:207
str_rdump_aaf    = $0A9D =  2717  _DATA   DEBUG.asm:233
str_rdump_abc    = $0AA6 =  2726  _DATA   DEBUG.asm:235
str_rdump_ade    = $0AAF =  2735  _DATA   DEBUG.asm:237
str_rdump_af     = $0A75 =  2677  _DATA   DEBUG.asm:223
str_rdump_ahl    = $0AB8 =  2744  _DATA   DEBUG.asm:239
str_rdump_bc     = $0A7E =  2686  _DATA   DEBUG.asm:225
str_rdump_de     = $0A87 =  2695  _DATA   DEBUG.asm:227
str_rdump_ei     = $0A64 =  2660  _DATA   DEBUG.asm:217 (unused)
str_rdump_flag   = $0A57 =  2647  _DATA   DEBUG.asm:215 (unused)
str_rdump_hl     = $0A90 =  2704  _DATA   DEBUG.asm:229
str_rdump_io     = $0A6B =  2667  _DATA   DEBUG.asm:219 (unused)
str_rdump_ix     = $0AC5 =  2757  _DATA   DEBUG.asm:243
str_rdump_iy     = $0ACE =  2766  _DATA   DEBUG.asm:245
str_rdump_pc     = $0A40 =  2624  _DATA   DEBUG.asm:210
str_rdump_sp     = $0A4A =  2634  _DATA   DEBUG.asm:212
str_rom          = $0B4C =  2892  _DATA   KSG1000.asm:154
str_splash       = $0B03 =  2819  _DATA   KRISYS.asm:227
str_vm_start     = $0B7A =  2938  _DATA   KSG1000.asm:166
str_zmm_init     = $09D8 =  2520  _DATA   ZMM.asm:308
tohex            = $08D0 =  2256  _TEXT   KRISYS.asm:202
trap_a_value     = $6FFF = 28671  _TEXT   KRISYS.asm:92
trap_continue    = $06AC =  1708  _TEXT   TRAP.asm:476
trap_entry       = $04C3 =  1219  _TEXT   TRAP.asm:19
trap_f_value     = $6FFE = 28670  _TEXT   KRISYS.asm:93
trap_init        = $06B9 =  1721  _TEXT   TRAP.asm:508
trap_io          = $04D4 =  1236  _TEXT   TRAP.asm:39 (unused)
trap_io_ex_out   = $0566 =  1382  _TEXT   TRAP.asm:166
trap_io_ext      = $04F0 =  1264  _TEXT   TRAP.asm:59
trap_io_ind      = $05FD =  1533  _TEXT   TRAP.asm:305
trap_io_inx      = $05C0 =  1472  _TEXT   TRAP.asm:246
trap_io_outd     = $0673 =  1651  _TEXT   TRAP.asm:421
trap_io_outx     = $0636 =  1590  _TEXT   TRAP.asm:360
trap_res_flag    = $06AD =  1709  _TEXT   TRAP.asm:485
trap_restore     = $06AD =  1709  _TEXT   TRAP.asm:482
trap_sp_value    = $0ED9 =  3801  _BSS    TRAP.asm:526
zmm_addr_hi      = $0032 =    50  _TEXT   KRISYS.asm:68 (unused)
zmm_addr_lo      = $0033 =    51  _TEXT   KRISYS.asm:69 (unused)
zmm_bnk0         = $0030 =    48  _TEXT   KRISYS.asm:62
zmm_bnk0_set     = $0260 =   608  _TEXT   ZMM.asm:193
zmm_bnk0_state   = $0E17 =  3607  _BSS    ZMM.asm:322
zmm_bnk0_we      = $0280 =   640  _TEXT   ZMM.asm:242 (unused)
zmm_bnk0_wp      = $0278 =   632  _TEXT   ZMM.asm:233
zmm_bnk1         = $0031 =    49  _TEXT   KRISYS.asm:63
zmm_bnk1_set     = $0266 =   614  _TEXT   ZMM.asm:203
zmm_bnk1_state   = $0E18 =  3608  _BSS    ZMM.asm:326
zmm_bnk1_we      = $0290 =   656  _TEXT   ZMM.asm:260 (unused)
zmm_bnk1_wp      = $0288 =   648  _TEXT   ZMM.asm:251
zmm_bnk2         = $0032 =    50  _TEXT   KRISYS.asm:64
zmm_bnk2_set     = $026C =   620  _TEXT   ZMM.asm:213
zmm_bnk2_state   = $0E19 =  3609  _BSS    ZMM.asm:330
zmm_bnk2_we      = $02A0 =   672  _TEXT   ZMM.asm:278 (unused)
zmm_bnk2_wp      = $0298 =   664  _TEXT   ZMM.asm:269 (unused)
zmm_bnk3         = $0033 =    51  _TEXT   KRISYS.asm:65
zmm_bnk3_set     = $0272 =   626  _TEXT   ZMM.asm:223
zmm_bnk3_state   = $0E1A =  3610  _BSS    ZMM.asm:334
zmm_bnk3_we      = $02B0 =   688  _TEXT   ZMM.asm:296 (unused)
zmm_bnk3_wp      = $02A8 =   680  _TEXT   ZMM.asm:287 (unused)
zmm_capt_res     = $007F =   127  _TEXT   KRISYS.asm:77
zmm_capt_set     = $0070 =   112  _TEXT   KRISYS.asm:76
zmm_capture      = $7000 = 28672  _TEXT   KRISYS.asm:72
zmm_ctrl         = $0034 =    52  _TEXT   KRISYS.asm:66
zmm_ctrl_set     = $0202 =   514  _TEXT   ZMM.asm:95
zmm_ctrl_state   = $0E16 =  3606  _BSS    ZMM.asm:318
zmm_init         = $01AC =   428  _TEXT   ZMM.asm:22
zmm_irq_inter    = $0234 =   564  _TEXT   ZMM.asm:148
zmm_irq_normal   = $023F =   575  _TEXT   ZMM.asm:159 (unused)
zmm_irq_off      = $0255 =   597  _TEXT   ZMM.asm:181 (unused)
zmm_irq_on       = $024A =   586  _TEXT   ZMM.asm:170 (unused)
zmm_isr          = $0030 =    48  _TEXT   KRISYS.asm:67
zmm_map          = $8000 = 32768  _TEXT   KRISYS.asm:73
zmm_prgm_in      = $021E =   542  _TEXT   ZMM.asm:126
zmm_prgm_out     = $0229 =   553  _TEXT   ZMM.asm:137
zmm_set_real     = $0213 =   531  _TEXT   ZMM.asm:115
zmm_set_virt     = $0208 =   520  _TEXT   ZMM.asm:104
zmm_top          = $C000 = 49152  _TEXT   KRISYS.asm:74
zmm_trap         = $0037 =    55  _TEXT   KRISYS.asm:70
zmm_vm_start     = $01C9 =   457  _TEXT   ZMM.asm:44


total time: 0.0238 sec.
no errors
