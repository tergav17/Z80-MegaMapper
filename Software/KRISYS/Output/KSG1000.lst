              	; --------------------------------------
              	; zasm: assemble "KSG1000.asm"
              	; date: 2024-08-18 19:04:48
              	; --------------------------------------


              	;
              	;********************************************************************
              	;*
              	;*        K R I S Y S   S G 1 0 0 0   C O R E
              	;*
              	;********************************************************************
              	
              	#include "KRISYS.asm"
              	;
              	;********************************************************************
              	;*
              	;*              I D E N T I T Y   K R I S Y S
              	;*
              	;*      The [K]lunkly [R]emapper / [I]nterpreter [SYS]tem
              	;*
              	;*             Written by Gavin Tersteeg, 2024
              	;*              Copyleft, All Wrongs Reserved
              	;*
              	;*
              	;*   This piece of software allows different classic Z80 systems
              	;*   to run as "virtual machines" on top of existing hardware by
              	;*   use of a ZMM (Z80 MEGAMAPPER). It does this by remapping RAM
              	;*   and I/O address space ot match that of it's target system.
              	;*   Anything that can't be emulated by simple remapping is instead
              	;*   interpreted using I/O traps. 
              	;*
              	;*   This allows virtualized machines to run with an acceptable
              	;*   degree of speed and accuracy. While the ZMM is still quite
              	;*   limited in what sort of hardware can be efficiently virtualized,
              	;*   anything that avoids MMIO or graphics hardware that isn't a VDP
              	;*   generally can be made to work.
              	;* 
              	;********************************************************************
              		
              	; ----------------------------
              	; ******** ZASM Setup ********
              	; ----------------------------
              	
0020:         	stack_size = 0x20
              	
              	#target BIN
0100:         	#code	_TEXT,0x0100	; Setup to run as a CP/M executable
07EA:         	#code	_DATA,_TEXT_end
0B16:         	#data	_BSS,_DATA_end
              	
              	; Make sure w don't overrun available memory
              	#assert	_BSS_end < (zmm_capture-stack_size)
              	
              	.area	_TEXT
0100: C32507  		jp	kri_start
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
              	; CP/M Stuff
0005:         	bdos		equ	0x0005
0000:         	bdos_exit	equ	0x00
0001:         	bdos_con_in	equ	0x01
0002:         	bdos_con_out	equ	0x02
0009:         	bdos_print	equ	0x09
000F:         	bdos_open	equ	0x0F
0014:         	bdos_read	equ	0x14
001A:         	bios_set_dma	equ	0x1A
              	
0080:         	cpm_command	equ	0x0080
              	
              	; Z80 MEGAMAPPER Stuff
0030:         	zmm_bnk0	equ	0x30	; 16K Bank 0 (0x0000 - 0x3FFF)
0031:         	zmm_bnk1	equ	0x31	; 16K Bank 1 (0x4000 - 0x7FFF)
0032:         	zmm_bnk2	equ	0x32	; 16K Bank 2 (0x8000 - 0xBFFF)
0033:         	zmm_bnk3	equ	0x33	; 16K Bank 3 (0xC000 - 0xFFFF)
0034:         	zmm_ctrl	equ	0x34	; ZMM Control Register
0030:         	zmm_isr		equ	0x30	; ZMM Trapped Instruction Register
0032:         	zmm_addr_hi	equ	0x32	; ZMM Trap Address High
0033:         	zmm_addr_lo	equ	0x33	; ZMM Trap Address Low
0037:         	zmm_trap	equ	0x37 	; ZMM Trap Vector
              	
7000:         	zmm_capture	equ	0x7000
8000:         	zmm_map		equ	0x8000
C000:         	zmm_top		equ	0xC000
              	
0070:         	zmm_capt_set	equ	0b01110000
007F:         	zmm_capt_res	equ	0b01111111
              	
              	; General Z80 Stuff
0066:         	nmi_address	equ	0x0066
0067:         	nmi_vector	equ	nmi_address+1
              	
              	; NABU Specific Stuff
0000:         	nabu_nctl	equ	0x00	; NABU Control Register
0040:         	nabu_ay_data	equ	0x40	; AY-3-8910 Data Port
0041:         	nabu_ay_latch	equ	0x41	; AY-3-8910 Latch Port
00A0:         	nabu_vdp_data	equ	0xA0	; VDP Data Port
00A1:         	nabu_vdp_addr	equ	0xA1	; VDP Address Port
              	
              	; Stack / Trap Management
7000:         	kri_stack	equ	zmm_capture
6FFF:         	trap_a_value	equ	kri_stack-1
6FFE:         	trap_f_value	equ	kri_stack-2
              	
              	; -------------------------------------
              	; ******** Additional Includes ********
              	; -------------------------------------
              	
              	#include "MEMORY.asm"
              	;
              	;********************************************************************
              	;*
              	;*                    Z M M   M E M O R Y
              	;* 
              	;*    The ZMM can be configured to have different amounts
              	;*    of memory installed. Instead of dicking around with 
              	;*    on-board jumpers, KRISYS will simply check what banks
              	;*    are available on startup. Memory will be dynamically
              	;*    allocated as needed by the client process.
              	;*
              	;*    Memory can be assigned to specific owners in the code.
              	;*    Valid owner IDs range from 1 to 254. Owner 0 is reserved
              	;*    for unallocatable banks.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              		
              	; Initalize the memory map
              	; Each bank of the ZMM will be probed, and writable
              	; banks will be recorded on the allocated bank map
              	;
              	; Returns nothing
              	; Uses: AF, BC, DE, HL
0103:         	mem_map_init:
              		; Go to virtual mode
0103: CDF601  		call	zmm_set_virt
              		
              		; Reset free bank counter
0106: 3E00    		ld	a,0
0108: 32160B  		ld	(banks_free),a
              		
              		; Write tags to all banks
010B: 0600    		ld	b,0
010D: 78      	0$:	ld	a,b
010E: CD6002  		call	zmm_bnk3_set
0111: 3200C0  		ld	(zmm_top),a
0114: ED44    		neg
0116: 3201C0  		ld	(zmm_top+1),a
0119: 04      		inc	b
011A: F20D01  		jp	p,0$
              		
              		; Mark any banks that record correctly
011D: 0600    		ld	b,0
011F: 21170B  		ld	hl,alloc_bank_map
0122: AF      	1$:	xor	a
0123: 77      		ld	(hl),a
0124: 78      		ld	a,b
0125: CD6002  		call	zmm_bnk3_set
0128: 3A00C0  		ld	a,(zmm_top)
012B: B8      		cp	b
012C: C24401  		jp	nz,2$
012F: 3A01C0  		ld	a,(zmm_top+1)
0132: 4F      		ld	c,a
0133: 78      		ld	a,b
0134: ED44    		neg
0136: B9      		cp	c
0137: C24401  		jp	nz,2$
              	
              		; Mark it
013A: 3EFF    		ld	a,0xFF
013C: 77      		ld	(hl),a
013D: 3A160B  		ld	a,(banks_free)
0140: 3C      		inc	a
0141: 32160B  		ld	(banks_free),a
              		
              		; Next
0144: 23      	2$:	inc	hl
0145: 04      		inc	b
0146: F22201  		jp	p,1$
              		
              		; Disable virtual mode
0149: CD0102  		call	zmm_set_real
              		
              		; Print out result
014C: 3A160B  		ld	a,(banks_free)
014F: CD5F07  		call	tohex
0152: ED530F08		ld	(str_mem_init_cnt),de
0156: 11EA07  		ld	de,str_mem_init
0159: CD4707  		call	cpm_print
              		
              		; Do we actually have an acceptable amount of memory?
015C: 3A160B  		ld	a,(banks_free)
015F: 3D      		dec	a
0160: 3D      		dec	a
0161: FAA301  		jp	m,mem_empty
              		
              		; We do, return
0164: C9      		ret
              		
              	; Allocates a bank of memory
              	; Will produce an error if no banks are available,
              	; check (banks_free) to avoid
              	; D = Owner ID (1-254)
              	;
              	; Returns A = Bank #
              	; Uses: AF, BC, HL
0165:         	mem_alloc:
              		; Check and decrement free memory
0165: 3A160B  		ld	a,(banks_free)
0168: 3D      		dec	a
0169: 32160B  		ld	(banks_free),a
016C: FAA301  		jp	m,mem_empty
              		
              		; Look for the first free bank
016F: 21170B  		ld	hl,alloc_bank_map
0172: 018000  		ld	bc,0x0080
0175: 3EFF    		ld	a,0xFF
0177: EDB1    		cpir
              		
              		; Make sure we found something
0179: C2A301  		jp	nz,mem_empty
              		
              		; Save and exit
017C: 2B      		dec	hl
017D: 72      		ld	(hl),d
017E: 01170B  		ld	bc,alloc_bank_map
0181: B7      		or	a
0182: ED42    		sbc	hl,bc
0184: 6F      		ld	l,a
0185: C9      		ret
              		
              	; Frees a bank of memory
              	; Safe to use on banks that are not free / not owned
              	; A = Bank #
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
0186:         	mem_free:
              		; Find location in memory
0186: 0600    		ld	b,0
0188: 4F      		ld	c,a
0189: 21170B  		ld	hl,alloc_bank_map
018C: 09      		add	hl,bc
              		
              		; Check owner
018D: 7E      		ld	a,(hl)
018E: BA      		cp	d
018F: C0      		ret	nz
              		
              		; Free bank
0190: 3EFF    		ld	a,0xFF
0192: 77      		ld	(hl),a
              		
              		; Increment banks free
0193: 21160B  		ld	hl,banks_free
0196: 34      		inc	(hl)
0197: C9      		ret
              		
              	; Free all banks by owner
              	; D = Owner ID (1-254)
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
0198:         	mem_free_all:
              		; Free a bank
0198: AF      		xor	a
0199: F5      	0$:	push	af
019A: CD8601  		call	mem_free
019D: F1      		pop	af
              		
              		; Next bank
019E: 3C      		inc	a
019F: F29901  		jp	p,0$
01A2: C9      		ret
              		
              	; Error out if empty
              	;
              	; Does not return
              	; Uses: N/A
01A3:         	mem_empty:
01A3: 111508  		ld	de,str_mem_empty
01A6: CD4707  		call	cpm_print
01A9: C35A07  		jp	cpm_exit
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
07EA:         	str_mem_init:
07EA: 494E4954		defb	'INITIALIZED MEMORY MAP',0x0A,0x0D
07EE: 49414C49	
07F2: 5A454420	
07F6: 4D454D4F	
07FA: 5259204D	
07FE: 41500A0D	
0802: 42414E4B		defb	'BANK COUNT = '
0806: 20434F55	
080A: 4E54203D	
080E: 20      	
080F:         	str_mem_init_cnt:
080F: 5858480A		defb	'XXH',0x0A,0x0D,'$'
0813: 0D24    	
              		
0815:         	str_mem_empty:
0815: 494E5355		defb	'INSUFFICIENT MEMORY',0x0A,0x0D,'$'
0819: 46464943	
081D: 49454E54	
0821: 204D454D	
0825: 4F52590A	
0829: 0D24    	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Free bank count
0B16:         	banks_free:
0B16: 00      		defs	1
              	
              	; Allocated bank map
              	; This 128 byte table keeps track of every single 16K bank
              	; that exists on the ZMM. Populated on startup
0B17:         	alloc_bank_map:
0B17: 00000000		defs	128
0B1B: 00...   	
              	#include "ZMM.asm"
              	;
              	;********************************************************************
              	;*
              	;*                  Z M M   M A N A G E M E N T
              	;* 
              	;*    These routines are used to manage the state of the ZMM.
              	;*    This includes the setting of the registers as well as setting
              	;*    up trap and interrupt stuff.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize ZMM and reset registers
              	;
              	; Returns nothing
              	; Uses: AF
01AC:         	zmm_init:
              		; Zero out control register
01AC: 3E00    		ld	a,0
01AE: 32970B  		ld	(zmm_ctrl_state),a
01B1: 32980B  		ld	(zmm_bnk0_state),a
01B4: 32990B  		ld	(zmm_bnk1_state),a
01B7: 329A0B  		ld	(zmm_bnk2_state),a
01BA: 329B0B  		ld	(zmm_bnk3_state),a
              		
              		; See if we can swing in and out of virtual mode
01BD: CDF601  		call	zmm_set_virt
01C0: CD0102  		call	zmm_set_real
              		
              		; Tell the user that the ZMM is read
01C3: 112B08  		ld	de,str_zmm_init
01C6: C34707  		jp	cpm_print
              		
              	; Start execution of the virtual machine at a specific location
              	; HL = Address to start execution at
              	; 
              	; Does not return
              	; Uses: All registers zeroed
01C9:         	zmm_vm_start:
01C9: 31FEFF  		ld	sp,0xFFFF-1
01CC: 7C      		ld	a,h
01CD: 32FE7F  		ld	((zmm_capture + 0x1000) - 2),a
01D0: 7D      		ld	a,l
01D1: 32FF7F  		ld	((zmm_capture + 0x1000) - 1),a
              		
              		; Reset I/O trap flag just in case
01D4: D337    		out	(zmm_trap),a
              		
              		; Zero everything
01D6: AF      		xor	a
01D7: 47      		ld	b,a
01D8: 4F      		ld	c,a
01D9: 57      		ld 	d,a
01DA: 5F      		ld	e,a
01DB: 67      		ld	h,a
01DC: 6F      		ld	l,a
01DD: D9      		exx
01DE: 08      		ex	af,af'
01DF: AF      		xor	a
01E0: 47      		ld	b,a
01E1: 4F      		ld	c,a
01E2: 57      		ld 	d,a
01E3: 5F      		ld	e,a
01E4: 67      		ld	h,a
01E5: 6F      		ld	l,a
              		
01E6: DD210000		ld	ix,0
01EA: FD210000		ld	iy,0
              		
              		; Enter virtual machine
01EE: ED45    		retn
              		
              	; Set the ZMM control register to the recorded state
              	; (zmm_ctrl_state) = New value of ZMM control register
              	;
              	; Returns nothing
              	; Uses: AF
01F0:         	zmm_ctrl_set:
01F0: 3A970B  		ld	a,(zmm_ctrl_state)
01F3: D334    		out	(zmm_ctrl),a
01F5: C9      		ret
              		
              	; Go to virtual mode
              	;
              	; Returns nothing
              	; Uses: AF
01F6:         	zmm_set_virt:
01F6: 3A970B  		ld	a,(zmm_ctrl_state)
01F9: F601    		or	0b00000001
01FB: 32970B  		ld	(zmm_ctrl_state),a
01FE: D334    		out	(zmm_ctrl),a
0200: C9      		ret
              		
              	; Go to real mode
              	;
              	; Returns nothing
              	; Uses: AF
0201:         	zmm_set_real:
0201: 3A970B  		ld	a,(zmm_ctrl_state)
0204: E6FE    		and	0b11111110
0206: 32970B  		ld	(zmm_ctrl_state),a
0209: D334    		out	(zmm_ctrl),a
020B: C9      		ret
              		
              	; Set program direction to "IN"
              	;
              	; Returns nothing
              	; Uses: AF
020C:         	zmm_prgm_in:
020C: 3A970B  		ld	a,(zmm_ctrl_state)
020F: F602    		or	0b00000010
0211: 32970B  		ld	(zmm_ctrl_state),a
0214: D334    		out	(zmm_ctrl),a
0216: C9      		ret
              		
              	; Set program direction to "OUT"
              	;
              	; Returns nothing
              	; Uses: AF
0217:         	zmm_prgm_out:
0217: 3A970B  		ld	a,(zmm_ctrl_state)
021A: E6FD    		and	0b11111101
021C: 32970B  		ld	(zmm_ctrl_state),a
021F: D334    		out	(zmm_ctrl),a
0221: C9      		ret
              		
              	; Turn on irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
0222:         	zmm_irq_inter:
0222: 3A970B  		ld	a,(zmm_ctrl_state)
0225: F604    		or	0b00000100
0227: 32970B  		ld	(zmm_ctrl_state),a
022A: D334    		out	(zmm_ctrl),a
022C: C9      		ret
              		
              	; Turn off irq intercept mode
              	;
              	; Returns nothing
              	; Uses: AF
022D:         	zmm_irq_normal:
022D: 3A970B  		ld	a,(zmm_ctrl_state)
0230: E6FB    		and	0b11111011
0232: 32970B  		ld	(zmm_ctrl_state),a
0235: D334    		out	(zmm_ctrl),a
0237: C9      		ret
              	
              	; Turn on force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
0238:         	zmm_irq_on:
0238: 3A970B  		ld	a,(zmm_ctrl_state)
023B: F608    		or	0b00001000
023D: 32970B  		ld	(zmm_ctrl_state),a
0240: D334    		out	(zmm_ctrl),a
0242: C9      		ret
              		
              	; Turn off force virtual irq
              	;
              	; Returns nothing
              	; Uses: AF
0243:         	zmm_irq_off:
0243: 3A970B  		ld	a,(zmm_ctrl_state)
0246: E6F7    		and	0b11110111
0248: 32970B  		ld	(zmm_ctrl_state),a
024B: D334    		out	(zmm_ctrl),a
024D: C9      		ret
              		
              	; Set bank 0
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses: AF, B
024E:         	zmm_bnk0_set:
024E: 32980B  		ld	(zmm_bnk0_state),a
0251: D330    		out	(zmm_bnk0),a
0253: C9      		ret
              		
              	; Set bank 1
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
0254:         	zmm_bnk1_set:
0254: 32990B  		ld	(zmm_bnk1_state),a
0257: D331    		out	(zmm_bnk1),a
0259: C9      		ret
              		
              	; Set bank 2
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
025A:         	zmm_bnk2_set:
025A: 329A0B  		ld	(zmm_bnk2_state),a
025D: D332    		out	(zmm_bnk2),a
025F: C9      		ret
              		
              	; Set bank 3
              	; A = Bank to set
              	;
              	; Returns nothing
              	; Uses:  AF, B
0260:         	zmm_bnk3_set:
0260: 329B0B  		ld	(zmm_bnk3_state),a
0263: D333    		out	(zmm_bnk3),a
0265: C9      		ret
              		
              		
              	; Write protect bank 0
              	;
              	; Returns nothing
              	; Uses: AF
0266:         	zmm_bnk0_wp:
0266: 3A980B  		ld	a,(zmm_bnk0_state)
0269: F680    		or	0b10000000
026B: C34E02  		jp 	zmm_bnk0_set
              		
              	; Write enable bank 0
              	;
              	; Returns nothing
              	; Uses: AF
026E:         	zmm_bnk0_we:
026E: 3A980B  		ld	a,(zmm_bnk0_state)
0271: E67F    		and	~0b10000000
0273: C34E02  		jp 	zmm_bnk0_set
              		
              	; Write protect bank 1
              	;
              	; Returns nothing
              	; Uses: AF
0276:         	zmm_bnk1_wp:
0276: 3A990B  		ld	a,(zmm_bnk1_state)
0279: F680    		or	0b10000000
027B: C35402  		jp 	zmm_bnk1_set
              		
              	; Write enable bank 1
              	;
              	; Returns nothing
              	; Uses: AF
027E:         	zmm_bnk1_we:
027E: 3A990B  		ld	a,(zmm_bnk1_state)
0281: E67F    		and	~0b10000000
0283: C35402  		jp 	zmm_bnk1_set
              		
              	; Write protect bank 2
              	;
              	; Returns nothing
              	; Uses: AF
0286:         	zmm_bnk2_wp:
0286: 3A9A0B  		ld	a,(zmm_bnk2_state)
0289: F680    		or	0b10000000
028B: C35A02  		jp 	zmm_bnk2_set
              		
              	; Write enable bank 2
              	;
              	; Returns nothing
              	; Uses: AF
028E:         	zmm_bnk2_we:
028E: 3A9A0B  		ld	a,(zmm_bnk2_state)
0291: E67F    		and	~0b10000000
0293: C35A02  		jp 	zmm_bnk2_set
              		
              	; Write protect bank 3
              	;
              	; Returns nothing
              	; Uses: AF
0296:         	zmm_bnk3_wp:
0296: 3A9B0B  		ld	a,(zmm_bnk3_state)
0299: F680    		or	0b10000000
029B: C36002  		jp 	zmm_bnk3_set
              		
              	; Write enable bank 3
              	;
              	; Returns nothing
              	; Uses: AF
029E:         	zmm_bnk3_we:
029E: 3A9B0B  		ld	a,(zmm_bnk3_state)
02A1: E67F    		and	~0b10000000
02A3: C36002  		jp 	zmm_bnk3_set
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
082B:         	str_zmm_init:
082B: 494E4954		defb	'INITIALIZED ZMM',0x0A,0x0D,'$'
082F: 49414C49	
0833: 5A454420	
0837: 5A4D4D0A	
083B: 0D24    	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
0B97:         	zmm_ctrl_state:
0B97: 00      		defs	1
              		
              	; Bank 0 state
0B98:         	zmm_bnk0_state:
0B98: 00      		defs	1
              		
              	; Bank 1 state
0B99:         	zmm_bnk1_state:
0B99: 00      		defs	1
              		
              	; Bank 2 state
0B9A:         	zmm_bnk2_state:
0B9A: 00      		defs	1
              		
              	; Bank 3 state
0B9B:         	zmm_bnk3_state:
0B9B: 00      		defs	1
              		
              	#include "RESOURCE.asm"
              	;
              	;********************************************************************
              	;*
              	;*               R E S O U R C E   M A N A G E M E N T
              	;* 
              	;*    These routines handle obtaining use-supplied resources
              	;*    such as configurations, ROM images, and storage bindings.
              	;*    During startup, these resources will be loaded to build
              	;*    the virtual machine.
              	;*
              	;********************************************************************
              	
              	; -------------------------
              	; ******** Equates ********
              	; -------------------------
              	
0010:         	arg_size	equ 16
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize resources
              	;
              	; Returns nothing
              	; Uses: AF, BC, HL
02A6:         	res_init:
              		; Start by zero-terminating string
02A6: 218000  		ld	hl,cpm_command
02A9: 4E      		ld	c,(hl)
02AA: 0600    		ld	b,0
02AC: 09      		add	hl,bc
02AD: 23      		inc	hl
02AE: 70      		ld	(hl),b
              		
02AF: C9      		ret
              		
              	; Loads an open resource into a bankmap
              	; Bankmap will be zero-padded to fill requested number of records
              	; HL = Address of bankmap
              	; BC = Number of records (128 byte blocks) to load
              	;
              	; Returns nothing
              	; Uses: all
02B0:         	res_load:
              		; Set read flag
02B0: 3EFF    		ld	a,0xFF
02B2: 32310C  		ld	(res_do_read),a
              	
              		; Save args
02B5: 22320C  		ld	(res_bankmap),hl
02B8: ED432F0C		ld	(res_sectors),bc
              	
              		; Virtual mode should be off while we do this
02BC: 3A970B  		ld	a,(zmm_ctrl_state)
02BF: F5      		push	af
02C0: CD0102  		call	zmm_set_real
              		
              		; Do function call
02C3: CDD202  		call	0$
              		
              		; Reset bank 3
02C6: 3A9B0B  		ld	a,(zmm_bnk3_state)
02C9: D333    		out	(zmm_bnk3),a
              		
              		; Restore register
02CB: F1      		pop	af
02CC: 32970B  		ld	(zmm_ctrl_state),a
02CF: C3F001  		jp	zmm_ctrl_set
              		
              		; Allocate a new bank
02D2: 1601    	0$:	ld	d,1
02D4: CD6501  		call	mem_alloc
02D7: 2A320C  		ld	hl,(res_bankmap)
02DA: 77      		ld	(hl),a
02DB: 23      		inc	hl
02DC: 22320C  		ld	(res_bankmap),hl
              		
              		; Set the bank in slot 3
02DF: D333    		out	(zmm_bnk3),a
              		
              		; Set DMA address
02E1: 11AF0B  		ld	de,res_buffer
02E4: 0E1A    		ld	c,bios_set_dma
02E6: CD0500  		call	bdos
              		
              		; Set pointer	
02E9: 2100C0  		ld	hl,zmm_top
02EC: 22340C  		ld	(res_pointer),hl
              		
              		; We will be loading up to 128 records at a time here
02EF: 0680    		ld	b,128
              		
              		; Do read operation
02F1: C5      	1$:	push	bc
02F2: 11360C  		ld	de,res_fcb
02F5: 0E14    		ld	c,bdos_read
02F7: 3A310C  		ld	a,(res_do_read)
02FA: B7      		or	a
02FB: C40500  		call	nz,bdos
              		
              		; Check file I/O result
02FE: B7      		or	a
02FF: C42803  		call	nz,50$
              		
              		; Go to virtual mode
0302: CDF601  		call	zmm_set_virt
              		
              		; Copy record to bank
0305: 21AF0B  		ld	hl,res_buffer
0308: ED5B340C		ld	de,(res_pointer)
030C: 018000  		ld	bc,128
030F: EDB0    		ldir
0311: ED53340C		ld	(res_pointer),de
              		
              		; Back to real mode
0315: CD0102  		call	zmm_set_real 
              		
              		; Get BC back to restore sector counter
0318: C1      		pop	bc
              		
              		; Decrement record count
0319: 2A2F0C  		ld	hl,(res_sectors)
031C: 2B      		dec	hl
031D: 222F0C  		ld	(res_sectors),hl
0320: 7C      		ld	a,h
0321: B5      		or	l
0322: C8      		ret	z
              		
              		; Go get another sector
0323: 10CC    		djnz	1$
0325: C3D202  		jp	0$
              	
              		; Zero buffer and reset read flag
0328: AF      	50$:	xor	a
0329: 32310C  		ld	(res_do_read),a
              		
032C: 21AF0B  		ld	hl,res_buffer
032F: 11B00B  		ld	de,res_buffer+1
0332: 017F00  		ld	bc,128-1
0335: 77      		ld	(hl),a
0336: EDB0    		ldir
              	
0338: C9      		ret
              		
              	; Throws an error a missing resource
              	; Resource name will be last attempted to locate
              	;
              	; Does not return
              	; Uses: N/A
0339:         	res_missing:
0339: CD0102  		call	zmm_set_real
              		
              		; Print error message
033C: 0E09    		ld	c,bdos_print
033E: 117A08  		ld	de,str_missing
0341: CD0500  		call	bdos
              		
              		; Print resource name
0344: ED5BAD0B		ld	de,(res_current)
0348: CD3904  		call	res_printzt
              		
              		; CRLF
034B: 0E09    		ld	c,bdos_print
034D: 11D308  		ld	de,str_crlf
0350: CD0500  		call	bdos
              		
              		; Exit
0353: C35A07  		jp	cpm_exit
              		
              	; Opens a file based on the resource argument
              	; If the file cannot be opened, an error will be thrown
              	; (res_argument) = File to open
              	;
              	; Returns nothing
              	; Uses: all
0356:         	res_open:
              		; Virtual mode should be off while we do this
0356: 3A970B  		ld	a,(zmm_ctrl_state)
0359: F5      		push	af
035A: CD0102  		call	zmm_set_real
              		
              		; Do function call
035D: CD6703  		call	0$
              		
              		; Restore register
0360: F1      		pop	af
0361: 32970B  		ld	(zmm_ctrl_state),a
0364: C3F001  		jp	zmm_ctrl_set
              		
              		; Let the user know we are loading stuff
0367: 0E09    	0$:	ld	c,bdos_print
0369: 113D08  		ld	de,str_load_a
036C: CD0500  		call	bdos
              		
              		; Print resource name
036F: ED5BAD0B		ld	de,(res_current)
0373: CD3904  		call	res_printzt
              		
              		; Next string
0376: 0E09    		ld	c,bdos_print
0378: 114608  		ld	de,str_load_b
037B: CD0500  		call	bdos
              		
              		; Print file name
037E: 119C0B  		ld	de,res_argument
0381: CD3904  		call	res_printzt
              		
              		; CRLF
0384: 0E09    		ld	c,bdos_print
0386: 11D308  		ld	de,str_crlf
0389: CD0500  		call	bdos
              		
              		; Detect if there is an argument
038C: 3A9C0B  		ld	a,(res_argument)
038F: B7      		or	a
0390: C29E03  		jp	nz,1$
              		
              		; No argument, error!
0393: 0E09    		ld	c,bdos_print
0395: 114D08  		ld	de,str_arg_empty
0398: CD0500  		call	bdos
039B: C35A07  		jp	cpm_exit
              	
              		; Reset fields
039E: AF      	1$:	xor	a
039F: 21360C  		ld	hl,res_fcb
03A2: 11370C  		ld	de,res_fcb+1
03A5: 012300  		ld	bc ,36-1
03A8: 77      		ld	(hl),a
03A9: EDB0    		ldir
              		
03AB: 3E20    		ld	a,0x20
03AD: 21370C  		ld	hl,res_fcb_name
03B0: 11380C  		ld	de,res_fcb_name+1
03B3: 010A00  		ld	bc ,11-1
03B6: 77      		ld	(hl),a
03B7: EDB0    		ldir
              	
              		; Is there a prefix?
03B9: 219C0B  		ld	hl,res_argument
03BC: 3A9D0B  		ld	a,(res_argument+1)
03BF: FE3A    		cp	':'
03C1: C2D303  		jp	nz,2$
              		
              		; Set prefix
03C4: 3A9C0B  		ld	a,(res_argument)
03C7: D640    		sub	'A'-1
03C9: FE11    		cp	17
03CB: D22E04  		jp	nc,99$
03CE: 32360C  		ld	(res_fcb_drive),a
03D1: 23      		inc	hl
03D2: 23      		inc	hl
              	
              		; HL = Proper filename start
03D3: 0608    	2$:	ld	b,8
03D5: 11370C  		ld	de,res_fcb_name
              		
              		; Copy it over
03D8: 7E      	3$:	ld	a,(hl)
03D9: B7      		or	a
03DA: CA2E04  		jp	z,99$
03DD: FE2A    		cp	'*'
03DF: CAEF03  		jp	z,4$
03E2: FE2E    		cp	'.'
03E4: CAF603  		jp	z,5$
03E7: 12      		ld	(de),a
03E8: 13      		inc	de
03E9: 23      		inc	hl
03EA: 10EC    		djnz	3$
03EC: C3F603  		jp	5$
              	
              		; Fill remains of FCB file name
03EF: 3E3F    	4$:	ld	a,'?'
03F1: 12      		ld	(de),a
03F2: 13      		inc	de
03F3: 10FA    		djnz	4$
03F5: 23      		inc	hl
              	
              		; We should either see a '.' or a null character
03F6: 7E      	5$:	ld	a,(hl)
03F7: B7      		or	a
03F8: CA1F04  		jp	z,8$
03FB: FE2E    		cp	'.'
03FD: C22E04  		jp	nz,99$
0400: 23      		inc	hl
              		
              		; Fill in extension
0401: 0603    		ld	b,3
0403: 113F0C  		ld	de,res_fcb_type
              		
              		; Copy it over
0406: 7E      	6$:	ld	a,(hl)
0407: B7      		or	a
0408: CA1F04  		jp	z,8$
040B: FE2A    		cp	'*'
040D: CA1804  		jp	z,7$
0410: 12      		ld	(de),a
0411: 13      		inc	de
0412: 23      		inc	hl
0413: 10F1    		djnz	6$
0415: C31F04  		jp	8$
              		
              		; Fill remains of FCB file extension
0418: 3E3F    	7$:	ld	a,'?'
041A: 12      		ld	(de),a
041B: 13      		inc	de
041C: 10D1    		djnz	4$
041E: 23      		inc	hl
              	
              		; We should get a zero
041F: 7E      	8$:	ld 	a,(hl)
0420: B7      		or	a
0421: C22E04  		jp	nz,99$
              		
              		; It is filled in, attempt to open
0424: 0E0F    		ld	c,bdos_open
0426: 11360C  		ld	de,res_fcb
0429: CD0500  		call	bdos
              		
              		; Check error
042C: 3C      		inc	a
042D: C0      		ret	nz
              		
              		; Error!
042E: 0E09    	99$:	ld	c,bdos_print
0430: 116408  		ld	de,str_arg_fail
0433: CD0500  		call	bdos
0436: C35A07  		jp	cpm_exit
              		
              		
              	; Print a zero terminated string
              	; We should be in real mode for this
              	; DE = String
              	;
              	; Returns nothing
              	; Uses: All
0439:         	res_printzt:
0439: 1A      	0$:	ld	a,(de)
043A: B7      		or	a
043B: C8      		ret	z
              		
              		; Print character
043C: D5      		push	de
043D: 5F      		ld	e,a
043E: 0E02    		ld	c,bdos_con_out
0440: CD0500  		call	bdos
0443: D1      		pop	de
0444: 13      		inc	de
0445: C33904  		jp	0$
              	
              	; Find a resource from the command line
              	; If the resource is found, the contents will be cached in memory
              	; DE = Name of resource (upper case only) 
              	;
              	; Returns A = 0xFF if no resource is found
              	; Uses: AF, BC, DE, HL
0448:         	res_locate:
              		; Save resource
0448: ED53AD0B		ld	(res_current),de
              	
              		; Travel to the start of arguments
044C: 218100  		ld	hl,cpm_command+1
044F: 7E      	0$:	ld	a,(hl)
0450: B7      		or	a
0451: CAAE04  		jp	z,99$
0454: FE21    		cp	0x21
0456: D25D04  		jp	nc,1$
0459: 23      		inc	hl
045A: C34F04  		jp	0$
              		
              		; Found an argument
              		; Check it against the contents of (DE)
              		; Also must start with '-'
045D: FE2D    	1$:	cp	'-'
045F: C27004  		jp	nz,3$
0462: 23      		inc	hl
0463: D5      		push	de
0464: 1A      	2$:	ld	a,(de)
              		
              		; Check if at end of string
0465: B7      		or	a
0466: CA7E04  		jp	z,4$
              		
              		; No? Well lets see if (de) = (hl)
0469: BE      		cp	(hl)
046A: 23      		inc	hl
046B: 13      		inc	de
046C: CA6404  		jp	z,2$
              		
              		; Strings are different!
              		; Escape from the current argument and continue
046F: D1      		pop	de
0470: 7E      	3$:	ld	a,(hl)
0471: B7      		or	a
0472: CAAE04  		jp	z,99$
0475: FE21    		cp	0x21
0477: DA4F04  		jp	c,0$
047A: 23      		inc	hl
047B: C37004  		jp	3$
              	
              		; Make sure we are at the end of the argument as well
047E: D1      	4$: 	pop	de
047F: 7E      		ld	a,(hl)
0480: FE21    		cp	0x21
0482: D27004  		jp	nc,3$
              		
              		; Ok, lets copy the argument into memory if it exists
0485: 119C0B  		ld	de,res_argument
0488: AF      		xor	a
0489: 12      		ld	(de),a
              		
              		; Travel to the start of the argument
048A: 7E      	5$:	ld	a,(hl)
048B: B7      		or	a
048C: CAAC04  		jp	z,89$
048F: FE21    		cp	0x21
0491: D29804  		jp	nc,6$
0494: 23      		inc	hl
0495: C38A04  		jp	5$
              	
              		; Make sure it doesn't start with '-'
0498: FE2D    	6$:	cp	'-'
049A: CAAC04  		jp	z,89$
              		
              		; Ok, lets copy up 16 bytes of this
049D: 0610    		ld	b,arg_size
049F: 7E      	7$:	ld	a,(hl)
04A0: FE21    		cp	0x21
04A2: DAAA04  		jp	c,8$
04A5: 12      		ld	(de),a
04A6: 23      		inc	hl
04A7: 13      		inc	de
04A8: 10F5    		djnz	7$
              	
              		; Zero terminate
04AA: AF      	8$:	xor	a
04AB: 12      		ld	(de),a
              		
              		; Good ending
04AC: AF      	89$:	xor	a
04AD: C9      		ret
              	
              		; Bad ending
04AE: 3EFF    	99$:	ld	a,0xFF
04B0: C9      		ret
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Loading string components
083D:         	str_load_a:
083D: 4C4F4144		defb	'LOADING $'
0841: 494E4720	
0845: 24      	
              		
0846:         	str_load_b:
0846: 2046524F		defb	' FROM $'
084A: 4D2024  	
              		
              	; Error messages
084D:         	str_arg_empty:
084D: 4E4F2041		defb	'NO ARGUMENT PROVIDED',0x0A,0x0D,'$'
0851: 5247554D	
0855: 454E5420	
0859: 50524F56	
085D: 49444544	
0861: 0A0D24  	
              		
0864:         	str_arg_fail:
0864: 4641494C		defb	'FAILED TO OPEN FILE',0x0A,0x0D,'$'
0868: 45442054	
086C: 4F204F50	
0870: 454E2046	
0874: 494C450A	
0878: 0D24    	
              		
087A:         	str_missing:
087A: 4D495353		defb	'MISSING RESOURCE: $'
087E: 494E4720	
0882: 5245534F	
0886: 55524345	
088A: 3A2024  	
              		
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Stores a zero-terminated string for the resource argument
0B9C:         	res_argument:
0B9C: 00000000		defs	arg_size+1
0BA0: 00...   	
              		
              	; Current resource being accessed
0BAD:         	res_current:
0BAD: 0000    		defs	2
              		
              	; Resource buffer
0BAF:         	res_buffer:
0BAF: 00000000		defs	128
0BB3: 00...   	
              		
              	; Sector counter
0C2F:         	res_sectors:
0C2F: 0000    		defs	2
              		
              	; Do we need to read?
0C31:         	res_do_read:
0C31: 00      		defs	1
              		
              	; Resource bankmap
0C32:         	res_bankmap:
0C32: 0000    		defs	2
              		
              	; Loading pointer
0C34:         	res_pointer:
0C34: 0000    		defs	2
              		
              	; File control block for use in loading resources
0C36:         	res_fcb:
0C36: 00000000		defs	36
0C3A: 00...   	
0C36:         	res_fcb_drive	equ	res_fcb
0C37:         	res_fcb_name	equ	res_fcb+1
0C3F:         	res_fcb_type	equ	res_fcb+9
0C42:         	res_fcb_ex	equ	res_fcb+12
0C43:         	res_fcb_s1	equ	res_fcb+13
0C44:         	res_fcb_s2	equ	res_fcb+14
0C45:         	res_fcb_rc	equ	res_fcb+15
0C46:         	res_fcb_data	equ	res_fcb+16
0C56:         	res_fcb_cr	equ	res_fcb+32
0C57:         	res_fcb_r0	equ	res_fcb+33
0C58:         	res_fcb_r1	equ	res_fcb+34
0C59:         	res_fcb_r2	equ	res_fcb+35
              	#include "TRAP.asm"
              	;
              	;********************************************************************
              	;*
              	;*                     T R A P   H A N D L E R
              	;* 
              	;*    Responsible for handling various traps from the ZMM. Both
              	;*    interrupt and I/O traps will be pre-processed before being
              	;*    sent to the virtualization core for device-specific handling
              	;*
              	;********************************************************************
              	
              	; -------------------------------
              	; ********  Trap Handler ********
              	; -------------------------------
              	
              	.area	_TEXT
              	
              	; Entry point for traps
04B1:         	trap_entry:
              		; Save value of SP
04B1: ED735A0C		ld	(trap_sp_value),sp
04B5: 310070  		ld	sp,kri_stack
              		
              		; Save value of AF
04B8: F5      		push	af
              		
              		; Check in on device interrupts
04B9: CDE507  		call	irq_handle
              		
              		; Grab the value of the ISR register
04BC: DB30    		in	a,(zmm_isr)
              		
              		; Do we actually need to handle an I/O trap?
04BE: B7      		or	a
04BF: F2A206  		jp	p,trap_continue
              		
              		; Yep, reset trap flag
04C2: D337    		out	(zmm_trap),a
              		
              		; OK, a trap did occur.
              		; Are we doing "classic" I/O or extended I/O?
04C4:         	trap_io:	
04C4: FEE8    		cp	0b11101000
04C6: DAE004  		jp	c,trap_io_ext
              		
              		; In or out?
04C9: FEEC    		cp	0b11101100
04CB: DAD704  		jp	c,0$
              		
              		; In it is
04CE: CDE607  		call	in_handle
04D1: 32FF6F  		ld	(trap_a_value),a
04D4: C3A206  		jp	trap_continue
              		
              		; Out it is
04D7: 3AFF6F  	0$:	ld	a,(trap_a_value)
04DA: CDE907  		call	out_handle
04DD: C3A206  		jp	trap_continue
              	
              	
              	; It's an extended I/O instruction
04E0:         	trap_io_ext:
              		; Input or output?
04E0: 0F      		rrca
04E1: DA5C05  		jp	c,trap_io_ex_out
              		
              		; Extended input instruction
              		; INI-class?
04E4: 0F      		rrca
04E5: DAB605  		jp	c,trap_io_inx
              		
              		; Left or right column
04E8: 0F      		rrca
04E9: DA1305  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
04EC: 0F      		rrca
04ED: DA0205  		jp	c,1$
              		
              		; B or H?
04F0: 0F      		rrca
04F1: DAFB04  		jp	c,2$
              		
              		; It's B
04F4: CDE607  		call	in_handle
04F7: 47      		ld	b,a
04F8: C33D05  		jp	90$
              		
              		; It's H	
04FB: CDE607  	2$:	call	in_handle
04FE: 67      		ld	h,a
04FF: C33D05  		jp	90$
              	
              		; D or 0?
0502: 0F      	1$:	rrca
0503: DA0D05  		jp	c,3$
              	
              		; It's D
0506: CDE607  		call	in_handle
0509: 57      		ld	d,a
050A: C33D05  		jp	90$
              		
              		; It's 0
050D: CDE607  	3$:	call	in_handle
0510: C33D05  		jp	90$
              		
              		
              		; Right column
              		; C, E, L, or A?
0513: 0F      	0$:	rrca
0514: DA2905  		jp	c,4$
              		
              		; C or L?
0517: 0F      		rrca
0518: DA2205  		jp	c,5$
              		
              		; It's C
051B: CDE607  		call	in_handle
051E: 4F      		ld	c,a
051F: C33D05  		jp	90$
              	
              		; It's L
0522: CDE607  	5$:	call	in_handle
0525: 6F      		ld	l,a
0526: C33D05  		jp	90$
              		
              		; E or A?
0529: 0F      	4$:	rrca
052A: DA3405  		jp	c,6$
              		
              		; It's E
052D: CDE607  		call	in_handle
0530: 5F      		ld	e,a
0531: C33D05  		jp	90$
              	
              		; It's A
0534: CDE607  	6$:	call	in_handle
0537: 32FF6F  		ld	(trap_a_value),a
053A: C33D05  		jp	90$
              		
              		; Extended IN instructions require special flag states
              		; lets set them and return
053D: E5      	90$:	push	hl
053E: 21FE6F  		ld	hl,trap_f_value
0541: CB46    		bit	0,(hl)
0543: E1      		pop	hl
              		
              		; If it's zero, we don't need the carry flag
0544: CA5205  		jp	z,91$ 
              		
              		; Update flags and persist carry flag
0547: B7      		or	a
0548: 37      		scf
0549: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Restore old SP
054C: ED7B5A0C		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
0550: ED45    		retn
              		
              		; Update flags and reset carry flag
0552: B7      	91$:	or	a
0553: 3AFF6F  		ld	a,(trap_a_value)
              		
              		; Restore old SP
0556: ED7B5A0C		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
055A: ED45    		retn
              		
              	; Extended output instruction
055C:         	trap_io_ex_out:
              		; OUTI-class?
055C: 0F      		rrca
055D: DA2C06  		jp	c,trap_io_outx
              		
              		; Left or right column?
0560: 0F      		rrca
0561: DA8C05  		jp	c,0$
              		
              		; Left column
              		; B, D, H, or 0?
0564: 0F      		rrca
0565: DA7A05  		jp	c,1$
              		
              		; B or H?
0568: 0F      		rrca
0569: DA7305  		jp	c,2$
              		
              		; It's B
056C: 78      		ld	a,b
056D: CDE907  		call	out_handle
0570: C3A206  		jp	trap_continue
              		
              		; It's H	
0573: 7C      	2$:	ld	a,h
0574: CDE907  		call	out_handle
0577: C3A206  		jp	trap_continue
              	
              		; D or 0?
057A: 0F      	1$:	rrca
057B: DA8505  		jp	c,3$
              	
              		; It's D
057E: 7A      		ld	a,d
057F: CDE907  		call	out_handle
0582: C3A206  		jp	trap_continue
              		
              		; It's 0
0585: AF      	3$:	xor	a
0586: CDE907  		call	out_handle
0589: C3A206  		jp	trap_continue
              		
              		
              		; Right column
              		; C, E, L, or A?
058C: 0F      	0$:	rrca
058D: DAA205  		jp	c,4$
              		
              		; C or L?
0590: 0F      		rrca
0591: DA9B05  		jp	c,5$
              		
              		; It's C
0594: 79      		ld	a,c
0595: CDE907  		call	out_handle
0598: C3A206  		jp	trap_continue
              	
              		; It's L
059B: 7D      	5$:	ld	a,l
059C: CDE907  		call	out_handle
059F: C3A206  		jp	trap_continue
              		
              		; E or A?
05A2: 0F      	4$:	rrca
05A3: DAAD05  		jp	c,6$
              		
              		; It's E
05A6: 7B      		ld	a,e
05A7: CDE907  		call	out_handle
05AA: C3A206  		jp	trap_continue
              	
              		; It's A
05AD: 3AFF6F  	6$:	ld	a,(trap_a_value)
05B0: CDE907  		call	out_handle
05B3: C3A206  		jp	trap_continue
              	
              	
              		; INX class instructions
              		; The CPU should handle the differences between INX and INXR
05B6:         	trap_io_inx:
              		; Left or right column?
05B6: 0F      		rrca
05B7: DAF305  		jp	c,trap_io_ind
              		
              		; Left column, it's 'I' class
05BA: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
05BB: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
05BC: 7C      		ld	a,h
05BD: 07      		rlca
05BE: DAD105  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
05C1: 07      		rlca
05C2: DACB05  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
05C5: 3A980B  		ld	a,(zmm_bnk0_state)
05C8: C3DE05  		jp	3$
              		
              		; 0x4000 - 0x7FFF
05CB: 3A990B  	1$:	ld	a,(zmm_bnk1_state)
05CE: C3DE05  		jp	3$
              			
              		; 0x8000 - 0xFFFF
05D1: 07      	0$:	rlca
05D2: DADB05  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
05D5: 3A9A0B  		ld	a,(zmm_bnk2_state)
05D8: C3DE05  		jp	3$
              	
              		; 0xC000 - 0xFFFF
05DB: 3A9B0B  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
05DE: E67F    	3$:	and	0b01111111
05E0: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
05E2: 3EC0    		ld	a,0b11000000
05E4: B4      		or	h
05E5: 67      		ld	h,a
              		
              		; Do the input
05E6: CDE607  		call	in_handle
05E9: 77      		ld	(hl),a
              		
              		; Fix banks
05EA: 3A9B0B  		ld	a,(zmm_bnk3_state)
05ED: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
05EF: E1      		pop	hl
05F0: C3A206  		jp	trap_continue
              		
              		; Right column, it's 'D' class
05F3:         	trap_io_ind:
05F3: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
05F4: 23      		inc	hl	; Increment to reverse 'D' class instruction
05F5: 7C      		ld	a,h
05F6: 07      		rlca
05F7: DA0A06  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
05FA: 07      		rlca
05FB: DA0406  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
05FE: 3A980B  		ld	a,(zmm_bnk0_state)
0601: C31706  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0604: 3A990B  	1$:	ld	a,(zmm_bnk1_state)
0607: C31706  		jp	3$
              			
              		; 0x8000 - 0xFFFF
060A: 07      	0$:	rlca
060B: DA1406  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
060E: 3A9A0B  		ld	a,(zmm_bnk2_state)
0611: C31706  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0614: 3A9B0B  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0617: E67F    	3$:	and	0b01111111
0619: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
061B: 3EC0    		ld	a,0b11000000
061D: B4      		or	h
061E: 67      		ld	h,a
              		
              		; Do the input
061F: CDE607  		call	in_handle
0622: 77      		ld	(hl),a
              		
              		; Fix banks
0623: 3A9B0B  		ld	a,(zmm_bnk3_state)
0626: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0628: E1      		pop	hl
0629: C3A206  		jp	trap_continue
              	
              		; OUTX-class instructions
              		; The CPU should handle the differences between OUTX and OTXR
062C:         	trap_io_outx:
              		; Left or right column?
062C: 0F      		rrca
062D: DA6906  		jp	c,trap_io_outd
              		
              		; Left column, it's 'I' class
0630: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
0631: 2B      		dec	hl	; Decrement to reverse 'I' class instruction
0632: 7C      		ld	a,h
0633: 07      		rlca
0634: DA4706  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0637: 07      		rlca
0638: DA4106  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
063B: 3A980B  		ld	a,(zmm_bnk0_state)
063E: C35406  		jp	3$
              		
              		; 0x4000 - 0x7FFF
0641: 3A990B  	1$:	ld	a,(zmm_bnk1_state)
0644: C35406  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0647: 07      	0$:	rlca
0648: DA5106  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
064B: 3A9A0B  		ld	a,(zmm_bnk2_state)
064E: C35406  		jp	3$
              	
              		; 0xC000 - 0xFFFF
0651: 3A9B0B  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
0654: E67F    	3$:	and	0b01111111
0656: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0658: 3EC0    		ld	a,0b11000000
065A: B4      		or	h
065B: 67      		ld	h,a
              		
              		; Do the output
065C: 7E      		ld	a,(hl)
065D: CDE907  		call	out_handle
              		
              		; Fix banks
0660: 3A9B0B  		ld	a,(zmm_bnk3_state)
0663: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
0665: E1      		pop	hl
0666: C3A206  		jp	trap_continue
              		
              		; Right column, it's 'D' class
0669:         	trap_io_outd:
0669: E5      		push	hl
              		
              		; Attempt to figure out the original virtual address
066A: 23      		inc	hl	; Increment to reverse 'D' class instruction
066B: 7C      		ld	a,h
066C: 07      		rlca
066D: DA8006  		jp	c,0$
              		
              		; 0x0000 - 0x7FFF
0670: 07      		rlca
0671: DA7A06  		jp	c,1$
              		
              		; 0x0000 - 0x3FFF
0674: 3A980B  		ld	a,(zmm_bnk0_state)
0677: C38D06  		jp	3$
              		
              		; 0x4000 - 0x7FFF
067A: 3A990B  	1$:	ld	a,(zmm_bnk1_state)
067D: C38D06  		jp	3$
              			
              		; 0x8000 - 0xFFFF
0680: 07      	0$:	rlca
0681: DA8A06  		jp	c,2$
              		
              		; 0x8000 - 0xBFFF
0684: 3A9A0B  		ld	a,(zmm_bnk2_state)
0687: C38D06  		jp	3$
              	
              		; 0xC000 - 0xFFFF
068A: 3A9B0B  	2$:	ld	a,(zmm_bnk3_state)
              	
              		; Remove write protection and set
068D: E67F    	3$:	and	0b01111111
068F: D333    		out	(zmm_bnk3),a
              		
              		; Correct HL
0691: 3EC0    		ld	a,0b11000000
0693: B4      		or	h
0694: 67      		ld	h,a
              		
              		; Do the output
0695: 7E      		ld	a,(hl)
0696: CDE907  		call	out_handle
              		
              		; Fix banks
0699: 3A9B0B  		ld	a,(zmm_bnk3_state)
069C: D333    		out	(zmm_bnk3),a
              		
              		; Restore and continue
069E: E1      		pop	hl
069F: C3A206  		jp	trap_continue
              	
              		
              	; Continue execution
06A2:         	trap_continue:
              		; Restore AF
06A2: F1      		pop	af
              		
              		; Restore old SP
06A3: ED7B5A0C		ld	sp,(trap_sp_value)
              		
              		; Go back to the virtual machine
06A7: ED45    		retn
              		
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize trap handling stuff
              	;
              	; Returns nothing
              	; Uses: AF, HL
06A9:         	trap_init:
              		; Install trap vector
06A9: 3EC3    		ld	a,0xC3
06AB: 326600  		ld	(nmi_address),a
06AE: 21B104  		ld	hl,trap_entry
06B1: 226700  		ld	(nmi_vector),hl
              		
06B4: C9      		ret
              		
              		
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Value of untrapped SP value
0C5A:         	trap_sp_value:
0C5A: 0000    		defs	2
              	#include "IRQ.asm"
              	;
              	;********************************************************************
              	;*
              	;*             I N T E R R U P T   M A N A G E M E N T
              	;* 
              	;*    Manages "real" system interrupts on the host hardware.
              	;*    Also deals with mocking interrupts to the virtual machine
              	;*    if it is needed.
              	;*
              	;********************************************************************
              	
              	; ----------------------------
              	; ********  Functions ********
              	; ----------------------------
              	
              	.area	_TEXT
              	
              	; Initalize interrupt stuff
              	;
              	; Returns nothing
              	; Uses: AF
06B5:         	irq_init:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06B5: 3E07    		ld	a,7		; AY register = 7
06B7: D341    		out	(nabu_ay_latch),a
06B9: DB40    		in	a,(nabu_ay_data)
06BB: E63F    		and	0x3F
06BD: F640    		or	0x40
06BF: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off all interrupts
06C1: 3E0E    		ld	a,14		; AY register = 14	
06C3: D341    		out	(nabu_ay_latch),a
06C5: AF      		xor	a
06C6: D340    		out	(nabu_ay_data),a
              		
              		; Return
06C8: C9      		ret
              		
              		
              	; Turns on the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
06C9:         	irq_vdp_on:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06C9: 3E07    		ld	a,7		; AY register = 7
06CB: D341    		out	(nabu_ay_latch),a
06CD: DB40    		in	a,(nabu_ay_data)
06CF: E63F    		and	0x3F
06D1: F640    		or	0x40
06D3: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask on interrupt
06D5: 3E0E    		ld	a,14		; AY register = 14	
06D7: D341    		out	(nabu_ay_latch),a
06D9: DB40    		in	a,(nabu_ay_data)
06DB: F610    		or	0b00010000
06DD: D340    		out	(nabu_ay_data),a
              		
06DF: C9      		ret
              		
              	; Turns off the VDP interrupt
              	;
              	; Returns nothing
              	; Uses: AF
06E0:         	irq_vdp_off:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06E0: 3E07    		ld	a,7		; AY register = 7
06E2: D341    		out	(nabu_ay_latch),a
06E4: DB40    		in	a,(nabu_ay_data)
06E6: E63F    		and	0x3F
06E8: F640    		or	0x40
06EA: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
06EC: 3E0E    		ld	a,14		; AY register = 14	
06EE: D341    		out	(nabu_ay_latch),a
06F0: DB40    		in	a,(nabu_ay_data)
06F2: E6EF    		and	~0b00010000
06F4: D340    		out	(nabu_ay_data),a
              		
06F6: C9      		ret
              		
              	; Turns on the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
06F7:         	irq_keyb_on:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
06F7: 3E07    		ld	a,7		; AY register = 7
06F9: D341    		out	(nabu_ay_latch),a
06FB: DB40    		in	a,(nabu_ay_data)
06FD: E63F    		and	0x3F
06FF: F640    		or	0x40
0701: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask on interrupt
0703: 3E0E    		ld	a,14		; AY register = 14	
0705: D341    		out	(nabu_ay_latch),a
0707: DB40    		in	a,(nabu_ay_data)
0709: F620    		or	0b00100000
070B: D340    		out	(nabu_ay_data),a
              		
070D: C9      		ret
              		
              	; Turns off the keyboard interrupt
              	;
              	; Returns nothing
              	; Uses: AF
070E:         	irq_keyb_off:
              		; Set up the AY-3-8910 I/O
              		; Make sure to only change the two most significant bits
070E: 3E07    		ld	a,7		; AY register = 7
0710: D341    		out	(nabu_ay_latch),a
0712: DB40    		in	a,(nabu_ay_data)
0714: E63F    		and	0x3F
0716: F640    		or	0x40
0718: D340    		out	(nabu_ay_data),a
              	
              	
              		; Mask off interrupt
071A: 3E0E    		ld	a,14		; AY register = 14	
071C: D341    		out	(nabu_ay_latch),a
071E: DB40    		in	a,(nabu_ay_data)
0720: E6DF    		and	~0b00100000
0722: D340    		out	(nabu_ay_data),a
              		
0724: C9      		ret
              	
              	; --------------------------------
              	; ******** KRISYS Startup ********
              	; --------------------------------
              	
              	.area	_TEXT
              		
              		; KRISYS entry point
0725:         	kri_start:	
              		; Set up stack
0725: F3      		di
0726: 310070  		ld	sp,kri_stack
0729: 215A07  		ld	hl,cpm_exit
072C: E5      		push	hl
              		
              		; Print "hello" splash
072D: 0E09    		ld	c,bdos_print
072F: 118D08  		ld	de,str_splash
0732: CD0500  		call	bdos
              		
              		; Initalize subcomponents
0735: CDB506  		call	irq_init
0738: CDAC01  		call	zmm_init
073B: CDA906  		call	trap_init
073E: CD0301  		call	mem_map_init
0741: CDA602  		call	res_init
              		
              		
              		; Start the core
0744: C37607  		jp	core_start
              		
              	; ------------------------------
              	; ******** CP/M Service ********
              	; ------------------------------
              		
              	; Print something to the CP/M console
              	; DE = Address of string to print
              	;
              	; Returns nothing
              	; Uses: All
0747:         	cpm_print:
              		; Save control register state
0747: 3A970B  		ld	a,(zmm_ctrl_state)
074A: F5      		push	af
              		
              		; Go to real mode
074B: CD0102  		call zmm_set_real
              		
              		; Do BDOS call
074E: 0E09    		ld	c,bdos_print
0750: CD0500  		call	bdos
              		
              		; Restore register
0753: F1      		pop	af
0754: 32970B  		ld	(zmm_ctrl_state),a
0757: C3F001  		jp	zmm_ctrl_set
              		
              	; Go back to CP/M
              	;
              	; Does not return
              	; Uses: N/A
075A:         	cpm_exit:
075A: 0E00    		ld	c,bdos_exit
075C: CD0500  		call	bdos	
              		
              	; ----------------------
              	; ******** Misc ********
              	; ----------------------
              		
              	; Converts the value into an 8 bit hex number
              	; A = Number to convert
              	;
              	; Returns DE = result
              	; Uses: AF, DE
075F: 57      	tohex:	ld	d,a
0760: CD6A07  		call	0$
0763: 5F      		ld	e,a
0764: 7A      		ld	a,d
0765: CD6E07  		call	1$
0768: 57      		ld	d,a
0769: C9      		ret
              		
076A: 1F      	0$:	rra
076B: 1F      		rra
076C: 1F      		rra
076D: 1F      		rra
076E: F6F0    	1$:	or	0xF0
0770: 27      		daa
0771: C6A0    		add	a,0xA0
0773: CE40    		adc	a,0x40
0775: C9      		ret
              	
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Inital string that prints when the program is started
088D:         	str_splash:
088D: 4944454E		defb	'IDENTITY KRISYS HYPERVISOR, CP/M EDT.',0x0A,0x0D
0891: 54495459	
0895: 204B5249	
0899: 53595320	
089D: 48595045	
08A1: 52564953	
08A5: 4F522C20	
08A9: 43502F4D	
08AD: 20454454	
08B1: 2E0A0D  	
08B4: 5645522E		defb	'VER. 0.0.1, GAVIN TERSTEEG 2024'
08B8: 20302E30	
08BC: 2E312C20	
08C0: 47415649	
08C4: 4E205445	
08C8: 52535445	
08CC: 45472032	
08D0: 303234  	
              		
              	; Carriage return, line break
08D3:         	str_crlf:
08D3: 0A0D24  		defb	0x0A,0x0D,'$' 
              		
              	
              	; ---------------------------
              	; ******** Core Init ********
              	; ---------------------------
              	
              	.area	_TEXT
              	
              	; Start of SG-1000 core
0776:         	core_start:
              	
              		; Try to find rom resource
0776: 11D608  		ld	de,str_rom
0779: CD4804  		call	res_locate
077C: B7      		or	a
077D: C23903  		jp	nz,res_missing
              		
              		; Open the resource
0780: CD5603  		call	res_open
              		
              		; Load resources into bankmap
0783: 215C0C  		ld	hl,bm_rom
0786: 010001  		ld	bc,256
0789: CDB002  		call	res_load
              		
              		; Program the I/O map
078C: 11DA08  		ld	de,str_prgm
078F: CD4707  		call	cpm_print
              		
              		; Do input map
0792: CDF601  		call	zmm_set_virt
0795: CD0C02  		call	zmm_prgm_in
0798: 211609  		ld	hl,io_map_input
079B: 110080  		ld	de,zmm_map
079E: 010001  		ld	bc,256
07A1: EDB0    		ldir
              		
              		; Do output map
07A3: CD1702  		call	zmm_prgm_out
07A6: 211609  		ld	hl,io_map_input
07A9: 110080  		ld	de,zmm_map
07AC: 010001  		ld	bc,256
07AF: EDB0    		ldir
              		
              		; Allocate free ram
07B1: 11F308  		ld	de,str_ram_alloc
07B4: CD4707  		call	cpm_print
              		
              		; Lower RAM
07B7: 1601    		ld	d,1
07B9: CD6501  		call	mem_alloc
07BC: CD5A02  		call	zmm_bnk2_set
              		
              		; Upper RAM
07BF: 1601    		ld	d,1
07C1: CD6501  		call	mem_alloc
07C4: CD6002  		call	zmm_bnk3_set
              		
              		; Mount ROM
07C7: 3A5C0C  		ld	a,(bm_rom)
07CA: CD4E02  		call	zmm_bnk0_set
07CD: CD6602  		call	zmm_bnk0_wp
07D0: 3A5D0C  		ld	a,(bm_rom+1)
07D3: CD5402  		call	zmm_bnk1_set
07D6: CD7602  		call	zmm_bnk1_wp
              		
              		; Start up VM
07D9: 110409  		ld	de,str_vm_start
07DC: CD4707  		call	cpm_print
              	
07DF: 210000  		ld	hl,0
07E2: CDC901  		call	zmm_vm_start
              		
              		
              	; -----------------------------------
              	; ******** Interrupt Handler ********
              	; -----------------------------------
              		
              	.area	_TEXT
              		
              	; Handle "real" interrupts from devices (if needed)
              	; All registers except AF must remain unchanged!
07E5:         	irq_handle:
07E5: C9      		ret
              		
              		
              	; -----------------------------
              	; ******** I/O Handler ********
              	; -----------------------------
              		
              	.area	_TEXT
              	
              	; Handle an IN instruction
              	; Inputted value should be returned in register A
              	; All registers except AF must remain unchanged!
07E6:         	in_handle:
07E6: 3EFF    		ld	a,0xFF
07E8: C9      		ret
              	
              	; Handle an OUT instruction
              	; A = Value outputted by virtual machine
              	; All registers except AF must remain unchanged!
07E9:         	out_handle:
07E9: C9      		ret
              		
              		
              	; -------------------------
              	; ******** Strings ********
              	; -------------------------
              	
              	.area	_DATA
              	
              	; Resource strings
08D6:         	str_rom:
08D6: 524F4D00		defb	'ROM',0
              		
              	; Bootup strings
08DA:         	str_prgm:
08DA: 50524F47		defb	'PROGRAMMING VM I/O MAP',0x0A,0x0D,'$'
08DE: 52414D4D	
08E2: 494E4720	
08E6: 564D2049	
08EA: 2F4F204D	
08EE: 41500A0D	
08F2: 24      	
              		
              	; Bootup strings
08F3:         	str_ram_alloc:
08F3: 414C4C4F		defb	'ALLOCATING RAM',0x0A,0x0D,'$'
08F7: 43415449	
08FB: 4E472052	
08FF: 414D0A0D	
0903: 24      	
              		
              	; Bootup strings
0904:         	str_vm_start:
0904: 53544152		defb	'STARTING VM NOW',0x0A,0x0D,'$'
0908: 54494E47	
090C: 20564D20	
0910: 4E4F570A	
0914: 0D24    	
              	
              	
              	; ----------------------
              	; ******** Data ********
              	; ----------------------
              		
              	.area	_DATA
              	
0037:         	TRAP	equ	zmm_trap	; Trap Vector
00A0:         	_VDD	equ	nabu_vdp_data	; VDP Data
00A1:         	_VDA	equ	nabu_vdp_addr	; VDP Address
              	
              	; Virtual machine I/O maps
              	; Input map
0916:         	io_map_input:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
0916: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
091A: 37...   	
0926: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
092A: 37...   	
0936: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
093A: 37...   	
0946: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
094A: 37...   	
0956: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
095A: 37...   	
0966: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
096A: 37...   	
0976: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
097A: 37...   	
0986: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
098A: 37...   	
0996: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x8*
099A: A0A1A0A1	
099E: A0A1A0A1	
09A2: A0A1A0A1	
09A6: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x9*
09AA: A0A1A0A1	
09AE: A0A1A0A1	
09B2: A0A1A0A1	
09B6: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xA*
09BA: A0A1A0A1	
09BE: A0A1A0A1	
09C2: A0A1A0A1	
09C6: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xB*
09CA: A0A1A0A1	
09CE: A0A1A0A1	
09D2: A0A1A0A1	
09D6: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
09DA: 37...   	
09E6: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
09EA: 37...   	
09F6: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
09FA: 37...   	
0A06: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
0A0A: 37...   	
              	
              	; Output map
0A16:         	io_map_output:
              		;	0x*0 0x*1 0x*2 0x*3 0x*4 0x*5 0x*6 0x*7 0x*8 0x*9 0x*A 0x*B 0x*C 0x*D 0x*E 0x*F 
0A16: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x0*
0A1A: 37...   	
0A26: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x1*
0A2A: 37...   	
0A36: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x2*
0A3A: 37...   	
0A46: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x3*
0A4A: 37...   	
0A56: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x4*
0A5A: 37...   	
0A66: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x5*
0A6A: 37...   	
0A76: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x6*
0A7A: 37...   	
0A86: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0x7*
0A8A: 37...   	
0A96: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x8*
0A9A: A0A1A0A1	
0A9E: A0A1A0A1	
0AA2: A0A1A0A1	
0AA6: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0x9*
0AAA: A0A1A0A1	
0AAE: A0A1A0A1	
0AB2: A0A1A0A1	
0AB6: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xA*
0ABA: A0A1A0A1	
0ABE: A0A1A0A1	
0AC2: A0A1A0A1	
0AC6: A0A1A0A1		defb	_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA,_VDD,_VDA	; 0xB*
0ACA: A0A1A0A1	
0ACE: A0A1A0A1	
0AD2: A0A1A0A1	
0AD6: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xC*
0ADA: 37...   	
0AE6: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xD*
0AEA: 37...   	
0AF6: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xE*
0AFA: 37...   	
0B06: 37373737		defb	TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP,TRAP	; 0xF*
0B0A: 37...   	
              	
              	; ---------------------------
              	; ******** Variables ********
              	; ---------------------------
              	
              	.area	_BSS
              	
              	; Reflected state of control register
0C5C:         	bm_rom:
0C5C: 0000    		defs	2


; +++ segments +++

#CODE _TEXT    = $0100 =   256,  size = $06EA =  1770
#CODE _DATA    = $07EA =  2026,  size = $032C =   812
#DATA _BSS     = $0B16 =  2838,  size = $0148 =   328

; +++ global symbols +++

TRAP             = $0037 =    55  _DATA   KSG1000.asm:143
_BSS             = $0B16 =  2838  _BSS    KRISYS.asm:28 (unused)
_BSS_end         = $0C5E =  3166  _BSS    KRISYS.asm:28
_BSS_size        = $0148 =   328  _BSS    KRISYS.asm:28 (unused)
_DATA            = $07EA =  2026  _DATA   KRISYS.asm:27 (unused)
_DATA_end        = $0B16 =  2838  _DATA   KRISYS.asm:27
_DATA_size       = $032C =   812  _DATA   KRISYS.asm:27 (unused)
_TEXT            = $0100 =   256  _TEXT   KRISYS.asm:26 (unused)
_TEXT_end        = $07EA =  2026  _TEXT   KRISYS.asm:26
_TEXT_size       = $06EA =  1770  _TEXT   KRISYS.asm:26 (unused)
_VDA             = $00A1 =   161  _DATA   KSG1000.asm:145
_VDD             = $00A0 =   160  _DATA   KSG1000.asm:144
alloc_bank_map   = $0B17 =  2839  _BSS    MEMORY.asm:211
arg_size         = $0010 =    16  _BSS    RESOURCE.asm:17
banks_free       = $0B16 =  2838  _BSS    MEMORY.asm:205
bdos             = $0005 =     5  _TEXT   KRISYS.asm:49
bdos_con_in      = $0001 =     1  _TEXT   KRISYS.asm:51 (unused)
bdos_con_out     = $0002 =     2  _TEXT   KRISYS.asm:52
bdos_exit        = $0000 =     0  _TEXT   KRISYS.asm:50
bdos_open        = $000F =    15  _TEXT   KRISYS.asm:54
bdos_print       = $0009 =     9  _TEXT   KRISYS.asm:53
bdos_read        = $0014 =    20  _TEXT   KRISYS.asm:55
bios_set_dma     = $001A =    26  _TEXT   KRISYS.asm:56
bm_rom           = $0C5C =  3164  _BSS    KSG1000.asm:195
core_start       = $0776 =  1910  _TEXT   KSG1000.asm:17
cpm_command      = $0080 =   128  _TEXT   KRISYS.asm:58
cpm_exit         = $075A =  1882  _TEXT   KRISYS.asm:164
cpm_print        = $0747 =  1863  _TEXT   KRISYS.asm:143
in_handle        = $07E6 =  2022  _TEXT   KSG1000.asm:103
io_map_input     = $0916 =  2326  _DATA   KSG1000.asm:149
io_map_output    = $0A16 =  2582  _DATA   KSG1000.asm:169 (unused)
irq_handle       = $07E5 =  2021  _TEXT   KSG1000.asm:90
irq_init         = $06B5 =  1717  _TEXT   IRQ.asm:22
irq_keyb_off     = $070E =  1806  _TEXT   IRQ.asm:119 (unused)
irq_keyb_on      = $06F7 =  1783  _TEXT   IRQ.asm:95 (unused)
irq_vdp_off      = $06E0 =  1760  _TEXT   IRQ.asm:71 (unused)
irq_vdp_on       = $06C9 =  1737  _TEXT   IRQ.asm:47 (unused)
kri_stack        = $7000 = 28672  _TEXT   KRISYS.asm:90
kri_start        = $0725 =  1829  _TEXT   KRISYS.asm:111
mem_alloc        = $0165 =   357  _TEXT   MEMORY.asm:103
mem_empty        = $01A3 =   419  _TEXT   MEMORY.asm:177
mem_free         = $0186 =   390  _TEXT   MEMORY.asm:135
mem_free_all     = $0198 =   408  _TEXT   MEMORY.asm:161 (unused)
mem_map_init     = $0103 =   259  _TEXT   MEMORY.asm:30
nabu_ay_data     = $0040 =    64  _TEXT   KRISYS.asm:84
nabu_ay_latch    = $0041 =    65  _TEXT   KRISYS.asm:85
nabu_nctl        = $0000 =     0  _TEXT   KRISYS.asm:83 (unused)
nabu_vdp_addr    = $00A1 =   161  _TEXT   KRISYS.asm:87
nabu_vdp_data    = $00A0 =   160  _TEXT   KRISYS.asm:86
nmi_address      = $0066 =   102  _TEXT   KRISYS.asm:79
nmi_vector       = $0067 =   103  _TEXT   KRISYS.asm:80
out_handle       = $07E9 =  2025  _TEXT   KSG1000.asm:110
res_argument     = $0B9C =  2972  _BSS    RESOURCE.asm:480
res_bankmap      = $0C32 =  3122  _BSS    RESOURCE.asm:500
res_buffer       = $0BAF =  2991  _BSS    RESOURCE.asm:488
res_current      = $0BAD =  2989  _BSS    RESOURCE.asm:484
res_do_read      = $0C31 =  3121  _BSS    RESOURCE.asm:496
res_fcb          = $0C36 =  3126  _BSS    RESOURCE.asm:508
res_fcb_cr       = $0C56 =  3158  _BSS    RESOURCE.asm:518 (unused)
res_fcb_data     = $0C46 =  3142  _BSS    RESOURCE.asm:517 (unused)
res_fcb_drive    = $0C36 =  3126  _BSS    RESOURCE.asm:510
res_fcb_ex       = $0C42 =  3138  _BSS    RESOURCE.asm:513 (unused)
res_fcb_name     = $0C37 =  3127  _BSS    RESOURCE.asm:511
res_fcb_r0       = $0C57 =  3159  _BSS    RESOURCE.asm:519 (unused)
res_fcb_r1       = $0C58 =  3160  _BSS    RESOURCE.asm:520 (unused)
res_fcb_r2       = $0C59 =  3161  _BSS    RESOURCE.asm:521 (unused)
res_fcb_rc       = $0C45 =  3141  _BSS    RESOURCE.asm:516 (unused)
res_fcb_s1       = $0C43 =  3139  _BSS    RESOURCE.asm:514 (unused)
res_fcb_s2       = $0C44 =  3140  _BSS    RESOURCE.asm:515 (unused)
res_fcb_type     = $0C3F =  3135  _BSS    RESOURCE.asm:512
res_init         = $02A6 =   678  _TEXT   RESOURCE.asm:29
res_load         = $02B0 =   688  _TEXT   RESOURCE.asm:47
res_locate       = $0448 =  1096  _TEXT   RESOURCE.asm:360
res_missing      = $0339 =   825  _TEXT   RESOURCE.asm:153
res_open         = $0356 =   854  _TEXT   RESOURCE.asm:179
res_pointer      = $0C34 =  3124  _BSS    RESOURCE.asm:504
res_printzt      = $0439 =  1081  _TEXT   RESOURCE.asm:340
res_sectors      = $0C2F =  3119  _BSS    RESOURCE.asm:492
stack_size       = $0020 =    32          KRISYS.asm:31
str_arg_empty    = $084D =  2125  _DATA   RESOURCE.asm:464
str_arg_fail     = $0864 =  2148  _DATA   RESOURCE.asm:467
str_crlf         = $08D3 =  2259  _DATA   KRISYS.asm:207
str_load_a       = $083D =  2109  _DATA   RESOURCE.asm:457
str_load_b       = $0846 =  2118  _DATA   RESOURCE.asm:460
str_mem_empty    = $0815 =  2069  _DATA   MEMORY.asm:195
str_mem_init     = $07EA =  2026  _DATA   MEMORY.asm:189
str_mem_init_cnt = $080F =  2063  _DATA   MEMORY.asm:192
str_missing      = $087A =  2170  _DATA   RESOURCE.asm:470
str_prgm         = $08DA =  2266  _DATA   KSG1000.asm:125
str_ram_alloc    = $08F3 =  2291  _DATA   KSG1000.asm:129
str_rom          = $08D6 =  2262  _DATA   KSG1000.asm:121
str_splash       = $088D =  2189  _DATA   KRISYS.asm:202
str_vm_start     = $0904 =  2308  _DATA   KSG1000.asm:133
str_zmm_init     = $082B =  2091  _DATA   ZMM.asm:296
tohex            = $075F =  1887  _TEXT   KRISYS.asm:177
trap_a_value     = $6FFF = 28671  _TEXT   KRISYS.asm:91
trap_continue    = $06A2 =  1698  _TEXT   TRAP.asm:481
trap_entry       = $04B1 =  1201  _TEXT   TRAP.asm:19
trap_f_value     = $6FFE = 28670  _TEXT   KRISYS.asm:92
trap_init        = $06A9 =  1705  _TEXT   TRAP.asm:501
trap_io          = $04C4 =  1220  _TEXT   TRAP.asm:42 (unused)
trap_io_ex_out   = $055C =  1372  _TEXT   TRAP.asm:174
trap_io_ext      = $04E0 =  1248  _TEXT   TRAP.asm:62
trap_io_ind      = $05F3 =  1523  _TEXT   TRAP.asm:312
trap_io_inx      = $05B6 =  1462  _TEXT   TRAP.asm:253
trap_io_outd     = $0669 =  1641  _TEXT   TRAP.asm:426
trap_io_outx     = $062C =  1580  _TEXT   TRAP.asm:367
trap_sp_value    = $0C5A =  3162  _BSS    TRAP.asm:519
zmm_addr_hi      = $0032 =    50  _TEXT   KRISYS.asm:67 (unused)
zmm_addr_lo      = $0033 =    51  _TEXT   KRISYS.asm:68 (unused)
zmm_bnk0         = $0030 =    48  _TEXT   KRISYS.asm:61
zmm_bnk0_set     = $024E =   590  _TEXT   ZMM.asm:181
zmm_bnk0_state   = $0B98 =  2968  _BSS    ZMM.asm:310
zmm_bnk0_we      = $026E =   622  _TEXT   ZMM.asm:230 (unused)
zmm_bnk0_wp      = $0266 =   614  _TEXT   ZMM.asm:221
zmm_bnk1         = $0031 =    49  _TEXT   KRISYS.asm:62
zmm_bnk1_set     = $0254 =   596  _TEXT   ZMM.asm:191
zmm_bnk1_state   = $0B99 =  2969  _BSS    ZMM.asm:314
zmm_bnk1_we      = $027E =   638  _TEXT   ZMM.asm:248 (unused)
zmm_bnk1_wp      = $0276 =   630  _TEXT   ZMM.asm:239
zmm_bnk2         = $0032 =    50  _TEXT   KRISYS.asm:63
zmm_bnk2_set     = $025A =   602  _TEXT   ZMM.asm:201
zmm_bnk2_state   = $0B9A =  2970  _BSS    ZMM.asm:318
zmm_bnk2_we      = $028E =   654  _TEXT   ZMM.asm:266 (unused)
zmm_bnk2_wp      = $0286 =   646  _TEXT   ZMM.asm:257 (unused)
zmm_bnk3         = $0033 =    51  _TEXT   KRISYS.asm:64
zmm_bnk3_set     = $0260 =   608  _TEXT   ZMM.asm:211
zmm_bnk3_state   = $0B9B =  2971  _BSS    ZMM.asm:322
zmm_bnk3_we      = $029E =   670  _TEXT   ZMM.asm:284 (unused)
zmm_bnk3_wp      = $0296 =   662  _TEXT   ZMM.asm:275 (unused)
zmm_capt_res     = $007F =   127  _TEXT   KRISYS.asm:76 (unused)
zmm_capt_set     = $0070 =   112  _TEXT   KRISYS.asm:75 (unused)
zmm_capture      = $7000 = 28672  _TEXT   KRISYS.asm:71
zmm_ctrl         = $0034 =    52  _TEXT   KRISYS.asm:65
zmm_ctrl_set     = $01F0 =   496  _TEXT   ZMM.asm:83
zmm_ctrl_state   = $0B97 =  2967  _BSS    ZMM.asm:306
zmm_init         = $01AC =   428  _TEXT   ZMM.asm:22
zmm_irq_inter    = $0222 =   546  _TEXT   ZMM.asm:136 (unused)
zmm_irq_normal   = $022D =   557  _TEXT   ZMM.asm:147 (unused)
zmm_irq_off      = $0243 =   579  _TEXT   ZMM.asm:169 (unused)
zmm_irq_on       = $0238 =   568  _TEXT   ZMM.asm:158 (unused)
zmm_isr          = $0030 =    48  _TEXT   KRISYS.asm:66
zmm_map          = $8000 = 32768  _TEXT   KRISYS.asm:72
zmm_prgm_in      = $020C =   524  _TEXT   ZMM.asm:114
zmm_prgm_out     = $0217 =   535  _TEXT   ZMM.asm:125
zmm_set_real     = $0201 =   513  _TEXT   ZMM.asm:103
zmm_set_virt     = $01F6 =   502  _TEXT   ZMM.asm:92
zmm_top          = $C000 = 49152  _TEXT   KRISYS.asm:73
zmm_trap         = $0037 =    55  _TEXT   KRISYS.asm:69
zmm_vm_start     = $01C9 =   457  _TEXT   ZMM.asm:44


total time: 0.6427 sec.
no errors
